\chapter[Súčasný stav problematiky]{Úvod do súčasneho stavu problematiky}
\label{chap:uvod}

Myšlienka regulárnych výrazov bola prvýkrát spomenutá v teórii formálnych jazykov a automatov ako iný spôsob popisu regulárnych jazykov. Vtedy pozostávali z operácií zjednotenia, zreťazenia a Kleeneho uzáveru. Pre ich jednoduchosť boli implementované ako nástroj na vyhľadávanie slov zo špecifikovaného jazyka. Postupom času a s inšpiráciou zo strany užívateľov k nim pribúdali ďalšie operácie. Niektoré boli len skratkou k tomu, čo sa už dalo zapísať -- umožnili zapísať to isté menej znakmi -- ostatné otvárali dvere k popisu dovtedy nedosiahnuteľných jazykov.

Zmes týchto operácií nazývame moderné regulárne výrazy a zaujíma nás, kam sa až dostali v popisovaní jazykov v rámci Chomského hierarchie. Túto problematiku sme z väčšej časti rozobrali v bakalárskej práci \cite{mojaBak}. V tejto práci rozbor dokončíme a pozrieme sa na ne aj z hľadiska zložitosti.

\section{Základné definície}
\label{definicie}

Formálna definícia je uvedená v \cite{mojaBak}, tu si len neformálne uvedieme, s ktorými operáciami pracujeme a ako fungujú. Každý regulárny výraz sa skladá zo znakov a metaznakov. Znaky sú symboly, ktoré charakterizujú samé seba, teda $L(a) = \lbrace a \rbrace$. Metaznaky popisujú operáciu nad regulárnymi výrazmi. Ak potrebujeme použiť metaznak ako znak, stačí pred neho dať $\backslash$, teda $L(\backslash x) = \lbrace x \rbrace$. Ak metaznak vyžaduje vstup, je ním posledný znak/metaznak/uzátvorkovaný podvýraz pred ním. Metaznaky vyzerajú nasledovne:

\begin{itemize}
\item $\backslash$ -- robí z metaznakov obyčajné znaky
\item $()$ -- okrúhle zátvorky slúžia na oddeľovanie podvýrazov
\item | -- operácia zjednotenia (alternácia) -- musí vyhovovať ľavý alebo pravý podvýraz
\item $*$ -- Kleeneho uzáver -- predchádzajúci výraz opakuj ľubovoľný počet krát
\item $+$ -- opakuj 1 alebo viackrát
\item $\lbrace \rbrace$ -- zložené zátvorky sú používané ako $\{n,m\}$ (opakuj aspoň $n$ a najviac $m$-krát) a $\{n\}=\{n,n\}$ (opakuj $n$-krát)
\item $[~]$ -- hranaté zátvorky -- znaky vnútri tvoria množinu, z ktorej si vyberáme. Vieme použiť aj intervaly, napr. a--z, A--Z, 0--9, \dots a kombinovať ich. Všetky metaznaky vnútri [~] sa považujú za normálne znaky.
\item . -- ľubovoľný znak
\item ? -- ak samostatne: opakuj 0 alebo 1-krát \\
ak za operáciou: namiesto greedy implementácie použi minimalistickú, t.j. zober čo najmenej znakov (platí pre $*,+,?,\lbrace n,m \rbrace$)\footnote{všetky spomenuté operácie ,,žerú'' znaky a na ich implementáciu bol použitý greedy algoritmus}
\item $\textasciicircum$ -- metaznak označujúci začiatok slova; špeciálnym prípadom je výraz $[\textasciicircum\alpha]$ (kde $\alpha$ je nejaká množina znakov), ktorý špecifikuje ľubovoľný znak, ktorý sa v množine $\alpha$ nenacháza
\item \$ - metaznak označujúci koniec slova
\end{itemize}

Okrem operácií označených metaznakmi vznikli aj zložitejšie operácie, na popis ktorých treba dlhšie konštrukcie. V prvom rade sa zaviedlo \textbf{číslovanie okrúhlych zátvoriek}. Čísluje sa zľava doprava podľa poradia ľavej (otváracej) zátvorky. Toto číslovanie sa deje automaticky pri každom behu algoritmu, teda už pri písaní výrazu ho môžeme využívať. Popíšme si teraz zložitejšie operácie:

\begin{itemize}
\item \textbf{komentár} ozn. (?\#text komentáru) -- klasický komentár, určený čitateľom kódu; nemá vplyv na výraz, algoritmus ho ignoruje
\item \textbf{spätné referencie} ozn. $\backslash k$, $k \in\N$ -- môže sa nachádzať na ľubovoľnom mieste vo výraze ZA $k$-tou pravou (zatváracou) zátvorkou. Odkazuje sa na $k$-te zátvorky a presný význam sa určuje až pri hľadaní zhody na konkrétnom vstupe. Algoritmus si zapamätá aké podslovo zo vstupu matchoval výraz vnútri $k$-tych zátvoriek a presne toto podslovo hľadá, keď ďalej vo výraze narazí na $\backslash k$.
\\ Predpokladáme, že číslo $k$ je zapísané znakmi z inej abecedy ako zvyšok regexu -- t.j. je jednoznačne určiteľné, kde končí zápis $k$.\footnote{V implementovaných regexoch vieme deterministicky určiť, kde končí číslo $k$ -- sú povolené maximálne trojciferné čísla. My chceme všeobecnejší model, bez obmedzení na veľkosť $k$, a práve preto je tento predpoklad oprávnený. Zároveň si to môžeme dovoliť, lebo ak máme $k$ zapísané ako číslo v desiatkovej sústave, v teórii je jednoduché zasubstituovať hľadaný jazyk tak, aby neobsahoval znaky 0,\dots,9.}
\item \textbf{lookahead} -- tzv. nazeranie dopredu. Keďže anglický výraz je kratší a zvučnejší, rozhodli sme sa ho používať.
\begin{itemize}
\item \textbf{pozitívny} ozn. $\lookahead\alpha)$, kde $\alpha$ je nejaký moderný regulárny výraz 
\\ V momente, keď na lookahead narazíme si zapamätáme aktuálnu pozíciu v slove. Začneme hľadať zhodu s výrazom $\alpha$. Ak vyhlásil zhodu, vrátime sa naspäť na zapamätané miesto a odtiaľ pokračujeme v slove aj regulárnom výraze akokeby tam lookahead nikdy nebol. Inak povedané lookahead nevyžiera písmenká a robí akýsi prienik. Ak neobsahuje znak pre koniec slova \$, môže skončiť kdekoľvek -- je to v okamihu, keď zistil zhodu.
\item \textbf{negatívny} ozn. $\nlookahead\alpha)$, kde $\alpha$ je nejaký moderný regulárny výraz \\ Nesmie nájsť slovo z jazyka $L(\alpha)$. Postup je ako pri lookaheade, ale končí úspešne len ak neexistuje žiadne podslovo začínajúce na danom mieste v slove také, že by ho $\alpha$ akceptoval. Inak povedané, toto je pozitívny lookahead s obrátenou akceptáciou.
\end{itemize}
\item \textbf{lookbehind} -- tzv. nazeranie dozadu. Opäť budeme používať anglickú verziu pre jej stručnosť.
\begin{itemize}
\item \textbf{pozitívny} ozn. $\lookbehind\alpha)$, kde $\alpha$ je nejaký moderný regulárny výraz \\ Hľadá slovo z $L(\alpha)$ naľavo od aktuálneho miesta v slove (musí končiť na susediacom políčku vľavo od aktuálnej pozície v slove). Opäť nie je určená hranica slova, môže začínať kdekoľvek, ak nie je vynútený začiatok slova znakom $\textasciicircum$. 

Ak by sme chceli deterministický algoritmus, vyzeral by nasledovne: od teraz do konca vykonávania lookbehindu bude na pozícii, na ktorej v slove sme, bude teraz pre znak pre koniec slova -- endmarker. Najprv vyskúšame 1 susedný symbol naľavo, či patrí do jazyka. Ak nie skúsime čítať o jeden znak viac (2 symboly naľavo), keď neuspejeme, opäť posunieme pomyselný začiatok slova doľava. Ak akceptujeme, môže to byť len na endmarkeri. Ak sme neakceptovali a začiatok slova nejde viac posunúť, zamietneme.
\item \textbf{negatívny} ozn. $\nlookbehind\alpha)$, kde $\alpha$ je nejaký moderný regulárny výraz \\ Hľadá ako pozivíny lookbehind, ale akceptuje len ak neexistuje slovo z $L(\alpha)$ vyskytujúce sa naľavo od aktuálnej pozície.
\end{itemize}
\end{itemize}

Pre lookahead a lookbehind používame spoločný názov \underline{lookaround}, takisto s prívlastkom pozitívny/negatívny myslíme iba ich pozitívne/negatívne verzie.

Keďže sa týmito operáciami budeme zaoberať podrobnejšie, uvedieme pre upresnenie ich definície.

\begin{df}[Pozitívny lookahead]
$$ L_{1}(?=L_{2})L_{3} = \lbrace uvw ~|~ u \in L_{1} \land v \in L_{2} \land vw \in L_{3} \rbrace $$ Operáciu $(?=\dots)$ nazývame pozitívny lookahead alebo len \underline{lookahead}.
\end{df}

\begin{df}[Negatívny lookahead]
$$ L_{1}(?!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexistuje~také~x,y,~že~v=xy~a~x \in L_2 \rbrace $$ Operáciu $(?!\dots)$ nazývame \underline{negatívny lookahead}.
\end{df}

\begin{df}[Pozitívny lookbehind]
$$ L_{1}(?<=L_{2})L_{3} = \lbrace uvw ~|~ uv \in L_{1} \land v \in L_{2} \land w \in L_{3} \rbrace $$ Operáciu $(?<=\dots)$ nazývame pozitívny lookbehind alebo len \underline{lookbehind}.
\end{df}

\begin{df}[Negatívny lookbehind]
$$ L_{1}(?<!L_{2})L_{3} = \lbrace uv ~|~ u \in L_{1} \land v \in L_{3} \land neexituje~také~x,y,~že~u=xy~a~y \in L_2 \rbrace $$ Operáciu $(?<!\dots)$ nazývame \underline{negatívny lookbehind}.
\end{df}

Moderné regulárne výrazy sa skladajú z \textbf{konečného počtu} znakov, metaznakov a zložitejších operácií.

Pre korektné matchovanie regulárnym výrazom potrebujeme vedieť priority operácií. Niektoré sa správajú ako znak: $\left[~\right]$, ., \textasciicircum, \$, $\backslash k$, pozitívny a negatívny lookaround. Ostatné kombinujú znaky s nasledovnými prioritami:

\begin{tabular}{|c||c|c|c|c|}
\hline
priorita &3&2&1& 0  \\
\hline
operácia & () & $*$ + ? $\lbrace \rbrace$ & zreťazenie & | \\ \hline
\end{tabular}
\\ \par
Máme veľkú množinu operácií a budeme chcieť pracovať aj s jej podmnožinami, preto si zavedieme názvoslovie pre ich jednoznačnejšie a kratšie určenie.

\begin{description}
\item[$\re$] -- množina operácií, pomocou ktorých vieme popísať iba regulárne jazyky; presnejšie všetky znaky a metaznaky (bez zložitejších operácií)
\item[$\e$] -- $\re$ so spätnými referenciami
\item[$\le$] -- $\e$ s pozitívnym lookaroundom
\item[$\nle$] -- $\le$ s negatívnym lookaroundom
\item[$\rel$] -- trieda jazykov nad $\re$ ($= \R$)
\item[$\el$] -- trieda jazykov nad $\e$
\item[$\lel$] -- trieda jazykov nad $\le$
\item[$\nlel$] -- trieda jazykov nad $nle$
\end{description}

\section[Vlastnosti a sila]{Vlastnosti a sila moderných regulárnych výrazov}
\label{usila}

\todo opraviť referencie na vety z bakalárky

Potrebné vety z bakalárskej práce:

\begin{veta}[Veta 2.2.5.]\label{lookahead+R}
Regulárne jazyky sú uzavreté na lookaround.
\end{veta}

\begin{veta}[Veta 2.2.10.]\label{lookaround+R}
Trieda nad regexami s pozitívnym lookaroundom je $\R$.
\end{veta} 

\begin{veta}[Veta 2.2.14.]\label{le+lcs}
$ \lel \subseteq \L_{CS} $
\end{veta}

\section[Popisná zložitosť]{Popisná zložitosť moderných regulárnych výrazov}
\label{uzlozitost}

V čase, keď sme hľadali články týkajúce sa popisnej zložitosti moderných regulárnych výrazov, sme nenašli nič týkajúce sa tejto problematiky. Známe boli len výsledky pre regulárne výrazy s operáciami zjednotenia, zreťazenia a Kleeneho $*$ (RE), prípadne ešte prieniku a komplementu (GRE). Navyše mali ešte znak pre prázdny jazyk $\emptyset$ a prázdne slovo $\varepsilon$.

Spomeňme si najprv ako možno zadefinovať popisnú zložitosť \cite{newResults} \cite{compMeasures75}:

\begin{list}{$\bullet$}{Nech E je regulárny výraz, potom}
\item $|E|$ je jeho celková dĺžka
\item $rpn(E)$ je jeho celková dĺžka v reverznej poľskej notácii. Táto notácia oproti klasickej neobsahuje okrúhle zátvorky a používa explicitný metaznak pre zreťazenie~$\bullet$. Napríklad regulárny výraz $(a|ab)*(c|d)$ má 12 znakov a v reverznej poľskej notácii $aab\bullet |*cd|\bullet$ má 10 znakov.

Uvedomme si, že dĺžka reverznej poľkej notácie je rovnaká ako počet vrcholov v syntaktickom strome pre daný výraz. Preto možno vernejšie popisuje skutočnú zložitosť regulárneho výrazu (žiadne pomocné symboly, len znaky a operácie). Nakoľko však nie je veľmi prehľadná a ťažko sa v nej hľadajú chyby, nie je tak často používaná.
\item $|alph(E)|= N(E)$ je počet alfabetických symbolov v E
\item $H(E)$ je hĺbka vzhľadom na $*$, počet vnorení $*$
\item $L(E)$ je dĺžka najdlhšej neopakujúcej sa cesty cez výraz
\item $W(E)$ je šírka, počet zjednotených symbolov. Za touto mierou zložitosti nie je žiadna intuitívna predstava. Ako vidieť neskôr v definícii, dôvodom jej vzniku bola duálnosť k L.
\end{list}

V nasledujúcej tabuľke sú uvedené induktívne definície jednotlivých mier zložitosti. Zložitosť regulárneho jazyka vzhľadom na ľubovoľnú z týchto mier zložitosti je minimálna miera cez všetky regulárne výrazy pre daný regulárny jazyk.

\begin{tabular}{|c||c|c|c|c|}
\hline
 ~ & Alphabetical Symbol & E $\cup$ F & E $\cdot$ F & E*
\\ \hline\hline
N & 1 & $N(E)+N(F)$ & $N(E)+N(F)$ & $N(E)$
\\ \hline 
H & 0 & $max(H(E),H(F))$ & $max(H(E),H(F))$ & $H(E)+1$
\\ \hline
L & 1 & $max(L(E),L(F))$ & $L(E)+L(F)$ & $L(E)$
\\ \hline
W & 1 & $W(E)+W(F)$ & $max(W(E),W(F))$ & $W(E)$
\\ \hline
\end{tabular}
\\ \\

Ako pri mnohých iných modeloch, aj do regulárnych výrazov vieme zakomponovať časti, ktoré nič nerobia (okrem toho, že zaberajú miesto). V rámci skúmania najjednoduchších výrazov sa prišlo k nasledujúcim definíciám \cite{newResults}:

\begin{df}
Nech E je regulárny výraz nad abecedou $\Sigma$ a nech L(E) je jazyk špecifikovaný výrazom E. Hovoríme, že E je \textbf{zmenšiteľný}, ak platí nejaká z nasledujúcich podmienok:
\begin{enumerate}
\item E obsahuje $\emptyset$ a $|E|>1$
\item E obsahuje podvýraz tvaru FG alebo GF, kde L(F)={$\varepsilon$}
\item E obsahuje podvýraz tvaru $F|G$ alebo $G|F$, kde $L(F)=\lbrace \varepsilon \rbrace$ a $\varepsilon \in L(G)$
\end{enumerate}
Inak, ak žiadna z nich neplatí, E nazývame \textbf{nezmenšiteľným}.
\end{df}

V originále sa používajú výrazy \textit{collapsible} a \textit{uncollapsible}. Táto definícia neodhalí všetky zbytočne zopakované časti, napríklad $a|a$ je nezmenšiteľný, aj keď by sa dal zapísať jednoduchým $a$. Problém je, že identity výrazov nie sú konečne axiomatizovateľné (ani nad unárnou abecedou)\cite{newResults}. Teda nie je reálne určiť také pravidlá, aby sme dosiahli konečné zjednodušenie. 

\begin{df}
Ak E je nezmenšiteľný regulárny výraz taký, že
\begin{enumerate}
\item E nemá nadbytočné (); a zároveň
\item E neobsahuje podvýraz tvaru $F**$
\end{enumerate}
potom vravíme, že E je \textbf{neredukovateľný} (irreducible).
\end{df}

Môžeme vyvodiť, že minimálny regulárny výraz pre daný jazyk bude nezmenšiteľný a neredukovateľný, naopak to však nemusí platiť. S takýmto základom možno dokázať napríklad tvrdenie: Ak E je neredukovateľný a $|alph(E)| \geq 1$, potom $|E| \leq 11|alph(E)| - 4$.

Iné spôsoby na ohraničenie regulárnych výrazov poskytujú nasledujúce pozorovanie a veta.

\begin{veta}[Proposition 6 \cite{newResults}]
Nech L je neprázdny regulárny jazyk.

(a) Ak dĺžka najkratšieho slova v L je $n$, potom $|alph(E)| \geq n$ pre ľubovoľný regulárny výraz E, kde L(E) = L.

(b) Ak naviac L je konečný a dĺžka najdlhšieho slova v L je $n$, potom $|alph(E)| \geq n$ pre ľubovoľný regulárny výraz, kde L(E) = L.
\end{veta}

Definícia non-returning NKA hovorí, že sa nevracia do počiatočného stavu, t.j. žiadne prechody nevedú smerom do $q_0$.

\begin{veta}[Theorem 10]
Nech E je regulárny jazyk s $|alph(E)| = n$. Potom existuje non-returning NKA akceptujúci $L(E)$ s $\leq n+1$ stavmi a DKA akceptujúci L(E) s $\leq 2n+1$ stavmi.
\end{veta}

Rozbehnutých je viacero oblastí skúmania. Regulárne výrazy sú zaujímavé hlavne preto, že tvoria stručnejší popis jazyka a sú ekvivalentné automatom. S tým súvisí prvá oblasť. Skúma sa stavová zložitosť automatu ekvivalentného konkrétnemu výrazu a naopak tiež popisná zložitosť výrazu ekvivalentného konkrétnemu automatu. Dá sa to zhrnúť ako problémy konverzií medzi modelmi. Niektorí autori siahajú po väčšej abstrakcii a namiesto automatov uvažujú iba orientované grafy s hranami označenými symbolmi. Určia si parametre grafu a snažia sa napríklad čo najlepšie popísať cesty medzi vrcholmi.

Ďalšia oblasť zahŕňa operácie nad regulárnymi výrazmi. Jeden z problémov je napríklad vzťah popisnej zložitosti výrazu pre jazyk $L$ a $L^c$. Pre automaty existuje konštrukcia pre vyrobenie komplementu jazyka. Avšak pre komplementárny regulárny výraz to nie je také jednoznačné.

Ako poslednú by sme spomenuli problém najkratšieho slova nešpecifikovaného re\-gu\-lár\-nym výrazom. Predpokladajme regulárny výraz $E$, kde $|alph(E)|=n$ nad konečnou abecedou $\Sigma$, pričom $L(E)\neq \Sigma^*$. Aké dlhé môže byť najkratšie slovo NEšpecifikované výrazom $E$? Najzaujímavejší výsledok je pre výraz s $|alph(E)| = 75n + 361$, kde naj\-krat\-šie nešpecifikované slovo je dĺžky $3(2 n - 1)(n + 1) + 3$.
