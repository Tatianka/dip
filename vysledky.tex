\chapter{Naše výsledky}
\label{chap:vysledky}

\todo Sem by bolo fajn niečo napísať.

\section{Sila negatívneho lookaroundu}

V bakalárskej práci bol skúmaný hlavne pozitívny lookaround. Teraz si pozrieme na vlastnosti negatívneho lookaroundu. Budú to vety s podobným znením ako v prípade pozitívnej verzie. 

Pripomenieme, že negatívny lookahead skúša všetky prefixy a pokiaľ žiadny z nich nepatrí do jeho jazyka, akceptuje a hľadanie zhody môže pokračovať v regexe ďalej. Čo je jednoduché pri pozitívnej verzii -- stačí si nedeterministicky tipnúť ten správny prefix patriaci do jazyka -- to je komplikované pri tej negatívnej. Aby sme mohli s~istotou povedať, že akceptuje, potrebujeme deterministický algoritmus, ktorý vyskúša všetky možnosti. Preto veľakrát budeme budovať negatívny lookaround tak, že vezmeme nejaký deterministický model akceptujúci jeho jazyk a upravíme akceptáciu.

\begin{lema}\label{nla+R}
Trieda $\R$ je uzavretá na negatívny lookahead.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$. Ukážeme, že $L=L_1\nlookahead L_2)L_3 \in \R$.

Jazyky $ L_{1},L_{2},L_{3} $ sú regulárne, teda existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=\nobreak L_{i},\allowbreak~ i \in \lbrace 1,2,3\rbrace $. Zostrojíme NKA $A$ pre $L$.

Konštrukcia bude veľmi podobná ako v obdobnej vete pre pozitívny lookahead v \cite{mojaBak}, keď si správne predpripravíme $A_2$. Negatívny lookahead sa snaží za každú cenu nájsť slovo z $L_2$ (t.j. uspieť s $A_2$) a ak sa mu to nepodarí, akceptuje. Preto musíme zaručiť, že sa $A_2$ buď zasekne alebo prejde až do konca slova\footnote{Ak sa zasekne, slovo z $L_2$ tam určite nebude, lebo $A_2$ je deterministický a teda neexistuje akceptačný výpočet. Ak sa nezasekne, nevieme povedať o tom slove nič, pokiaľ ho neprejdeme celé.}. Akonáhle $A_2$ dosiahne akceptačný stav, negatívny lookahead musí zamietnuť. 

Ďaľšie pozorovanie nám hovorí, že negatívny lookahead akceptuje vždy nejaké slovo z komplementu $L_2$. Ale komplement vzhľadom na akú abecedu? V skutočnosti nekonečnú -- ľubovoľný znak, ktorý nepatrí do $\Sigma_2$, znamená zaseknutie $A_2$, t.j. akceptáciu. Ak sa na to pozrieme z väčšej ďiaľky, uvidíme $L_3$, s ktorým robíme prenik. $A_3$ musí dočítať slovo do konca a na úplne neznámom znaku sa zasekne, takže z pohľadu výslednej akceptácie slova nevadí, ak by kvôli tomu znaku zamietol už negatívny lookahead. Preto stačí urobiť komplement vzhľadom na $\Sigma_2 \cup \Sigma_3$. 

Poďme upravovať $A_2$, začneme vytváraním komplementu. Ak $\Sigma_3 \setminus \Sigma_2 \neq\emptyset$\footnote{Inak $A_2'=A_2$.}, potom vytvoríme $A_2'= (K_2',\Sigma_2',\delta_2',q_{0},F_2')$ tak, že pridáme nové znaky $\Sigma_2'=\Sigma_2 \cup \Sigma_3$,  jeden nový stav\footnote{Pre každý nový stav predpokladáme, že je jedinečný -- t.j. žiaden taký v množine stavov ešte nie je.} $K_2'=K_2 \cup \lbrace q_{ZLE} \rbrace$ a prechody na nové znaky z každého stavu: 
\begin{alignat*}{3}
& \forall q \in K_2, &&~ \forall a \in \Sigma_2 &&~~:~~  \delta_2'(q,a)=\delta_2(q,a) \\
& \forall q \in K_2, &&~ \forall a \in \Sigma_3 \setminus \Sigma_2 &&~~:~~ \delta_2'(q,a)=q_{ZLE} \\
&~&&~ \forall a \in \Sigma_2' &&~~:~~  \delta_2'(q_{ZLE},a)=q_{ZLE}
\end{alignat*}
 $F_2'=F_2.$ Do všetkých stavov sme pridali prechody na nové znaky a $q_{ZLE}$ má 1 prechod na každý znak, takže $A_2'$ je stále deterministický. Zároveň nové znaky vedú do stavu, z ktorého sa nedá dostať do žiadneho akceptačného, z čoho vyplýva $L(A_2')=L_2$.

Teraz $A_2'$ zmeníme na $A_2''$ tak, aby akceptoval práve vtedy, keď $\nlookahead L_2)$. Najprv si skonštruujeme množinu stavov, z ktorých sa vieme dostať do akceptačného stavu: $H=\nobreak\lbrace  q \in K_2'~|~ \exists w \in {\Sigma_2'}^*, ~ \exists q_A \in F_2': ~ (q,w)\vdash_{A_2'}(q_A,\varepsilon) \rbrace $, nasledovným spôsobom: $$ H_0 = F_2' $$ 
$$H_{i+1} = H_i \cup \lbrace q \in K_2'~|~ \exists p \in H_i ~~ \exists a \in \Sigma_2': ~ \delta(q,a)=p \rbrace$$
Zrejme $\exists j \in \N: ~ H_{j+1}=H_j = H$. Nás zaujíma množina $K_2' \setminus H$, v ktorej sa nachádzajú všetky stavy, z ktorých sa na žiadnu postupnosť znakov nedá dostať do žiadneho akceptačného stavu.

$A_2''= (K_2'',\Sigma_2'',\delta_2'',q_{0},F_2'')$: $$K_2'' = K_2' \cup \lbrace q_A, q_Z \rbrace, ~\Sigma_2'' = \Sigma_2', ~F_2'' = (K_2'\setminus H) \cup \lbrace q_A \rbrace$$

$\delta''$ je definovaná nasledovne: 
\begin{alignat*}{4}
 & \forall q \in K_2' \setminus F_2'  &~ \forall a \in \Sigma_2' ~&~:~~  \delta_2''(q&&,a)=\delta_2'(q,a) \\
 & \forall q \in K_2' \setminus F_2'  &~ \forall a \in \Sigma_2' ~&~:~~  \delta_2''(q&&,\varepsilon)=q_A \\
 & \forall q \in F_2' &~ \forall a \in \Sigma_2' ~&~:~~ \delta_2''(q&&,a)=q \footnotemark \\
 & ~ & ~\forall a \in \Sigma_2' ~&~:~~ \delta_2''(q_A&&,a)=q_Z 
\end{alignat*}
\footnotetext{Tento riadok v podstate netreba, $A_2''$ sa môže rovno zaseknúť, lebo $A_2'$ práve akceptoval.}
Je dobré poznamenať, že $A_2''$ je takmer deterministický. Chýbajú mu prechody z $q_Z$ -- môžeme ho nechať cykliť v tomto stave, ale nevadí nám ani keď sa zasekne. Nedeterministické rozhodnutie vykonáva iba jedno -- pri prechode do stavu $q_A$. Vtedy háda, že už je na konci slova. Ak nie je, $\delta$-funkcia ho pošle do stavu $q_Z$. Podľa toho je zrejmé, že ak existuje akceptačný výpočet a dočítal slovo do konca, je práve jeden\footnote{Okrem prípadu, kedy dočíta slovo a je v stave z $(K_2'\setminus H)$ -- vieme ho predĺžiť o krok na $\varepsilon$ a skončiť v $q_A$. Jadro výpočtu ale zostáva rovnaké -- jednoznačné.} \footnote{Zaujímavé je, že aj zamietací výpočet je pre každé slovo jednoznačný.}.

Tvrdíme $ L_1\lookahead L(A_2''))L_3 =L_1\nlookahead L_2)L_3= L $.
Keďže $A_1$ a $A_3$ sa pri oboch výpočtoch budú chovať rovnako (sú nezávislé od lookaheadov), nebudeme sa nimi pri dôkaze zaoberať.

$\subseteq :$ Máme akceptačný výpočet pre $A_2''$ na nejakom vstupe. Akceptačný stav mohol byť buď z množiny $K_2'\setminus H$, to znamená, že pôvodný automat $A_2'$ sa dostal do stavu, z ktorého už nemohol nijak akceptovať\footnote{Sem spadá aj prípad, keď $A_2$ prečítal neznámy znak a zasekol sa -- $A_2'$ zostáva až do konca slova v stave $q_{ZLE}$.}. V takom prípade $\nlookahead L_2)$ akceptuje. V druhom prípade mohol $A_2''$ akceptovať pomocou $q_A$, čo znamená, že dočítal slovo do konca (pretože z $q_A$ sa na ľubovoľný znak dostaneme do $q_Z$, v ktorom sa $A_2''$ zasekne a nebude akceptovať) a ani raz sa nedostal do akceptačného stavu automatu $A_2'$. Teda aj $\nlookahead L_2)$ akceptuje.

$\supseteq :$ Nech $\nlookahead L_2)$ akceptoval, t.j. na $A_2$ bol vykonaný nejaký neakceptujúci výpočet ($A_2$ je deterministický, takže existuje práve jeden pre každé slovo). Rovnakú postupnosť stavov bude mať aj výpočet na $A_2''$ (automat obsahuje všetky stavy aj $\delta$-funkciu z $A_2$, počiatočný stav je ten istý). Ak sa $A_2$ zasekol na neznámom znaku, v $A_2'$ na ten znak pridáme prechod do stavu $q_{ZLE}$ a v ňom zostaneme až do konca slova. Keďže $q_{ZLE}$ nie je v $A_2'$ akceptačný a nedá sa z neho na žiadne slovo dostať do ľubovoľného akceptačného stavu, $q_{ZLE} \in K_2' \setminus H$ a teda $q_{ZLE} \in F_2''$. Ak sa $A_2$ nezasekol, tak dočítal slovo do konca a v postupnosti stavov jeho výpočtu sa nenachádza žiaden z množiny $F_2$. V tom prípade $A_2''$ z posledného stavu prejde na $\varepsilon$ do $q_A$ (2. riadok definície $\delta_2''$) a akceptuje.

Z práve dokázaného tvrdenia a vety \ref{lookaround+R} už vyplýva aj platnosť našej lemy.
\end{proof}

\begin{lema}\label{nlb+R}
Trieda $\R$ je uzavretá na negatívny lookbehind.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=\nobreak L_{i},\allowbreak i \in \lbrace 1,2,3\rbrace $. Ukážeme, že $L=L_1\nlookbehind L_2)L_3 \in \R$.

Nemôžeme skonštruovať $A_2''$ také, že bude akceptovať práve vte\-dy, keď $\nlookbehind L_2)$, pretože nevieme čítať doľava -- teda nevieme zaručiť, že miesto, kde začína výpočet $A_2''$ je skutočný začiatok slova. Mechanizmus lookbehindu musí byť riadený zvonku, automatom pre $L$. Skonštruujeme ho. $C=(K,\Sigma, \delta,q_0,F):$ 
$$K=K_3\cup \lbrace (q,A) ~|~ q \in K_1 \wedge A \subseteq K_2 \rbrace,~\Sigma = \Sigma_1\cup\Sigma_2\cup\Sigma_3,~q_0=(q_{01},\lbrace q_{02}\rbrace),F=F_3$$
$\delta:$
\begin{alignat*}{5}
& \forall q \in K_1 ~&& \forall A \subseteq K_2  && ~ \forall a \in \Sigma_1 \cap \Sigma_2 &&~~:~~ \delta((q,A),a) \ni (\delta_1(q,a), B\cup \lbrace q_{02}\rbrace)\\ 
&                   ~&&                          && &&~~~~~~B=\lbrace r ~|~ \exists s \in A:~ \delta_2(s,a)=r \rbrace \\
& \forall q \in K_1 ~&& \forall A \subseteq K_2  &&~\forall a \in \Sigma_1 \setminus \Sigma_2 &&~~:~~ \delta((q,A),a) \ni (\delta_1(q,a),\lbrace q_{02}\rbrace) \\
& \forall q \in F_1 ~&& \forall A \subseteq K_2 \setminus F_2 && &&~~:~~ \delta((q,A),\varepsilon) \ni q_{03} \\
& \forall q \in K_3 ~&&                          &&~ \forall a \in \Sigma_3 &&~~:~~ \delta(q,a) \ni \delta_3(q,a)
\end{alignat*}
Prvý riadok $\delta$-funkcie hovorí, že $A_1$ a všetky rozbehnuté výpočty $A_2$ prejdú do ďalšieho stavu a zároveň sa rozbehne nový výpočet $A_2$. Ak by sme hľadali jeden akceptačný výpočet $A_2$ stačilo by tipnúť si začiatok a odtiaľ ho simulovať. Lenže simulujeme negatívny lookbehind, teda ak neexistuje akceptačný výpočet, tak my akceptujeme (prejdeme na simulovanie $A_3$, 4. riadok). A to vieme povedať len v prípade, že sme videli všetky možné výpočty. Keďže $A_2$ je deterministický, pre každé slovo existuje práve jeden výpočet a zároveň sa nikdy nezasekne (na svojej abecede), teda nám stačí skontrolovať množinu stavov $A$ vtedy, keď sa $C$ rozhodne, že $A_1$ končí výpočet. Ak v $A$ je nejaký akceptačný stav, potom $C$ nevie prejsť do stavu $q_3$. Tým pádom sa nedostane k simulovaniu $A_3$ a ani k svojim akceptačným stavom.

$L(C)=L.$

$\subseteq:$
Majme akceptačný výpočet $C$ na $w$. Z definície $F$ vyplýva, že $A_3$ akceptoval, teda $\exists u,v$ také, že $w=uv$ a $v \in L_3$. Do $q_{03}$ sa dá dostať len z dvojice $(q,A)$ takej, že $q\in F_1$, teda $u\in L_1$, a $A \cap F_2 = \emptyset$, teda $\nexists x,y$ také, že $u=xy$ a $y \in L_2$. To vyplýva z toho, že v každom znaku $u$ začal jeden výpočet na $A_2$ a žiaden z nich neakceptoval. Teda negatívny lookbehind akceptoval a $w\in L$.

$\supseteq:$
Nech $w\in L$, teda $\exists u,v$ také, že $w=uv,~ u \in L_1, v\in L_3$ a $\forall x,y:~u=xy$ platí $y \notin L_2$. Pre $u,v$ teda existujú akceptačné výpočty na $A_1,A_3$ a pre všetky $y$ neakceptačné na $A_2$. Z toho už vieme vyskladať akceptačný výpočet na $C$.
\end{proof}

\begin{veta}
Trieda $\R$ je uzavretá na negatívny lookaround.
\end{veta}

Zjavne konečné automaty si s negatívnym lookaroundom poradia. Pozrime sa teraz na model $\re$ s pridaným negatívnym lookaroundom. Najprv musíme skontrolovať kombinácie operácií ako v \cite[Lema. 2.2.8. a 2.2.9]{mojaBak}. Ukazuje sa, že aj tu dostávame rovnaké výsledky ako pri pozitívnej verzii.

\begin{lema}\label{nla*}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = \left( L_1 \left( ?!~ L_2\right) L_3 \right) * L_4$. Potom $L(\alpha) \in \R$.
\end{lema} 
\begin{proof}
Podobne ako v dôkaze vety \ref{nla+R} pretransformujeme $\nlookahead L_2)$ na akýsi $\lookahead L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $\nlookahead L_2)$. Potom $\beta = \left( L_1 \lookahead L(A_2'') ) L_3 \right) * L_4$, $L(\beta) = L(\alpha) \in \R$ podľa lemy k vete \ref{lookaround+R}.
\end{proof}

\begin{lema}\label{nlb*}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = L_4 \left( L_1 \left(?<!~ L_2\right) L_3 \right) *$. Potom $L(\alpha)~\in~\R$.
\end{lema} 
\begin{proof}
Použijeme konštrukciu ako v dôkaze vety \ref{nlb+R}, kde pretransformujeme $\nlookbehind L_2)$ na $\lookbehind L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $\nlookbehind L_2$. Z toho vznikne $\beta = L_4 \left( L_1 \left(?<=~ L(A_2'')\right) L_3 \right) *$, $L(\beta) = L(\alpha) \in \R$ podľa lemy k vete \ref{lookaround+R}.
\end{proof}

\begin{veta}\label{nlookaround+R}
Trieda nad regexami s negatívnym lookaroundom je $\R$.
\end{veta}
\begin{proof}
Podobne ako v dôkaze vety \ref{lookaround+Regex} je netriviálna iba kombinácia operácií negatívny lookaround a $*$. Podľa liem \ref{nla*} a \ref{nlb*} máme stále regulárne jazyky.
\end{proof}

\begin{dosledok}
Trieda nad regexami s pozitívnym a negatívnym lookaroundom je $\R$.
\end{dosledok}
\begin{proof}
Lookaround nevyžiera písmenká, takže neovplyvňuje zvyšok regexu, teda ani iné lookaroundy. Musíme vyriešiť iba prípad, kedy je do seba vnorených niekoľko pozitívnych a negatívnych lookaroundov. V takejto situácii vieme postupovať z najvnútornejšieho regexu s lookaroundom s hĺbou vnorenia 1. Jeho jazyk je regulárny a teda ho vieme prepísať na regex z $\re$. Takýmto spôsobom vieme zvnútra von prepisovať regex, až skončíme s regexom z $\re$, teda matchujúcim regulárny jazyk.
\end{proof}

\section{Vlastnosti triedy $\lel$}

Pridanie nových operácií medzi regulárne výrazy síce pridalo na sile modelu, ale mohlo pokaziť jeho uzáverové vlastnosti. Vieme, že regulárne jazyky sú uzavreté na všetky možné operácie, ktoré poznáme. Posilnenie modelu spätnými referenciami a následne lookaroundom však ohrozilo uzavretosť na základnú operáciu regulárnych výrazov -- zreťazenie. Pokiaľ zreťazíme 2 regexy obsahujúce lookahead alebo lookbehind, tieto operácie začnú zasahovať do slova z vedľajšieho jazyka. Ak by išlo o zreťazenie so zarážkou (napr. $\alpha\#\beta$), na koniec každého lookaheadu v $\alpha$ by stačilo pripojiť $.*\#$, prípadne znak \$ nahradiť znakom \#. Podobne by sme v regexe $\beta$ pridali na začiatok každého lookbehindu $\#.*$ prípadne by sme vymenili znak $\textasciicircum$  znakom \#. Potom by tieto operácie zostali ,,skrotené'' na území slova, ktoré danému regexu prislúcha.

Otázka nastáva, ako to spraviť, keď zarážku k dispozícii nemáme. Odpoveďou je nasledujúca veta.

\begin{veta}
Trieda $\lel$ je uzavretá na zreťazenie.
\end{veta}
\begin{proof}
Nech $\alpha, \beta\in \le$. Chceme ukázať, že jazyk $L(\alpha)L(\beta) \in \lel$. Intuitívne nás to vedie k riešeniu $\alpha\beta$, čo ale nemusí byť vždy správne. Problémom sú operácie lookaround, presnejšie každý lookahead v $\alpha$ môže zasahovať do slova z $L(\beta)$ a takisto každý lookbehind z $\beta$ môže zasahovať do slova z $L(\alpha)$. Navyše, ak lookahead obsahuje $\$$ a lookbehind $\textasciicircum$, potom zasahujú do slova z iného jazyka určite. V takom prípade môže regex $\alpha\beta$ vynechať niektoré slová z $L_1L_2$ a tiež pridať nejaké nevhodné slová naviac. Preto treba nájsť spôsob, ako operácie lookaroundu vhodne ,,skrotiť''. Predpokladajme, že $\alpha$ má $k$ označených zátvoriek, potom regex pre jazyk $L(\alpha)L(\beta)$ vyzerá nasledovne:
\begin{equation} \label{zretazenie}
\lookahead \mathop(_1 \alpha \mathop)_1 \mathop(_{k+2}\beta \mathop)_{k+2} \mathdollar) \alpha ' \backslash \text{$k$+2} ~\lookbehind \textasciicircum\backslash 1\beta ')
\end{equation}
V $\alpha,\beta$ treba vhodne prepísať spätné referencie podľa nového prečíslovania zátvoriek. $\alpha '$ je $\alpha$ prepísaný tak, že pre každý lookahead:
\begin{itemize}
\item bez \$ -- na koniec pridáme $.* \backslash \text{$k$+2} ~\mathdollar $
\item s \$ -- pred \$ pridáme $\backslash \text{$k$+2}$
\end{itemize}
$\beta '$ je $\beta$ prepísaný tak, že pre každý lookbehind:
\begin{itemize}
\item bez $\textasciicircum$ -- na začiatok pridáme $\textasciicircum \backslash 1.*$
\item s $\textasciicircum$ -- za $\textasciicircum$ pridáme $ \backslash 1$
\end{itemize}
Čo presne robí regex ~\ref{zretazenie}? Nech $w$ je vstupné slovo, ktoré chceme matchovať. Lookahead na začiatku ho nejako rozdelí na $w_1$ a $w_2$, pričom $w=w_1w_2$, tak, že $w_1$ bude patriť do $L(\alpha)$ a podslovo $w_2$ do $L(\beta)$. Ešte musíme overiť, či $\alpha$ matchuje $w_1$ samostatne.

Preto sme v $\alpha$ prepísali všetky lookaheady. V $\alpha '$ každý z nich musí na konci slova $w$ matchovať $w_2$ (toto zabezpečí spätná referencia $\backslash \text{$k$+2}$ a \$) a teda matchovanie regexu $\alpha$ zostane výlučne na podslove $w_1$. Analogicky to platí pre upravené lookbehindy v~$\beta '$.

\end{proof}

\section[Chomského hierarchia]{Zaradenie do Chomského hierarchie}

\begin{veta}\label{lelcf}
$\lel$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Majme jazyk $L=\lbrace ww~|~w \in \lbrace a,b \rbrace^* \rbrace \in \L_{CF}$, nech $ \alpha = ([ab]*)\backslash 1 $.
Zrejme $ L(\alpha) = L $, teda $L\in \lel$.

Ukážeme, že jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace \notin \lel$. Sporom, nech $L \in \lel$. 

Vieme, že $L \notin \el$, preto musí obsahovať nejaký lookaround. Zároveň z $L \notin \R$ a vety \ref{lookaround+Regex} vyplýva, že musí obsahovať aj spätné referencie.

Kam sa môžu spätné referencie odkazovať a kam ich potom môžeme umiestniť?
\begin{list}{$\bullet$}{Nech výraz, na ktorý ukazujú, vyrobí nejaké:}
\item $a^i$, potom $\backslash k$ musí byť v prvej polovičke slova (medzi $a$, inak by pokazil štruktúru slova), takže nevplýva na časť s $b$ a teda sa zaobídeme bez nich.
\item $a^ib^j$, potom $\backslash k$ by mohol byť len medzi $b$, ale tam by pokazil štruktúru slova $a^nb^n$
\item $b^j$, potom $\backslash k$ môže byť len medzi $b$ a je tam zbytočný z rovnakých dôvodov, aké má prípad $a^i$
\end{list}
Vidíme, že so spätnými referenciami dosiahneme rovnaký výsledok ako bez nich, čo je spor s tým, že sa vo výraze musia nachádzať (bez nich vieme urobiť len regulárny jazyk).
\end{proof}

\begin{dosledok}
$\lel \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$ \nlel \subseteq \L_{CS} $
\end{veta}
\begin{proof}
Vieme, že $ \lel \in \L_{CS} $ (veta \ref{le+lcs}), teda ľubovoľný regex z $\le$ vieme simulovať pomocou LBA. Ukážeme, že ak pridáme operáciu negatívny lookahead/lookbehind, vieme to simulovať tiež.

Nech $\alpha \in \nle$. Potom nech $A$ je LBA pre $\alpha$, ktorý ignoruje negatívny lookaround (t.j. vyrábame LBA pre regex z $\le$). Teraz vytvoríme LBA $B$ pre regex vnútri negatívneho lookaroundu. Z nich vytvoríme LBA $C$ pre úplný regex $\alpha$ tak, že $C$ bude simulovať $A$ a keď príde na rad negatívny lookaround zaznačí si, v akom stave je $A$ a na ktorom políčku skončil. Skopíruje slovo na ďalšiu stopu a na nej simuluje od/do toho miesta $B$ (podľa toho, či je to lookahead alebo lookbehind). 

Teraz je to s akceptáciou náročnejšie ako pri pozitívnom lookarounde. Pokiaľ $B$ akceptoval, $C$ sa zasekne. Ak sa $B$ zasekol, $C$ sa vráti naspäť k zastavenému výpočtu $A$ a pokračuje v ňom. Keďže slovo je konečné a $B$ na ňom testuje regex, ktorý postupne vyjedá písmenká, určite raz príde na koniec slova. Môže sa stať, že bude skúšať viaceré možnosti -- napr. skúsi pre $*$ zobrať menej znakov, teda príde na koniec slova viackrát. Ako určíme, že skončil výpočet? Bez újmy na všeobecnosti môžeme predpokladať, že sa $B$ nezacyklí, ale zamietne slovo na konci výpočtu. To preto, že všetkých možností na rozdelenie znakov medzi operácie $*,+,?,\lbrace n,m\rbrace$ je konečne veľa a keď ich systematicky skúša\footnote{Algoritmus pre $*$ je v praxi greedy. Ak slovo nesedí, tak sa vráti, odoberie posledný znak zožratý $*$ a opäť skúša zvyšok výrazu, či slovo sedí. Ak stále nevyhovuje, algoritmus odoberá hviezdičke znaky dovtedy, dokým nenájde zhodu alebo odoberie všetky znaky -- vtedy sa mu minuli všetky možnosti a môže slovo zamietnuť.}, raz sa mu musia minúť. To znamená, že ak nemá v $\delta$-funkcii umelo vsunuté zacyklenie, nezacyklí sa. Teda ak slovo neakceptuje, tak ho určite zamietne a vtedy $C$ môže prejsť na zastavený výpočet $A$ a pokračovať v ňom.

Podobne ako pri lookarounde aj jeho negatívna verzia môže obsahovať vnorený negatívny lookaround. Tých však môže byť iba konečne veľa, keďže každý regex musí mať konečný zápis. Čo znamená, že aj stôp bude konečne veľa a naznačeným postupom si vieme postupne vybudovať LBA, ktorý bude simulovať $\alpha$.
\end{proof}

\TODO check \& rewrite
\begin{veta}
$\nlel$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Opäť použíjeme jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace$ a budeme dokazovať sporom. Nech $L \in \lel$.

Z vety \ref{lelcf} vidíme, že výraz musí obsahovať negatívny lookaround. Z jej dôkazu vidíme, že spätné referencie nepomôžu, nech sa ich pokúsime hocijako použiť. Z toho vyplýva, že ich nepoužijeme a z vety \ref{nlookaround+R} zistíme, že nám zostal model schopný vyrobiť iba regulárne jazyky. Spor.
\end{proof}

\begin{dosledok}
$\nlel \subsetneq \L_{CS}$
\end{dosledok}

\TODO obkec o tom, že doplniť substitúciu nestačí
\TODO ?? a čo keby sme pridali aj reverz ?? (pozn. obe operácie len upravujú spätné referencie)

\section{Priestorová zložitosť}

\begin{veta}
$\lel \subseteq NSPACE(\log n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
Ukážeme, že ľubovoľný $\alpha \in \le$ vieme simulovať nedeterministickým Turingovým strojom s jednou vstupnou read-only páskou a jednou pracovnou páskou, na ktorej použijeme maximálne logaritmický počet políčok.

Celý regex si budeme uchovávať v stavoch\footnote{Každý regex je má z definície konečnú dĺžku, to znamená aj konečný počet stavov.} a pridáme doňho špeciálny znak $ \blacktriangleright $, ktorým si budeme ukazovať, kam sme sa v regexe dopracovali -- bude to akýsi smerník na znak, ktorý práve spracovávame. Teda stav bude vyzerať takto: $q_{\beta\blacktriangleright\xi}$ (pre lepšiu čitateľnosť budeme uvádzať namiesto stavu iba jeho dolný index: $\beta\blacktriangleright\xi$), kde $\beta\xi = \alpha$, časť $\beta$ sme už namatchovali na vstup a práve sa chystáme pokračovať časťou $\xi$. Ak $\blacktriangleright$ ukazuje na znak, porovnáme ho s aktuálnym znakom na vstupnej páske. Pokiaľ sa nezhodujú, výpočet sa zasekne. Pri zhode pokračujeme až kým sa nám neminie vstup aj regex. Ak $\blacktriangleright$ ukazuje na metaznak, potom zistíme o akú operáciu ide (ak má viac znakov, treba na to niekoľko stavov -- napr. lookahead) a začneme ju vykonávať.

Pracovná páska bude slúžiť ako úložisko smerníkov na rôzne miesta vstupnej pásky. Bude mať formát $A_1\#A_2\#\dots\#A_m$. Adresu nejakého políčka na vstupnej páske vieme zapísať v priestore $\log n$. Ak ukážeme, že $m$ je konštanta, potom $m.\log n \in O(\log n)$. Adresa $A_1$ bude rezervovaná pre prvý adresný slot na aktuálnu pozíciu hlavy na vstupe, nech si ju máme odkiaľ okopírovať, keď treba. Adresy budeme využívať pri operáciách spätná referencia, lookahead a lookbehind.

Keďže celý regex vidíme pri konštrukcii Turingovho stroja, vieme si do stavov zakódovať význam a poradie adresných slotov. A celú pracovnú pásku si predpripraviť (napísať potrebný počet \#). 

Teraz skonštruujeme Turingov stroj $M = \left( K, \Sigma, \delta, q_0, F \right)$ k regexu $\alpha$. 
$$ K = \lbrace \beta\blacktriangleright\xi ~|~ \beta,\xi \textit{ sú podslová } \alpha \textit{ také, že } \beta\xi = \alpha \rbrace $$
$$ \Sigma = \Sigma(\alpha)\footnote{T.j. všetky znaky a metaznaky použité v regexe $\alpha$.}, ~
q_0 = \blacktriangleright\alpha, ~
F = \lbrace \alpha\blacktriangleright \rbrace $$
\underline{$\delta:$ (v tvare: stav, znak čítaný na vstupnej páske)} 

Kvôli prehľadnosti popíšeme len hlavné kroky algoritmu. 
\begin{list}{}{}
\item $\delta(\beta\blacktriangleright a \xi, a) = \lbrace (\beta a \blacktriangleright \xi, 1) \rbrace ~ \forall a \in \Sigma$ -- Ak je v regexe znak, matchujeme ho s tým na vstupe.
\item $\delta(\beta\blacktriangleright(\gamma)\xi, a) = \lbrace (\beta(\blacktriangleright\gamma)\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku pre $\backslash k$.
\item $\delta(\beta(\gamma\blacktriangleright)\xi, a) = \lbrace (\beta(\gamma)\blacktriangleright\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu konca pre $\backslash k$. Používame polootvorený interval -- znak na koncovej adrese do podslova nepatrí.
\item $\delta(\beta\blacktriangleright(\gamma)*\xi, a) = \lbrace (\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Pri Kleeneho $*$ máme možnosť vykonať aj 0 iterácií, teda zátvorky preskočiť. Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku aj konca pre $\backslash k$.
\item $\delta(\beta(\gamma)\blacktriangleright * \xi, a) = \lbrace (\beta(\blacktriangleright\gamma)*\xi, 0),(\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Kleeneho $*$: buď opakujeme alebo pokračujeme ďalej.
\item $\delta(\beta\blacktriangleright\backslash k \xi, a) = \lbrace (q_{najdi\_zaciatok(k)}, 0) \rbrace$ -- Najprv si zapamätáme aktuálnu pozíciu na vstupe (ďalej označovanú ako 'aktuálna pracovná pozícia'). Stav $q_{najdi\_zaciatok(k)}$ zodpovedá presunu hlavy na vstupnej páske na začiatočnú pozíciu podslova. Tu začneme algoritmus porovnávania podslov podľa definície spätnej referencie -- aké podslovo matchujú $k$-te zátvorky, také isté musí ležať aj na 'aktuálnej pracovnej pozícii'. Algoritmus bude porovnávať vždy postupne po jednom znaku od začiatočnej pozície (ľavá zátvorka) po (koniec - 1) (pravá zátvorka):

\begin{verbatim}
pokiaľ zaciatok != koniec: 
    zapamätaj si znak 
    začiatok++ 
    presuň hlavu na pozíciu 'aktuálna pracovná pozícia' 
    porovnaj znak (ak nesedí, zasekni sa) 
    (aktuálna pracovná pozícia)++ 
    presuň hlavu na pozíciu 'začiatok' 
presuň hlavu na pozíciu 'aktuálna pracovná pozícia'
\end{verbatim}
Vidíme, že si dočasne potrebujeme zapamätať adresu 'aktuálna pracovná pozícia', ale po skončení tohto algoritmu ju môžeme zahodiť.

Po úspešnom zbehutí algoritmu TS prejde do stavu $\beta\backslash k \blacktriangleright\xi$.
\item $\delta(\beta\blacktriangleright\lookahead\gamma)\xi, a) = \lbrace (\blacktriangleright\gamma, 0) \rbrace$ -- Lookahead: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske a spracujeme regex vnútri lookaheadu. Ak uspejeme, presunieme hlavu na vstupnej páske naspäť na zapamätanú pozíciu a pokračujeme v regexe ďalej: $\delta(\gamma\blacktriangleright, a) = \lbrace (\beta\lookahead\gamma)\blacktriangleright\xi, 0) \rbrace $.
\item $\delta(\beta\blacktriangleright\lookbehind\gamma)\xi, a) = \lbrace (doľava\_ \gamma, 0) \rbrace$
-- Lookbehind: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske. Toto je zarážka pre lookbehind -- svoje matchovanie musí skončiť na tejto pozícii tak, že tento znak už neberie do úvahy. Nedeterministicky sa vrátime o niekoľko políčok doľava ($\delta(doľava\_ \gamma, a) = \lbrace(doľava\_ \gamma,-1), (\blacktriangleright\gamma, 0)\rbrace$)  a skúsime matchovať regex v lookbehinde. Keď uspejeme, porovnáme aktuálnu pozíciu so zarážkou. Ak sú rôzne, Turingov stroj sa zasekne. Inak pokračuje vo výpočte ďalej, od tejto pozície: $\delta(\gamma\blacktriangleright\_overene, a) = \lbrace (\beta\lookbehind \gamma)\blacktriangleright\xi, 0) \rbrace $.
\end{list}

\textbf{\underline{Počet adries}}:

Pre \textbf{spätné referencie} potrebujeme vždy 2 adresy -- na začiatok a koniec. Ak sa náhodou budú $k$-te zátvorky opakovať, napr. kvôli Kleeneho $*$, v definícii stojí, že sa vždy berie do úvahy posledný výskyt, takže adresy prepisujeme pri každom opakovaní. V prípade, že sa $k$-te zátvorky nachádzajú vnútri lookaheadu/lookbehindu, tiež máme pre ne rezervované 2 sloty. Algoritmus porovnávania potrebuje 1 ďalšiu adresu -- aktuálnu pracovnú pozíciu. Po jeho dokončení adresu môžeme vymazať (tzn. v ďalšom výpočte prepísať niečím iným).

V prípade \textbf{lookaheadu a lookbehindu} spotrebujeme len 1 adresný slot a to tiež len dočasne -- dokým sa operácia celá nevykoná. Potom je nám tento údaj zbytočný. Tieto operácie však môžu byť vnorené a tak v najhoršom prípade zaberú $p.\log n$ priestoru, ak ich počet je $p$.

Ak máme 1 rezervovaný slot pre aktuálnu adresu, $s$ spätných referencií, $l_a$ lookaheadov a $l_b$ lookbehindov, najviac spotrebujeme $(1+2s+1+l_a+l_b)\log n$ priestoru. Celý regex $\alpha$ je konečne dlhý, teda počet operácií je konečný. Čo znamená, že $m=1+2s+1+l_a+l_b$ je konštanta a to sme chceli dokázať.

\end{proof}


\begin{veta}[Savitch \cite{Savitch}]
Nech $S(n)\geq \log n$ je páskovo konštruovateľná, potom 
$$ NSPACE(S(n)) \subseteq DSPACE(S^2(n)) $$
\end{veta}

\begin{dosledok}
$\lel \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{dosledok}

Keď už máme deterministický model pre pozitívny lookaround, vieme triedu rozšíriť aj o ten negatívny.
\begin{veta}
$\nlel \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
Dôkaz tejto vety uvedieme neskôr. Najprv si zavedieme niekoľko nových pojmov. Keďže sa budeme opierať o dôkaz Savitchovej vety \cite{Savitch_skripta}, bude to akási forma konfigurácií, inšpirovaná definíciou Turingovho stroja.

\begin{df}
\textbf{Konfiguráciou} regexu $\alpha = r_1 \dots r_n$ nazývame dvojicu $(r, w)$, kde $r \in (\lceil\alpha)\cup(\alpha\lceil)\cup(r_1 \dots \lceil r_i \dots r_n)$ $w \in \Gamma^*\lceil~ \Gamma^*$ a sybmol $\lceil$ ukazuje, kde sa nachádzame vo výpočte v regexe a v slove.
\end{df}

\begin{df}
Konfiguráciu $(r_1 \dots r_n \lceil, w_1\dots w_m \lceil)$ nazývame \textbf{akceptačná}.
\end{df}

\begin{df}
Zátvorka $($ v regexe $\alpha$ je \textbf{indexovateľná}, ak sa bezprostredne za ňou nenachádza metaznak ? a zároveň sa nenachádza vnútri negatívneho lookaroundu.
\end{df}
Je zakázané odkazovať sa spätnými referenciami na operácie formy $(?\dots )$, preto ich ani nechceme a nebudeme brať do úvahy v poradí zátvoriek. Z týchto operácií sa v našom modeli nachádza iba pozitívny a negatívny lookaround. Je povolené odkazovať sa na zátvorky vnútri lookaroundu, takže sa vieme odvolať na podslovo, čo sa zhoduje s pozitívnou formou (ak lookaround považujeme za neindexovateľné zátvorky, stačí ho prepísať do formy $\lookahead (\dots ))$ a vieme sa referencovať na jeho obsah). Problém nastáva pri jeho negatívnej verzii -- podľa definície nesmie nájsť žiadnu zhodu, inak sa výpočet zastaví. Potom po akceptácii nedefinuje žiadne podslovo, na ktoré by sme sa mohli odvolať. To isté platí o ľubovoľných zátvorkách v jeho vnútri.
\TODO ale na samotné matchovanie vnútri potrebuje aj spätné referencie

\begin{df}
Zátvorka $)$ v regexe $\alpha$ je \textbf{indexovateľná}, ak k nej prislúchajúca otváracia zátvorka je indexovateľná.
\end{df}

\begin{df}
Nech regex $\alpha \in \nle$ obsahuje alternáciu. Potom jeho podslovo $\beta$ nazývame \textbf{alternovateľným}, ak je validným regexom z $nle$ a zároveň zodpovedá jednej z týchto podmienok:
\begin{enumerate}[(i)]
\item \textbf{prvá} \\ $\beta$ je prefix $\alpha$ alebo znak pred $\beta$ je ( \footnote{Z podmienky hovoriacej, že $\beta$ musí byť validný regex, vyplýva, že prislúchajúca ) sa bude nachádzať až za metaznakom |} 
\\ $\wedge$ za $\beta$ nasleduje metaznak |
\item \textbf{stredná} \\ znak pred $\beta$ je | \\ $\wedge$ $\beta$ je dobre uzátvorkovaný výraz \\ $\wedge$ za $\beta$ nasleduje |
\item \textbf{posledná} \\ znak pred $\beta$ je | \\
$\wedge$ $\beta$ je sufix $\alpha$ alebo za $\beta$ nasleduje ) \footnote{To isté ako pri podmienke $(i)$ -- prislúchajúca ( sa musí nachádzať pred metaznakom | (susediacim s $\beta$)}
\end{enumerate}
\end{df}

\begin{lema}
Alternácia používa iba alternovateľné regexy.
\end{lema}
\begin{proof}
Ukážeme indukciou na počet alternácií v regexe.

Majme regex $\alpha \in \nle$, ktorý obsahuje alternáciu. Bez újmy na všeobecnosti nech je to práve 1 alternácia (potenciálne zložená z viacerých metaznakov |). Podľa tabuľky priorít vieme, že alternácia má najnižšiu prioritu. Regex $\alpha$ môže byť v takýchto tvaroch:
\begin{enumerate}
\item $\beta_1|\dots|\beta_n$
\item $\alpha_1(\beta_1|\dots|\beta_n)\alpha_2$
\end{enumerate}
Pre $\alpha_1,\alpha_2,\beta_i\in\nle$ $i\in\lbrace 1,\dots,n\rbrace$. Je zrejmé, že $\beta_1$ spĺňa podmienku prvého alternovateľného regexu, $\beta_i$ pre $i\in\lbrace 2,\dots,n-1\rbrace$ spĺňajú podmienku pre stredný alternovateľný regex a $\beta_n$ spĺňa podmienku pre posledný alternovateľný regex.

Nech platí pre regexy obsahujúce $m-1$ alternácií, že tieto alternácie používajú iba alternovateľné regexy. Zoberme teraz regex $\alpha \in \nle$ obsahujúci $m$ alternácií. Opäť vieme $\alpha$ rozdeliť buď spôsobom 1. alebo 2. na validné regexy z $\nle$. Každý z $\beta_1,\dots,\beta_n,\alpha_1,\alpha_2$ obsahuje najviac $m-1$ alternácií, teda alternácie v týchto regexoch používajú iba alternovateľné regexy. Navyše je zrejmé, že aj regexy $\beta_1,\dots,\beta_n$ majú tvar alternovateľných regexov.
\end{proof}

Na základe definovania pojmu alternovateľnosti vieme jednoznačne určiť, ktoré regexy patria ku ktorej alternácii. Dôležité je, že to vieme naprogramovať do Turingovho stroja -- pre každú alternáciu bude skúmať, či je ohraničená zátvorkami alebo rozdeľuje celý regex na časti (teda či nastáva prípad 1. alebo 2. z dôkazu predchádzajúcej vety).

V nasledujúcej definícii kroku výpočtu budeme používať v konfiguráciách poschodové symboly. Informáciu o tom, aké písmenko na danej pozícii leží budeme potrebovať neustále -- tá bude aj súčasťou poschodovej varianty písmenka. Špeciálna informácia vo vyšších poschodiach bude patriť k spätným referenciám a lookaroundu. Už z definície spätných referencií vieme, že informácia o tom, aké podslovo predstavuje $\backslash k$ získame až počas výpočtu na konkrétnom slove. Referencia $\backslash k$ predstavuje posledné podslovo matchované $k$-tymi zátvorkami. Preto informácia o jeho pozícii musí byť súčasťou konfigurácie. Zároveň potrebujeme informáciu o každom lookaheade/lookbehinde -- a to pozíciu v slove, kde začal matchovanie, aby sme sa po jeho vykonaní mohli na túto pozíciu vrátiť. Opäť to je informácia, ktorú získame až pri výpočte na konkrétnom vstupe a preto si ju uchováme do poschodového symbolu.

Každý regex má konečný počet operácií, preto aj poschodí v poschodových symboloch bude konečne veľa. Pre každú spätnú referenciu potrebujeme 2 miesta (začiatok a koniec podslova) a pre každý lookaround 1 miesto.

Poschodové symboly sú veľmi prehľadné, čo sa týka zápisu konfigurácií. Z pohľadu výpočtu nejakého Turingovho stroja však môžu byť veľmi nepraktické. Pokiaľ nepoznáme regex dopredu, je to o to ťažšia interpretácia. Preto vo výpočtoch Turingovho stroja necháme vstup nedotknutý a informáciu pre jednotlivé operácie budeme reprezentovať vo forme adries ukazujúcich na konkrétnu pozíciu v slove.

\begin{df}
\textbf{Krok výpočtu} je relácia $\vdash$ na konfiguráciách definovaná nasledovne (najprv napíšeme, čoho sa jednotlivé kroky týkajú a potom uvedieme formálny zápis):

\begin{enumerate}[I.]
\item Prečítame rovnaké písmeko v regexe aj v slove.
\item V regexe ukazujeme na (, ktorá je $k$-ta indexovateľná. V slove si zaznačíme do poschodového symbolu, že na tejto pozícii začína podslovo ku $k$-tym zátvorkám. V regexe prejdeme za zátvorku.
\\ Pokiaľ za $k$-tymi zátvorkami nasleduje $*$, môžeme sa rozhodnúť ich celé preskočiť (až za $*$). V tom prípade si na poschodový symbol zaznačíme začiatok aj koniec podslova.
\item V regexe ukazujeme na ), ktorá je $k$-ta indexovateľná. V slove si zaznačíme do poschodového symbolu, že znak na tejto pozícii už do podslova ku $k$-tym zátvorkám nepatrí. V regexe prejdeme za zátvorku.
\item Narazili sme na začiatok alternácie (začiatok jej prvého alternovateľného regexu). Musíme si zvoliť jednu z jej možností. Buď budeme plynule pokračovať ďalej a spracovávať prvý alternovateľný regex alebo skočíme na začiatok ľubovoľného ďalšieho alternovateľného regexu z tejto alternácie.
\item V alternácii sme práve dokončili matchovanie jednej z možností -- ukazujeme na metaznak |. Skočíme v regexe za posledný alternovateľný regex.
\item Ukazujeme na Kleeneho $*$, ktorej predchádza písmenko. Máme 2 možnosti. Buď sa rozhodneme pokračovať -- preskočíme v regexe $*$ -- alebo spravíme ďalšiu iteráciu -- skočíme pred písmenko.
\item Ukazujeme na Kleeneho $*$, ktorej predchádzajú $k$-te zátvorky. Možnosti sú rovnaké ako v prípade s písmenkom. Rozdiel je len v tom, ak sa rozhodneme spraviť ďalšiu iteráciu. Potom musíme zmazať predošlý záznam k podslovu ku $k$-tym zátvorkám a zaznačiť si túto pozíciu ako jeho začiatok.
\item Narazili sme na znak spätných referencií $\backslash k$. Do slova si na túto pozíciu umiestníme pomocný ukazovateľ $\intercal$.
\item Stále ukazujeme na $\backslash k$ a v slove už máme umiestnený $\intercal$ a písmenko za ním neobsahuje značku konca podslova ku $k$-tym zátvorkám. Porovnávame písmenká v slove na pozíciách s normálnym a pomocným ukazovateľom. Pokiaľ sa zhodujú, posunieme obe pozície o 1 ďalej.
\item Stále ukazujeme na $\backslash k$, v slove je umiestnený $\intercal$ a ukazuje na písmenko zo značkou konca podslova ku $k$-tym zátvorkám. Odstránime zo slova $\intercal$ a v regexe sa posunieme za $\backslash k$.
\item Narazili sme na pozitívny lookahead. Zaznačíme si do poschodového symbolu v slove, že na tejto pozícii začína a v regexe skočíme do lookaheadu.
\item Skončili sme matchovanie lookaheadu, ukazujeme na jeho ). V slove skočíme na zaznačený začiatok a vymažeme túto značku. V regexe skočíme za ).
\item Narazili sme na pozitívny lookbehind. Zaznačíme si do poschodového symbolu v slove, že na tejto pozícii začína. V slove skočíme o niekoľko symbolov nazad (ľubovoľná pozícia medzi začiatkom slova a súčasnou, vrátane týchto 2) a v regexe skočíme do lookbehindu.
\item Skončili sme matchovanie lookbehindu, ukazujeme na jeho ). Zároveň v slove ukazujeme na jeho zaznačený začiatok. Zmažeme túto značku a v regexe prejdeme za ).
\item Narazili sme na negatívny lookahead. Pokiaľ neexistuje postupnosť konfigurácií taká, že regex v negatívnom lookaheade by matchoval nejaký prefix slova začínajúc od súčasnej pozície v slove, potom môžeme lookahead preskočiť.
\item Narazili sme na negatívny lookbehind. Pokiaľ neexistuje postupnosť konfigurácií taká, že regex v negatívnom lookbehinde by matchoval nejaký sufix slova končiac na súčasnej pozícii v slove, potom môžeme lookahead preskočiť.

\end{enumerate}

Formálny zápis:
\begin{enumerate}[I.]\label{dfkonfig}
\item $\forall a \in \Sigma: ~(r_1 \dots \lceil a \dots r_n, w_1 \dots \lceil a \dots w_m) \vdash (r_1 \dots a\lceil \dots r_n, w_1 \dots a \lceil \dots w_m)$
\item Nech ( je indexovateľná, $k$-ta v poradí: $\displaystyle{ (r_1 \dots \lceil ( \dots r_n, w_1 \dots \lceil w_j \dots w_m)}$ $$(1) \vdash (r_1 \dots (\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^k \dots w_m)$$
Ak za jej uzatváracou zátvorkou nasleduje $*$, t.j. $\alpha$ je tvaru $r_1 \dots \lceil ( \dots ) * \dots r_n$, potom $$ (2) \vdash (r_1 \dots (\dots )* \lceil \dots r_n, w_1 \dots \lceil \mathop{\mathop{w_j}^k}^{k'} \dots w_m ) $$
\item Nech ) je indexovateľná, $k$-ta v poradí: $$ (r_1 \dots \lceil ) \dots r_n, w_1 \dots \lceil w_j \dots w_m) \vdash (r_1 \dots )\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^{k'} \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie: $(r_1 \dots \lceil \alpha_1 | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$(1) \vdash \textit{ďalší prechod v }\alpha_1$$
$$(2) \vdash (r_1 \dots \alpha_1 | \lceil \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
$$\dots$$
$$(A) \vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \lceil \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie, potom pre všetky možnosti:
\\ $(r_1 \dots \alpha_1 \lceil | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$,
\\ $(r_1 \dots \alpha_1 | \alpha_2 \lceil | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
\\ \dots, \\ $(r_1 \dots \alpha_1 | \alpha_2 | \dots | \alpha_{A-1} \lceil | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$\vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \alpha_{A-1} | \alpha_A \lceil \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item $(r_1\dots a\lceil *\dots r_n, w_1\dots\lceil w_j\dots w_m)$
$$(1) \vdash (r_1\dots a *\lceil\dots r_n, w_1\dots\lceil w_j\dots w_m)$$
$$(2) \vdash (r_1\dots \lceil a *\dots r_n, w_1\dots\lceil w_j\dots w_m)$$
\item $\displaystyle{(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k\lceil * \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)\footnotemark}$
\footnotetext{Podľa definície spätných referencií platí podsledné podslovo nájdené regexom v $k$-tych zátvorkách. Pri tejto pracovnej pozícii v regexe je zrejmé, že nejde o prvý prechod cez tieto zátvorky a teda existuje také $a,b$, že $k$ je v slove nad $w_a$ a $k'$ nad $w_b$. Ak nastane prechod (2), pôvodné horné indexy $k, k'$ miznú a pridáva sa $k$ nad $w_j$.}
$$(1) ~\vdash(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k *\lceil \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)$$
$$(2) ~\vdash(r_1 \dots \mathop{(}_k\lceil r_i \dots r_l\mathop{)}_k * \dots r_n, w_1 \dots w_a \dots w_b \dots \lceil \mathop{w_j}^k \dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots\mathop{w_b}^{k'}\dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\ldots\intercal\mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)$$	

\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal w_c \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$, kde $a\leq c < b$ a zároveň $w_c = w_j$\footnote{$w_c$ a $w_j$ môžu byť poschodové symboly, avšak pri tejto rovnosti poschodia ignorujeme -- chceme porovnať iba písmenká v slove, prislúchajúce týmto pozíciám.}
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots w_c\intercal \dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal  \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots  \backslash k \lceil \dots r_n,w_1\dots\mathop{w_a}^k\dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item Nech $\lookahead \dots$) je $k$-ty pozitívny lookahead v poradí: 
\\ $\displaystyle{(r_1\dots \lceil \lookahead \dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash(r_1\dots \lookahead\lceil\dots) \dots r_n, w_1\dots\lceil \mathop{w_j}^{\mathop{k}^\rightarrow}\dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookaheadu v poradí: 
\\ $\displaystyle{(r_1\dots \lookahead\dots\lceil) \dots r_n, w_1\dots \mathop{w_l}^{\mathop{k}^\rightarrow}\dots\lceil w_j\dots w_m )} $
$$ \vdash(r_1\dots \lookahead\dots)\lceil \dots r_n, w_1\dots \lceil w_l \dots w_j\dots w_m ) $$
\item Nech $\lookbehind\dots)$ je $k$-ty pozitívny lookbehind v poradí, $\forall L\in\lbrace 0,\dots, j-1\rbrace$:
\\ $\displaystyle{(r_1\dots \lceil \lookbehind\dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash (r_1\dots \lookbehind\lceil\dots) \dots r_n, w_1\dots\lceil w_{j-L}\dots \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookbehindu v poradí:
\\ $\displaystyle{(r_1\dots \lookbehind\dots\lceil) \dots r_n, w_1\dots \lceil \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m )}$
$$ \vdash(r_1\dots \lookbehind\dots)\lceil \dots r_n, w_1 \dots \lceil w_j \dots w_m ) $$
\item Ak $\nexists p \in \lbrace j,\dots,m\rbrace: (\lceil r_k\dots r_l,\lceil w_j\dots w_p) \vdash^* (r_k\dots r_l\lceil, w_j\dots w_p \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookahead r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookahead r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item Ak $\nexists p \in \lbrace 1,\dots,j-1\rbrace: (\lceil r_k\dots r_l,\lceil w_p\dots w_{j-1}) \vdash^* (r_k\dots r_l\lceil, w_p \dots w_{j-1} \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookbehind r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookbehind r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\end{enumerate}

\end{df}

Prechody XV. a XVI. sa môžu zdať ťažkopádne, ťažko overiteľné. Nie je však šikovný spôsob ako krokmi znázorniť, že sa niečo nedá. Môžeme si to však predstaviť tak, že k vnútornému regexu máme zostrojený deterministický Turingov stroj, ktorý vie postupovať podľa krokov I. -- XIV. a má obrátenú akceptáciu. Teda ak by chcel akceptovať, zamietne, a ak sa zasekne/zamietne, tak akceptuje.

Táto úvaha nezahŕňa vnorené negatívne lookaroundy. Potrebný Turingov stroj sa však dá zostrojiť aj tak. Keďže každý regex musí byť konečnej dĺžky, nejaký z tých negatívnych lookaroundov musí byť najviac vnorený -- bez vnorených negatívnych lookaroundov. Práve k nemu vieme zostrojiť vyššie popísaný Turingov stroj. Potom Turingov stroj pre negatívny lookaround, ktorý ho obaľuje bude spúšťať tento Turingov stroj a tak ďalej, vieme zostrojovať Turingove stroje zvnútra von. Pri výpočte sa potom budú navzájom volať zvonka smerom dnu.

\begin{df}
\textbf{Jazyk} generovaný regexom $\alpha$ je množina $$L(\alpha) = \lbrace w~|~platí ~ (\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil) \rbrace$$
\end{df}

\textbf{Poznámka.}
Postupnosť konfigurácií $(\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil)$\footnote{Bez ohľadu na to, čo obsahujú vyššie poschodia symbolov vo $w$.} pre daný regex $\alpha$ a slovo $w$ nazývame \textbf{akceptačný výpočet}. Konfiguráciu $(\lceil \alpha,\lceil w)$ nazývame počiatočnou a $(\alpha\lceil,w\lceil)$ akceptačnou konfiguráciou.

\begin{lema}\label{dlzka_vypoctu_rw}
Nech $\alpha \in \el$ a $w \in L(\alpha)$. Potom existuje akceptačný výpočet, ktorý má najviac $3\cdot|\alpha|\cdot|w|^2$ konfigurácií.
\end{lema}
\begin{proof}
Pri prechodoch medzi konfiguráciami I., II., III., IV., V., VI.(1), VII.(1), IX., XI., XIV., XV. a XVI. sa ukazovateľ posúva vždy vpred buď v slove alebo v regexe alebo v oboch. Keby sme využívali iba tieto prechody, akceptačný výpočet má najviac $\left\vert{\alpha}\right\vert+|w|$ konfigurácií.

Existujú prechody, pri ktorých sa žiaden ukazovateľ nepohne: VIII. a X. Tieto prechody nastávajú pri spätných referenciách a jedná sa o objavenie sa alebo zmiznutie pomocného ukazovateľa. Pri každej spätnej referencii nastávajú oba javy práve jedenkrát. Zároveň počet spätných referencií je najviac $|\alpha|$, teda tieto 2 konfigurácie sa objavia dokopy najviac $(2\cdot\left\vert{\alpha}\right\vert)$-krát.

Akceptačný výpočet, ktorý obsahuje iba doteraz spomenuté kroky výpočtu obsahuje najviac $|w|+3|\alpha|$ konfigurácií. Zostali kroky výpočtu, v ktorých ukazovateľ skáče dozadu, rozoberme si ich postupne:

VI.(2),VII.(2) -- v prípade Kleeneho $*$ nastáva ďalšie opakovanie. Keďže $w\in L(\alpha)$, existuje pre $w$ akceptačný výpočet. Takýchto výpočtov môže byť viac, napríklad ak sa v $\alpha$ vyskytuje regex $(\beta)*$ taký, že $\varepsilon \in L(\beta)$. Potom existuje nekonečne veľa výpočtov, ktoré sa líšia v počte prechodov týmto regexom. Z nich si vyberieme najkratší akceptačný výpočet. Vyberme si ľubovoľnú $*$ a sled jej iterácií v nejakom momente výpočtu\footnote{Táto $*$ môže mať viac sledov iterácií, pokiaľ je vnútri regexu, ktorý je v poli pôsobnosti inej $*$. Ak táto vonkajšia $*$ vykonáva niekoľko (>1) iterácií, potom vnútorná $*$ je v každej z nich spúšťaná odznova. Teda môže existovať niekoľko jej sledov iterácií.}, nech je ich počet $k$. Pokiaľ $k=0$, potom je to krok II.(2) a ten sme už zarátali. V prípade $k=1$ opať krok VI.(2) ani VII.(2) nenastali. Nech teda $k>1$. Tvrdíme, že každá iterácia okrem poslednej v tomto slede matchovala aspoň 1 písmenko. Ukážeme to sporom. Nech nejaká $i$-ta, $i<k$, matchovala prázdne slovo. Potom ale túto operáciu možno vymazať zo sledu, napojiť konfigurácie a máme kratší výpočet, čo je spor. Tvrdenie neplatí pre poslednú iteráciu, pretože pokiaľ je iterovaný regex v zátvorkách, posledná iterácia ovplyvňuje podslovo, ktoré bude vyjadrené spätnými referenciami a jej vymazanie by mohlo pokaziť akceptačný výpočet. Takýto sled využíva $(k-1)$-krát prechod VI.(2) alebo VII.(2), teda prvé písmenko je zadarmo. Zároveň však platíme naviac za 1 návrat naviac v VII.(2), pokiaľ chceme mať posledné slovo $\varepsilon$. Predstavme si preto, že platíme za prvé písmenko a neplatíme za posledný prechod na prázdne slovo -- v takomto prípade získame horný odhad počtu konfigurácií, lebo na záver nemusí byť zakaždým $\varepsilon$ a zároveň podľa tvrdenia prvý prechod musí byť na písmenko.

Odhadnime teraz dĺžku najkratšieho akceptačného výpočtu aj s použitím krokov VI.(2) a VII.(2). Celkovo počet návratov môže byť najviac $|w|$, pretože každá iterácia, za ktorú platíme návratom, musí matchovať aspoň 1 písmenko. Medzi 2 návratmi používame nenávratové kroky, ktorých je najviac $|w|+3|\alpha|$. Preto akceptačný výpočet obsahujúci doteraz spomenuté kroky výpočtu bude mať najviac $|w|\cdot(|w|+3|\alpha|) \leq 3\cdot|w|^2\cdot|\alpha|$ konfigurácií.
\end{proof}

Príkladom toho, že táto lema poskytuje tesný odhad, je jazyk $(a*b*c*d*e*)*$ a slovo $edcba$. V najkratšom akceptačnom výpočte v každom opakovaní $*$ naozaj nájdeme zhodu práve s jedným písmenkom.

V praxi často regex dopredu nepoznáme. Vstupným údajom je text na vyhľadávanie a rovnako aj regex, ktorý znázorňuje požiadavku na vyhľadávanie. Tento problém predstavuje jazyk $$L(regex\#word) = \lbrace word~|~word \in L(regex) \wedge regex \in \cal U \rbrace$$
kde ${\cal U} \in \lbrace \re ,\e ,\le ,\nle \rbrace$.

\begin{veta}
$L(regex\#word) \in NSPACE(n \log n)$, kde $regex \in \le$. (Presnejšie $NSPACE(r \log w)$, kde $r = |regex|$ a $w = |word|$.)
\end{veta}
\begin{proof}
\TODO
Zostrojíme nedeterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na pracovných páskach zapíše najviac $O(r\log w)$ políčok.

Na pracovnej páske 
\end{proof}

\begin{veta}
$L(regex\#word) \in DSPACE(n \log^2 n)$, kde $regex \in \le$ a $n$ je dĺžka vstupu.
\end{veta}
\begin{proof}
Pre účely dôkazu budeme označovať $w = |word|$ a $r = |regex|$.

Zostrojíme deterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na každej pracovnej páske použije najviac $O(n\log^2 n)$ políčok. M bude mať vstupnú read-only pásku a 2 pracovné pásky.

Myšlienka je podobná dôkazu Savitchovej vety \cite{Savitch_skripta} -- M bude vykonávať funkciu $TESTUJ(C_1,C_2,i)$, ktorá zistí, či sa vieme dostať z konfigurácie $C_1$ do konfigurácie $C_2$ na $i$ krokov. 

Podľa lemy \ref{dlzka_vypoctu_rw} vieme, že ak existuje akceptačný výpočet pre $w$, potom existuje aj akceptačný výpočet taký, ktorý má najviac $3rw^2$ konfigurácií. Na základe tohto výsledku bude M zisťovať, či sa z počiatočnej konfigurácie $C_0$ vieme dostať do akceptačnej konfigurácie $C_a$ na $3rw^2$ krokov -- $TESTUJ(C_0,C_a,3rw^2)$.

Pseudokód procedúry $TESTUJ$:
\lstset{numbers=left, tabsize=4, morekeywords={if,then,return,true,false}}
\begin{lstlisting}[mathescape]
bool $TESTUJ(C_1,C_2,i)$
	if ($C_1 == C_2$) then return true
	if ($i>0 ~\wedge~ C_1\vdash C_2$) then return true
	if ($i<=1$) return false
	iteruj cez vsetky konfiguracie $C_3$
		if ($TESTUJ(C_1, C_3,\lfloor \frac{i}{2}\rfloor) ~\wedge ~TESTUJ(C_3, C_2,\lceil \frac{i}{2}\rceil)$) then return true
	return false
\end{lstlisting}

Pre podrobnejší popis pseudokódu je nutné, aby sme najprv definovali tvar konfigurácie. Použijeme zápis z definície \ref{dfkonfig}, v tvare $(a_1\dots \lceil a_i \dots a_r, b_1 \dots\lceil b_j \dots b_w)$ respektíve $(a_1\dots \lceil a_i \dots a_r, b_1 \ldots \intercal b_l \dots \lceil b_j \dots b_w)$, kde $a_1\dots a_r = regex$ a $b_1\dots b_w = word$. Reprezentovať ich budeme vo forme 2 resp. 3 adries -- pracovná pozícia v regexe ($i$), pracovná pozícia v slove ($j$) a adresa k spätnej referencii ($l$). Namiesto poschodových symbolov si M bude pre každú konfiguráciu pamätať informáciu, ktoré zátvorky zodpovedajú ktorému podslovu slova $word$. Pre každé zátvorky si uloží 2 adresy -- začiatok podslova a 1 políčko za koncom podslova (použijeme polootvorený interval $\langle za\v{c},kon)$). Pre každý lookahead a každý lookbehind bude mať vyhradené 1 adresné miesto aby si zapamätal, kam do slova ukazoval, keď naňho narazil.

Popis pseudokódu:
\begin{description}
\item[riadok 2] Ak $C_1=C_2$, potom vieme prejsť z $C_1$ do $C_2$ na ľubovoľný počet krokov.
\item[riadok 3] Platí $C_1 \neq C_2$. Ak $i=0$, nevieme prejsť do žiadnej inej konfigurácie ako $C_1$, teda vrátime \textbf{false}. Nech $i>0$. Skontrolujeme podľa definície \ref{dfkonfig}, či platí $C_1 \vdash C_2$. Konfigurácie sú uložené na páske ako $m$-tice, kde $m = 3+2\cdot (\text{počet zátvoriek})+(\text{počet lookaheadov})+(\text{počet lookbehindov})$: $C_1 = (d_1,\dots, d_m)$, $C_2=(e_1,\dots,e_m)$. Nech $d_1, e_1$ sú pracovné pozície v regexe, $d_2,e_2$ sú pracovné pozície v slove a $d_3,e_3$ pracovné pozície ukazovateľa pre spätné referencie, pričom $d_3,e_3$ môžu byť nedefinované (na prislúchajúcom mieste medzi oddeľovačmi adries nebude nič zapísané). TS M overí, či je splnená nejaká z týchto podmienok (rímske čísla zodpovedajú tým v definícii \ref{dfkonfig}):
\begin{enumerate}[I.]
\item $regex[d_1]=word[d_2]~\wedge~(e_1,\dots,e_m) = (d_1+1,d_2+1,nedef,d_4, \dots, d_m)$
\item (1) $regex[d_1]=$'('$ \\ ~\wedge~regex[d_1]$ je indexovateľná 
\\ $\wedge$ nech $d_k$ prislúcha k $regex[d_1]$, $4\leq k \leq m$: $e_k=d_2$ (sedí začiatok podslova) 
\\ $ \wedge ~(e_1,\dots, e_m) = (d_1+1,d_2,nedef,d_4,\dots,d_{k-1},d_2,d_{k+1},\dots,d_m)$
\setcounter{enumi}{1}
\item (2) $regex[d_1]=$'('$ \\ \wedge$ 2 políčka pred pozíciou $e_2$ je v regexe '$)*$' $ 
\\ \wedge$ zátvorky $regex[d_1]$ a $regex[e_1-2]$ sú k sebe prislúchajúce\footnote{To M skontroluje tak, že si overí, že medzi nimi ku každej '(' existuje ')' -- teda počet výskytov '(' a ')' musí byť rovnaký.} 
\\ $\wedge$ nech $d_k$ prislúcha k $regex[d_1],~4\leq k\leq m$: $e_k=e_{k+1}=d_2$ (začiatok a koniec podslova je nastavený na to isté políčko)
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+l, d_2,nedef,d_4,\dots,d_{k-1},e_k,e_{k+1},d_{k+2},\dots,d_m)$ pre $l\in\nobreak\N$
\item podobne ako II.(1) -- kontrola, či sedí koniec podslova
\item $regex[e_1-1] =$'|' \\ $\wedge$ regex medzi $d_1$ a najbližším metaznakom | je alternovateľný \\ $\wedge$ všetky regexy ohraničené | medzi $d_1$ a $e_1$ sú alternovateľné 
\\ $\wedge~ (e_1,\dots, e_m)=(d_1+l,d_2,nedef,d_4,\dots,d_m)$ pre $l\in\N$
\item $regex[d_1] =$'$|$'
\\ $\wedge$ všetky regexy ohraničené $|$ medzi $d_1$ a $e_1$ sú alternovateľné
\\ $\wedge$ regex medzi $e_1$ a najbližším metaznakom $|$ naľavo od neho je alternovateľný
\\ $\wedge~ (e_1,\dots, e_m)=(d_1+l,d_2,nedef,d_4,\dots,d_m)$ pre $l\in\N$
\item (1) $regex[d_1]=$'$*$'$~\wedge~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{5}
\item (2) $regex[d_1]=$'$*$'
\\ $\wedge~ regex[d_1-1]=a,~a\in\Sigma$
\\ $\wedge~(e_1,\dots,e_m)=(d_1-1,d_2,nedef,d_4,\dots,d_m)$
\item (1) $regex[d_1]=$'$*$'$~\wedge~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{6}
\item (2) $regex[d_1]=$'$*$'$ \\ \wedge~regex[e_1-1]=$'(' a prislúcha k $regex[d_1]$ 
\\ $\wedge$ nech $d_k,d_{k+1}$ prislúchajú k týmto zátvorkám, potom $e_k=d_2$, $e_{k+1}=\nobreak nedef$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1-l,d_2,nedef,d_4,\dots,d_{k-1},e_k,e_{k+1},d_{k+2},\dots, d_m)$ pre $l\in\nobreak\N$
\item $regex[d_1] =$'$\backslash$' 
\\ $\wedge$ nasleduje číslo $k$, $0\leq k \leq$ (počet indexovateľných zátvoriek) 
\\ $\wedge ~ (e_1,\dots,e_m)= (d_1,d_2,d_{2k+2},d_4,\dots,d_m)$ ($d_{2k+2}$ je adresa začiatku podslova prislúchajúca ku $k$-tym zátvorkám)
\item na pozícii $d_1$ je podslovo '$\backslash k$'
\\ $\wedge$ podobne ako I.-- musí platiť $d_3<d_{2k+3}$ a správne sa posunú adresy $d_2,d_3$
\item na pozícii $d_1$ je podslovo '$\backslash k$' 
\\ $\wedge ~ d_3=d_{2k+3}$ 
\\ $\wedge ~(e_1,\dots, e_m)=(d_1,d_2,nedef,d_4,\dots,d_m)$
\item na pozícii $d_1$ je podslovo '$\lookahead$' 
\\ $\wedge$ nech $d_l$ adresa prislúchajúca k tomuto lookaheadu: $e_l=d_2$, teda 
\\ $(e_1,\dots,e_m)=(d_1+3,d_2,nedef,d_4,\dots,d_{l-1},d_2,d_{l+1},\dots,d_m)$
\item $regex[d_1]=$')' a prislúcha lookaheadu, ktorému patrí adresa $d_l$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+1,d_l,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\item na pozícii $d_1$ je podslovo '$\lookbehind$' 
\\ $\wedge$ nech $d_l$ adresa prislúchajúca k tomuto lookbehindu: $e_l=d_2$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+3,d_2-l,nedef,d_4,\dots,d_{l-1},d_2,d_{l+1},\dots,d_m)$, kde $l\in\N$
\item $regex[d_1]=$')' a prislúcha lookbehindu, ktorému patrí adresa $d_l$ \\ $\wedge ~ d_2=d_l \\ \wedge ~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\end{enumerate}
Keďže regex neobsahuje negatívny lookbaround, ďalšie riadky z definície netestujeme.
\item[riadok 4] Po predošlých riadkoch platí $C_1\neq C_2 \wedge C_1 \nvdash C_2$. Ak zároveň $i<=1$, potom sa z $C_1$ do $C_2$ na $i$ krokov dostať nedokážeme. $TESTUJ$ vráti \textbf{false}.
\item[riadok 5] M začne iterovať cez všetky možné konfigurácie -- t.j. všetky možné kombinácie adries z množiny $\lbrace 1,\dots,d\rbrace$, kde $d=\lceil\log(r+1)\rceil$ pre $d_1$ a $d=\lceil\log(w+1)\rceil$ pre ostatné adresy. Vygenerované $C_3$ bude mať M uložené ako lokálnu premennú.
\item[riadok 6] M testuje, či je $C_3$ vo výpočte v strede medzi $C_1$ a $C_2$. Ak obe volané procedúry vrátia \textbf{true}, vrátime \textbf{true}. Inak sa M vráti na \textbf{riadok 5} a vygeneruje ďalšie $C_3$.
\item[riadok 7] Neexistuje vhodná konfigurácia $C_3$, teda sa nevieme dostať z $C_1$ do $C_2$ na $i$ krokov. Vrátime \textbf{false}.
\end{description}

Podľa vyššie špecifikovaných $m$-tíc pre konfigurácie bude úvodné nastavenie nasledovné: $$C_0=(~~~~~1,~~~~~~1,nedef,nedef,\dots,nedef,nedef,\dots,nedef)$$
$$C_a=(r+1,w+1,nedef,\underbrace{nedef,\dots,nedef}_{\substack{\text{adresy pre}\\\text{spätné}\\\text{ referencie}}},\underbrace{nedef,\dots,nedef}_{\substack{\text{adresy pre}\\\text{lookahead a lookbehind}}})$$

Turingov stroj M rekurzívne volá procedúru $TESTUJ$. Preto na prvej páske bude mať zásobník, kde budú uložené záznamy o jednotlivých volaniach. Druhá páska je pomocná pri vykonávaní konkrétneho volania -- M potrebuje konštantný počet adries, aby mohol realizovať porovnávanie (overovanie rovnosti konfigurácií a adries, overovanie konkrétneho rozdielu medzi adresami), zisťovanie príslušnosti zátvoriek (t.j. ktorá je druhá zátvorka k tejto -- treba počítať zátvorky (,)), zisťovanie poradia zátvorky/lookaheadu/lookbehindu a prislúchajúcej adresy, kontrolu alternovateľnosti (to je v podstate počítanie zátvoriek), čítanie čísla $k$ za metaznakom $\backslash$ a hľadanie adries pre $k$-te zátvorky, \dots

Zrejme ak existuje akceptačný výpočet, M ho nájde. Treba ukázať, že sa pri tom na každej páske zmestí do pamäte $O(n\log^2 n)$. Podľa predchádzajúceho odstavca vieme, že na druhej (pomocnej) páske potrebuje $O(\log n)$ políčok, čo spĺňa podmienku. Spočítajme veľkosť potrebnú zásobníka.

Adresy vieme zapísať v logaritmickom priestore závislom od dĺžky slova, kam ukazujú. Pre regex to bude $\log r$ a pre slovo $\log w$, pretože vieme adresovať od oddeľovača \#. Číslo $i$ je najviac $3rw^2$ a tiež ho vieme zapísať v logaritmickom tvare, čo zaberie $\log (3rw^2) = \log 3 + \log r + 2\log w$ políčok. Platí $r\leq n, w\leq n$, lebo $r+w+1=n$.

Počet zátvoriek, lookaheadov a lookbehindov je v regexe dokopy najviac $r$, teda jedna konfigurácia bude potrebovať najviac $\log r + 2\log w + 2r\log w$ priestoru.

Jeden záznam procedúry $TESTUJ$ obsahuje 3 konfigurácie a číslo $i$, čo spolu zaberá $\log 3+\log r + 2\log w + 3\log r + 6\log w + 6r\log w = O(r\log w) = O(n\log n)$ priestoru.

Počet záznamov na zásobníku závisí od hĺbky rekurzie. Keďže začíname na hodnote $i=3rw^2$ a pri každom volaní je $i$ zmenšené na polovicu, hĺbka vnorenia bude $\log(3rw^2)=O(\log n^3) = O(3\log n) = O(\log n)$.

Celkovo M na zásobníkovej páske zapíše $O(\log n)\cdot O(n\log n) = O(n\log^2 n)$ priestoru.
\end{proof}


\section[Popisná zložitosť]{Popisná zložitosť moderných regulárnych výrazov}
\label{vzlozitost}

V tejto kapitole rozoberieme moderné regulárne výrazy z dvoch hľadísk. Najprv nás bude zaujímať, ako pomohli nové konštrukcie pri popise regulárnych jazykov a potom prejdeme na analýzu dĺžky výrazov pre zložitejšie jazyky.

Lookaround môže výrazne pomôcť pri definovaní konečných jazykov, napríklad regex 
$$(\lookahead 
\underbrace{
	\underbrace{
		\lookahead (a^m)*\$ )
	}_{ \text{\normalsize \parbox{2cm}{generuje $a^{km}$, $k\in\N$} } }
	\underbrace{
		(a^{m+1})* a\lbrace 1,m-1\rbrace \$ ~|~ a^m \$ 
	}_{ \text{\normalsize \parbox{4.5cm}{generuje celé a$*$, okrem: $a^{m+1}$, $a^{m(m+1)l}$, $l\in\N$} } }
}_{\mathclap{ \text{\normalsize generuje $a^{km}$ také, že nevie $a^{m(m+1)l}$, $l\in\N$ } } }
) a^m)+$$
generuje konečný jazyk obsahujúci slová $a^m,\allowbreak a^{2m},\dots,\allowbreak a^{(m-1)(m+1)}$. Hlavný lookahead je spúšťaný každú iteráciu, teda pre slovo $a^{zm}$ musí matchovať všetky $a^{im}$ pre $i\in\lbrace 1,\dots,z\rbrace$.
