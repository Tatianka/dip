\chapter{Naše výsledky}
\label{chap:vysledky}

\section[Vlastnosti a sila]{Vlastnosti a sila moderných regulárnych výrazov}
\label{vsila}

V bakaláskej práci sme zabudli ... \textbf{\textit{negatívny lookaround}} \todo

\begin{lema}\label{nla+R}
Trieda $\R$ je uzavretá na negatívny lookahead.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$. Ukážeme, že $L=L_1\nlookahead L_2)L_3 \in \R$.

Keďže $ L_{1},L_{2},L_{3} $ sú regulárne, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=L_{i}, i \in \lbrace 1,2,3\rbrace $. Zostrojíme NKA $A$ pre $L$.

Konštrukcia bude veľmi podobná ako pre pozitívny lookahead, keď si správne predpripravíme $A_2$. Negatívny lookahead sa snaží za každú cenu nájsť slovo z $L_2$ (t.j. uspieť s $A_2$) a ak sa mu to nepodarí, akceptuje. Preto musíme zaručiť, že sa $A_2$ buď zasekne alebo prejde až do konca slova\footnote{Ak sa zasekne, slovo z $L_2$ tam určite nebude, lebo neexistuje akceptačný výpočet. Ak sa nezasekne, nevieme povedať o tom slove nič, pokiaľ ho neprejdeme celé.}. Ak $A_2$ dosiahne akceptačný stav, negatívny lookahead musí zamietnuť. 

Ďaľšie pozorovanie nám hovorí, že negatívny lookahead akceptuje vždy nejaké slovo z komplementu $L_2$. Ale komplement vzhľadom na akú abecedu? V skutočnosti nekonečnú -- ľubovoľný znak, ktorý nepatrí do $\Sigma_2$, znamená zaseknutie $A_2$, t.j. akceptáciu. Ak sa na to pozrieme z väčšej ďiaľky, uvidíme $L_3$, s ktorým robíme prenik. $A_3$ musí dočítať slovo do konca a na úplne neznámom znaku sa zasekne, takže z pohľadu výslednej akceptácie slova nevadí, ak by kvôli tomu znaku zamietol už negatívny lookahead. Preto stačí urobiť komplement vzhľadom na $\Sigma_2 \cup \Sigma_3$. 

Poďme upravovať $A_2$, začneme vytváraním komplementu. Ak $\Sigma_3 \setminus \Sigma_2 \neq\emptyset$\footnote{Inak $A_2'=A_2$.}, potom vytvoríme $A_2'= (K_2',\Sigma_2',\delta_2',q_{0},F_2')$ tak, že pridáme nové znaky $\Sigma_2'=\Sigma_2 \cup \Sigma_3$,  jeden nový stav\footnote{Pre každý nový stav predpokladáme, že je jedinečný -- t.j. žiaden taký v množine stavov ešte nie je.} $K_2'=K_2 \cup \lbrace q_{ZLE} \rbrace$ a prechody na nové znaky z každého stavu: 
\begin{eqnarray*}
 \forall q \in K_2 ~ \forall a \in \Sigma_2 &:&  \delta_2'(q,a)=\delta_2(q,a) \\
 \forall q \in K_2~ \forall a \in \Sigma_3 \setminus \Sigma_2 &:& \delta_2'(q,a)=q_{ZLE} \\
 \forall a \in \Sigma_2' &:&  \delta_2'(q_{ZLE},a)=q_{ZLE}
\end{eqnarray*}
 $F_2'=F_2.$ Do všetkých stavov sme pridali prechody na nové znaky a $q_{ZLE}$ má 1 prechod na každý znak, takže $A_2'$ je stále deterministický. Zároveň nové znaky vedú do stavu, z ktorého sa nedá dostať do žiadneho akceptačného, z čoho vyplýva $L(A_2')=L_2$.

Teraz $A_2'$ zmeníme na $A_2''$ tak, aby akceptoval práve vtedy, keď $\nlookahead L_2)$. Najprv si skonštruujeme množinu stavov, z ktorých sa vieme dostať do akceptačného stavu: $H= \lbrace  q \in K_2'~|~ \exists w \in {\Sigma_2'}^* ~ \exists q_A \in F_2': ~ (q,w)\vdash_{A_2'}(q_A,\varepsilon) \rbrace $, nasledovným spôsobom: $$ H_0 = F_2' $$ 
$$H_{i+1} = \lbrace q \in K_2'~|~ \exists p \in H_i~ \exists a \in \Sigma_2': ~ \delta(q,a)=p \rbrace$$
Zrejme $\exists i \in \N: ~ H_{i+1}=H_i = H$. Nás zaujíma množina $K_2' \setminus H$, v ktorej sa nachádzajú všetky stavy, z ktorých sa na žiadne slovo nie je možné dostať do žiadneho akceptačného stavu.

$A_2''= (K_2'',\Sigma_2'',\delta_2'',q_{0},F_2'')$: $K_2'' = K_2' \cup \lbrace q_A, q_Z \rbrace, ~\Sigma_2'' = \Sigma_2', ~F_2'' = (K_2'\setminus H) \cup \lbrace q_A \rbrace$
\begin{eqnarray*}
 \forall q \in K_2' \setminus F_2'  ~ \forall a \in \Sigma_2' &:&  \delta_2''(q,a)=\delta_2'(q,a) \\
 \forall q \in K_2' \setminus F_2'  ~ \forall a \in \Sigma_2' &:&  \delta_2''(q,\varepsilon)=q_A \\
 \forall q \in F_2' ~ \forall a \in \Sigma_2' &:& \delta_2''(q,a)=q \footnotemark \\
 \forall a \in \Sigma_2' &:& \delta_2''(q_A,a)=q_Z 
\end{eqnarray*}
\footnotetext{Tento riadok v podstate netreba, $A_2''$ sa môže rovno zaseknúť, lebo $A_2'$ práve akceptoval.}
Je dobré poznamenať, že $A_2''$ je takmer deterministický. Chýbajú mu prechody z $q_Z$ -- môžeme ho nechať cykliť v tomto stave, ale nevadí nám ani keď sa zasekne. Nedeterministické rozhodnutie vykonáva iba jedno -- pri prechode do stavu $q_A$. Vtedy háda, že už je na konci slova. Ak nie je, $\delta$-funkcia ho pošle do stavu $q_Z$. Podľa toho je zrejmé, že ak existuje akceptačný výpočet a dočítal slovo do konca, je práve jeden\footnote{Okrem prípadu, kedy dočíta slovo a je v stave z $(K_2'\setminus H)$ -- vieme ho predĺžiť o krok na $\varepsilon$ a skončiť v $q_A$. Jadro výpočtu ale zostáva rovnaké -- jednoznačné.} \footnote{Zaujímavé je, že aj zamietací výpočet je pre každé slovo jednoznačný}.

Tvrdíme $ L_1\lookahead L(A_2''))L_3 =L_1\nlookahead L_2)L_3= L $.
Keďže $A_1$ a $A_3$ sa pri oboch výpočtoch budú chovať rovnako (sú nezávislé od lookaheadov), nebudeme sa nimi pri dôkaze zaoberať.

$\subseteq :$ Máme akceptačný výpočet pre $A_2''$ na nejakom vstupe. Akceptačný stav mohol byť buď z množiny $K_2'\setminus H$, to znamená, že pôvodný automat $A_2'$ sa dostal do stavu, z ktorého už nemohol nijak akceptovať\footnote{Sem spadá aj prípad, keď $A_2$ prečítal neznámy znak a zasekol sa -- $A_2'$ zostáva až do konca slova v stave $q_{ZLE}$.}. V takom prípade $\nlookahead L_2)$ akceptuje. V druhom prípade mohol $A_2''$ akceptovať pomocou $q_A$, čo znamená, že dočítal slovo do konca (pretože z $q_A$ sa na ľubovoľný znak dostaneme do $q_Z$, v ktorom sa $A_2''$ zasekne a nebude akceptovať) a ani raz sa nedostal do akceptačného stavu automatu $A_2'$. Teda aj $\nlookahead L_2)$ akceptuje.

$\supseteq :$ Nech $\nlookahead L_2)$ akceptoval, t.j. na $A_2$ bol vykonaný nejaký neakceptujúci výpočet ($A_2$ je deterministický, takže existuje práve jeden pre každé slovo). Rovnakú postupnosť stavov bude mať aj výpočet na $A_2''$ (automat obsahuje všetky stavy aj $\delta$-funkciu z $A_2$, počiatočný stav je ten istý). Ak sa $A_2$ zasekol na neznámom znaku, v $A_2'$ na ten znak pridáme prechod do stavu $q_{ZLE}$ a v ňom zostaneme až do konca slova. Keďže $q_{ZLE}$ nie je v $A_2'$ akceptačný a nedá sa z neho na žiadne slovo dostať do ľubovoľného akceptačného stavu, $q_{ZLE} \in K_2' \setminus H$ a teda $q_{ZLE} \in F_2''$. Ak sa $A_2$ nezasekol, tak dočítal slovo do konca a v postupnosti stavov jeho výpočtu sa nenachádza žiaden z množiny $F_2$. V tom prípade $A_2''$ z posledného stavu prejde na $\varepsilon$ do $q_A$ (2.riadok definície $\delta_2''$) a akceptuje.

Z práve dokázaného tvrdenia a vety \ref{lookahead+R} už vyplýva aj platnosť našej lemy.
\end{proof}

\begin{lema}
Trieda $\R$ je uzavretá na negatívny lookbehind.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=L_{i}, i \in \lbrace 1,2,3\rbrace $.. Ukážeme, že $L=L_1\nlookbehind L_2)L_3 \in \R$.

Nemôžme skonštruovať $A_2''$ také, že bude akceptovať práve vte\-dy, keď $\nlookbehind L_2)$, pretože nevieme čítať doľava. Tzn. zaručiť, že miesto, kde začína $A_2''$ výpočet je skutočný začiatok slova. Mechanizmus lookbehindu musí byť riadený zvonku, automatom pre $L$. Skonštruujeme ho. $C=(K,\Sigma, \delta,q_0,F):$ 
$$K=K_3\cup \lbrace (q,A) ~|~ q \in K_1 \wedge A \subseteq K_2 \rbrace,~\Sigma = \Sigma_1\cup\Sigma_2\cup\Sigma_3,~q_0=(q_{01},\lbrace q_{02}\rbrace),F=F_3~ \delta:$$
\begin{eqnarray*}
\forall q \in K_3~ \forall a \in \Sigma_3 &:& \delta(q,a) \ni \delta_3(q,a) \\
\forall q \in K_1 ~\forall A \subseteq K_2~ \forall a \in \Sigma_1 \cap \Sigma_2 &:& \delta((q,A),a) \ni (p,B\cup \lbrace q_{02}\rbrace), ~\text{kde}~ \delta_1(q,a)=p,\\ &~& B=\lbrace r ~|~ \exists s \in A:~ \delta_2(s,a)=r \rbrace \\
\forall q \in K_1 ~\forall A \subseteq K_2 ~ \forall a \in \Sigma_1 \setminus \Sigma_2 &:& \delta((q,A),a) \ni (p,\lbrace q_{02}\rbrace), \text{ kde } \delta_1(q,a)=p \\
\forall q \in F_1~\forall A: ~A \subseteq K_2 \wedge A \cap F_2 = \emptyset &:& \delta((q,A),\varepsilon) \ni q_{03}
\end{eqnarray*}
Druhý riadok $\delta$-funkcie hovorí, že $A_1$ a všetky rozbehnuté výpočty $A_2$ prejdú do ďalšieho stavu a zároveň sa rozbehne nový výpočet $A_2$. Ak by sme hľadali jeden akceptačný výpočet $A_2$ stačilo by tipnúť si začiatok a odtiaľ ho simulovať. Lenže simulujeme negatívny lookbehind, teda ak neexistuje akceptačný výpočet, tak my akceptujeme (prejdeme na simulovanie $A_3$, 4. riadok). A to vieme povedať len v prípade, že sme videli všetky možné výpočty. Keďže $A_2$ je deterministický, pre každé slovo existuje práve jeden výpočet a zároveň sa nikdy nezasekne (na svojej abecede), teda nám stačí skontrolovať množinu stavov vtedy, keď sa $C$ rozhodne, že $A_1$ končí výpočet. Ak tam je, nedostane sa k simulovaniu $A_3$ a tým ani k akceptačným stavom.

$L(C)=L.$

$\subseteq:$
Majme akceptačný výpočet $C$ na $w$. Z definície $F$ vyplýva, že $A_3$ akceptoval, teda $\exists u,v$ také, že $w=uv$ a $v \in L_3$. Do $q_{03}$ sa dá dostať len z dvojice $q,A$ takej, že $q\in F_1$, teda $u\in L_1$, a $a \cap F_2 = \emptyset$, teda $\nexists xy$ také, že $u=xy$ a $y \in L_2$. To vyplýva z toho, že v každom znaku $u$ začal jeden výpočet na $A_2$ a žiaden z nich neakceptoval. Teda negatívny lookbehind akceptoval a $w\in L$.

$\supseteq:$
Nech $w\in L$, teda $\exists u,v$ také, že $w=uv,~ u \in L_1, v\in L_3$ a $\forall x,y:~u=xy$ platí $y \notin L_2$. Pre $u,v$ teda existujú akceptačné výpočty na $A_1,A_3$ a pre všetky $y$ neakceptačné na $A_2$. Z toho už vieme vyskladať akceptačný výpočet na $C$.
\end{proof}

\begin{veta}
Trieda $\R$ je uzavretá na negatívny lookaround.
\end{veta}

\begin{lema}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = \left( L_1 \left( ?= L_2\right) L_3 \right) * L_4$. Potom $L(\alpha) \in \R$.
\end{lema} 
\begin{proof}
Podobne ako v dôkaze vety \ref{nla+R} pretransformujeme $\nlookahead L_2)$ na akýsi $\lookahead L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $\nlookahead L_2)$. Potom $\beta = \left( L_1 \lookahead L(A_2'') ) L_3 \right) * L_4, ~ L(\beta) = L(\alpha) \in \R$ podľa vety \ref{lookaround+R}.
\end{proof}

\begin{lema}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = L_4 \left( L_1 \left(?<!~ L_2\right) L_3 \right) *$. Potom $L(\alpha)~\in~\R$.
\end{lema} 
\begin{proof}
\todo
\end{proof}

\begin{veta}\label{nlookaround+R}
Trieda nad regexami s negatívnym lookaroundom je $\R$.
\end{veta}

\begin{dosledok}
Trieda nad regexami s pozitívnym a negatívnym lookaroundom je $\R$.
\end{dosledok}

\begin{veta}
Trieda \le~je uzavretá na zreťazenie.
\end{veta}
\begin{proof}
Nech sú le-regexy $\alpha, \beta$. Chceme ukázať, že jazyk $L(\alpha)L(\beta) \in \le$. Intuitívne nás to vedie k riešeniu $\alpha\beta$, čo ale nemusí byť vždy správne. Problémom sú operácie lookaround, presnejšie každý lookahead v $\alpha$ môže zasahovať do slova z $L(\beta)$ a takisto každý lookbehind z $\beta$ môže zasahovať do slova z $L(\alpha)$. Navyše, ak lookahead obsahuje $\$$ a lookbehind $\textasciicircum$, potom zasahujú do slova z iného jazyka určite. V takom prípade môže le-regex $\alpha\beta$ vynechať niektoré slová z $L_1L_2$ a tiež pridať nejaké nevhodné slová naviac. Preto treba nájsť spôsob, ako operácie lookaroundu vhodne 'skrotiť', predpokladajme, že $\alpha$ má $k$ označených zátvoriek:
\begin{equation} \label{zretazenie}
\lookahead \mathop(_1 \alpha \mathop)_1 \mathop(_{k+2}\beta \mathop)_{k+2} \mathdollar) \alpha ' \backslash k+2 \lookbehind \textasciicircum\backslash 1\beta ')
\end{equation}
V $\alpha,\beta$ treba vhodne prepísať označenie zátvoriek (po poradí). $\alpha '$ je $\alpha$ prepísaný tak, že pre každý lookahead:
\begin{itemize}
\item bez \$ -- na koniec pridáme $.* \backslash k+2 \mathdollar $
\item s \$ -- pred \$ pridáme $\backslash k+2$
\end{itemize}
$\beta '$ je $\beta$ prepísaný tak, že pre každý lookbehind:
\begin{itemize}
\item bez $\textasciicircum$ -- na začiatok pridáme $\textasciicircum \backslash 1.*$
\item s $\textasciicircum$ -- pred $\textasciicircum$ pridáme $\textasciicircum \backslash 1$
\end{itemize}
Čo teda robí le-regex ~\ref{zretazenie}? Nech $w$ je vstupné slovo, ktoré chceme matchovať. Lookahead na začiatku ho nejak rozdelí na $w_1$ a $w_2$, pričom $w=w_1w_2$, tak, že do $L(\alpha)$ pridelí $w_1$ a do $L(\beta)$ podslovo $w_2$. Ešte musíme overiť, či $\alpha$ matchuje $w_1$ samostatne.

Preto sme v $\alpha$ prepísali všetky lookaheady. V $\alpha '$ každý z nich musí na konci slova $w$ matchovať $w_2$ (toto zabezpečí spätná referencia $\backslash k+2$ a \$) a teda matchovanie le-regexu $\alpha$ zostane výlučne na podslove $w_1$. Analogicky to platí pre lookbehindy v $\beta '$.
\end{proof}

\begin{veta}\label{lelcf}
$\le$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Majme jazyk $L=\lbrace ww~|~w \in \lbrace a,b \rbrace^* \rbrace \in \L_{CF}$, nech $ \alpha = ([ab]*)\backslash 1 $.
Zrejme $ L(\alpha) = L $, teda $L\in \le$.

Ukážeme, že jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace \notin \le$. Sporom, nech $L \in \le$. 

Vieme, že $L \notin \e$, preto musí obsahovať nejaký lookaround. Zároveň z $L \notin \R$ a \ref{lookaround+R} vyplýva, že musí obsahovať aj spätné referencie.

Kam sa môžu spätné referencie odkazovať a kam ich potom môžeme umiestniť?
\begin{list}{$\bullet$}{Nech výraz, na ktorý ukazujú, vyrobí nejaké:}
\item $a^i$, potom $\backslash k$ musí byť v prvej polovičke slova (medzi $a$, inak by pokazil štruktúru slova), takže nevplýva na časť s $b$ a teda sa zaobídeme bez nich.
\item $a^ib^j$, potom $\backslash k$ by mohol byť len medzi $b$, ale tam by pokazil štruktúru slova $a^nb^n$
\item $b^j$, potom $\backslash k$ môže byť len medzi $b$ a je tam zbytočný z rovnakých dôvodov, aké má prípad $a^i$
\end{list}
Vidíme, že so spätnými referenciami dosiahneme rovnaký výsledok ako bez nich, čo je spor s tým, že sa vo výraze musia nachádzať (bez nich vieme urobiť len regulárny jazyk).
\end{proof}

\begin{dosledok}
$\le \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$ nLEregex \subseteq \L_{CS} $
\end{veta}
\begin{proof}
Vieme, že $ \le \in \L_{CS} $ (veta \ref{le+lcs}), teda ľubovoľný le-regex vieme simulovať pomocou LBA. Ukážeme, že ak pridáme operáciu negatívny lookahead/lookbehind, vieme to simulovať tiež.

Nech $\alpha$ je nle-regex. Potom $A$ je LBA pre $\alpha$, ktorý ignoruje negatívny lookaround (t.j. vyrábame LBA pre le-regex). Teraz vytvoríme LBA $B$ pre le-regex vnútri negatívneho lookaroundu. Z nich vytvoríme LBA $C$ pre úplný nle-regex $\alpha$ tak, že bude simulovať $A$ a keď príde na rad negatívny lookaround zaznačí si, v akom stave je $A$ a na ktorom políčku skončil. Skopíruje slovo na ďalšiu stopu a na nej simuluje od/do toho miesta $B$ (podľa toho, či je to lookahead alebo lookbehind). 

Teraz je to s akceptáciou náročnejšie ako pri pozitívnom lookarounde. Pokiaľ $B$ akceptoval, $C$ sa zasekne. Ak sa $B$ zasekol, $C$ sa vráti naspäť k zastavenému výpočtu $A$ a pokračuje v ňom. Keďže slovo je konečné a $B$ na ňom testuje le-regex, ktorý postupne vyjedá písmenká, určite raz príde na koniec slova. Môže sa stať, že bude skúšať viaceré možnosti -- napr. skúsi pre $*$ zobrať menej znakov, teda príde na koniec slova viackrát. Ako určíme, že skončil výpočet? Bez újmy na všeobecnosti môžeme predpokladať, že sa $B$ nezacyklí, ale zamietne slovo na konci výpočtu. To preto, že všetkých možností na rozdelenie znakov medzi operácie $*,+,?,\lbrace n,m\rbrace$ je konečne veľa a keď ich systematicky skúša\footnote{Algoritmus pre $*$ je v praxi greedy. Ak slovo nesedí, tak sa vráti, odoberie posledný znak zožratý $*$ a opäť skúša zvyšok výrazu, či slovo sedí. Ak stále nie, algoritmus odoberá hviezdičke znaky dovtedy, dokým nenájde zhodu alebo odoberie všetky znaky -- vtedy sa mu minuli všetky možnosti a môže slovo neakceptovať.}, raz sa mu musia minúť. To znamená, že ak nemá v $\delta$-funkcii umelo vsunuté zacyklenie, nezacyklí sa. Teda ak slovo neakceptuje, tak ho určite zamietne a vtedy $C$ môže prejsť na zastavený výpočet $A$ a pokračovať v ňom.

Podobne ako pri lookarounde aj jeho negatívna verzia môže obsahovať nle-regex, t.j. vnorený (negatívny) lookaround. Tých však môže byť iba konečne veľa, keďže každý nle-regex musí mať konečný zápis. Čo znamená, že aj stôp bude konečne veľa a naznačeným postupom si vieme postupne vybudovať LBA, ktorý bude simulovať $\alpha$.
\end{proof}

\begin{veta}
$\nle$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Opäť použíjeme jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace$ a budeme dokazovať sporom. Nech $L \in \le$.

Z vety \ref{lelcs} vieme, že výraz musí obsahovať negatívny lookaround. Z jej dôkazu vidíme, že spätné referencie nepomôžu nech sa ich pokúsime hocijako použiť. Z toho vyplýva, že ich nepoužijeme a z vety \ref{nlookaround+R} zistíme, že nám zostal model schopný vyrobiť iba regulárne jazyky. Spor.
\end{proof}

\begin{dosledok}
$\nle \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$\le \subseteq NSPACE(\log n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
Ukážeme, že ľubovoľný $\alpha \in \le$ vieme simulovať nedeterministickým Turingovým strojom s jednou vstupnou read-only páskou a jednou pracovnou páskou, na ktorej použijeme maximálne logaritmický počet políčok.

Celý regex si budeme uchovávať v stavoch\footnote{Každý regex je má z definície konečnú dĺžku, to znamená aj konečný počet stavov.} a pridáme doňho špeciálny znak $ \blacktriangleright $, ktorým si budeme ukazovať, kam sme sa v regexe dopracovali -- bude to akýsi smerník na znak, ktorý práve spracovávame. Teda stav bude vyzerať takto: $q_{\beta\blacktriangleright\xi}$ (pre lepšiu čitateľnosť budeme uvádzať namiesto stavu iba jeho dolný index: $\beta\blacktriangleright\xi$), kde $\beta\xi = \alpha$, časť $\beta$ sme už namatchovali na vstup a práve sa chystáme pokračovať časťou $\xi$. Ak $\blacktriangleright$ ukazuje na znak, porovnáme ho s aktuálnym znakom na vstupnej páske. Pokiaľ sa nezhodujú, výpočet sa zasekne. Pri zhode pokračujeme až kým sa nám neminie vstup aj regex. Ak $\blacktriangleright$ ukazuje na metaznak, potom zistíme o akú operáciu ide (ak má viac znakov, treba na to niekoľko stavov -- napr. lookahead) a začneme ju vykonávať.

Pracovná páska bude slúžiť ako úložisko smerníkov na rôzne miesta vstupnej pásky. Bude mať formát $A_1\#A_2\#\dots\#A_m$. Adresu nejakého políčka na vstupnej páske vieme zapísať v priestore $\log n$. Ak ukážeme, že $m$ je konštanta, potom $m.\log n \in O(\log n)$. Adresa $A_1$ bude rezervovaná pre prvý adresný slot na aktuálnu pozíciu hlavy na vstupe, nech si ju máme odkiaľ okopírovať, keď treba. Adresy budeme využívať pri operáciách spätná referencia, lookahead a lookbehind.

Keďže celý regex vidíme pri konštrukcii Turingovho stroja, vieme si do stavov zakódovať význam a poradie adresných slotov. A celú pracovnú pásku si predpripraviť (napísať potrebný počet \#). 

Teraz skonštruujeme Turingov stroj $M = \left( K, \Sigma, \delta, q_0, F \right)$ k regexu $\alpha$. 
$$ K = \lbrace \beta\blacktriangleright\xi ~|~ \beta,\xi \textit{ sú podslová } \alpha \textit{ také, že } \beta\xi = \alpha \rbrace $$
$$ \Sigma = \Sigma(\alpha)\footnote{T.j. všetky znaky a metaznaky použité v regexe $\alpha$.}, ~
q_0 = \blacktriangleright\alpha, ~
F = \lbrace \alpha\blacktriangleright \rbrace $$
\underline{$\delta:$ (v tvare: stav, znak čítaný na vstupnej páske)} 

Kvôli prehľadnosti popíšeme len hlavné kroky algoritmu. 
\begin{list}{}{}
\item $\delta(\beta\blacktriangleright a \xi, a) = \lbrace (\beta a \blacktriangleright \xi, 1) \rbrace ~ \forall a \in \Sigma$ -- Ak je v regexe znak, matchujeme ho s tým na vstupe.
\item $\delta(\beta\blacktriangleright(\gamma)\xi, a) = \lbrace (\beta(\blacktriangleright\gamma)\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku pre $\backslash k$.
\item $\delta(\beta(\gamma\blacktriangleright)\xi, a) = \lbrace (\beta(\gamma)\blacktriangleright\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu konca pre $\backslash k$. Používame polootvorený interval -- znak na koncovej adrese do podslova nepatrí.
\item $\delta(\beta(\gamma)\blacktriangleright * \xi, a) = \lbrace (\beta(\blacktriangleright\gamma)*\xi, 0),(\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Kleeneho $*$: buď opakujeme alebo pokračujeme ďalej.
\item $\delta(\beta\blacktriangleright\backslash k \xi, a) = \lbrace (q_{najdi\_zaciatok(k)}, 0) \rbrace$ -- Najprv si zapamätáme aktuálnu pozíciu na vstupe (ďalej označovanú ako 'aktuálna pracovná pozícia'). Stav $q_{najdi\_zaciatok(k)}$ zodpovedá presunu hlavy na vstupnej páske na začiatočnú pozíciu podslova. Tu začneme algoritmus porovnávania podslov podľa definície spätnej referencie -- aké podslovo matchujú $k$-te zátvorky, také isté musí ležať aj na 'aktuálnej pracovnej pozícii'. Algoritmus bude porovnávať vždy postupne po jednom znaku od začiatočnej pozície (ľavá zátvorka) po (koniec - 1) (pravá zátvorka):

\begin{verbatim}
pokiaľ zaciatok != koniec: 
    zapamätaj si znak 
    začiatok++ 
    presuň hlavu na pozíciu 'aktuálna pracovná pozícia' 
    porovnaj znak (ak nesedí, zasekni sa) 
    (aktuálna pracovná pozícia)++ 
    presuň hlavu na pozíciu 'začiatok' 
presuň hlavu na pozíciu 'aktuálna pracovná pozícia'
\end{verbatim}
Vidíme, že si dočasne potrebujeme zapamätať adresu 'aktuálna pracovná pozícia', ale po skončení tohto algoritmu ju môžeme zahodiť.

Po úspešnom zbehutí algoritmu TS prejde do stavu $\beta\backslash k \blacktriangleright\xi$.
\item $\delta(\beta\blacktriangleright\lookahead\gamma)\xi, a) = \lbrace (\blacktriangleright\gamma, 0) \rbrace$ -- Lookahead: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske a spracujeme regex vnútri lookaheadu. Ak uspejeme, presunieme hlavu na vstupnej páske naspäť na zapamätanú pozíciu a pokračujeme v regexe ďalej: $\delta(\gamma\blacktriangleright, a) = \lbrace (\beta\lookahead\gamma)\blacktriangleright\xi, 0) \rbrace $.
\item $\delta(\beta\blacktriangleright\lookbehind\gamma)\xi, a) = \lbrace (doľava\_ \gamma, 0) \rbrace$
-- Lookbehind: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske. Toto je zarážka pre lookbehind -- svoje matchovanie musí skončiť na tejto pozícii tak, že tento znak už neberie do úvahy. Nedeterministicky sa vrátime o niekoľko políčok doľava ($\delta(doľava\_ \gamma, a) = \lbrace(doľava\_ \gamma,-1), (\blacktriangleright\gamma, 0)\rbrace$)  a skúsime matchovať regex v lookbehinde. Keď uspejeme, porovnáme aktuálnu pozíciu so zarážkou. Ak sú rôzne, Turingov stroj sa zasekne. Inak pokračuje vo výpočte ďalej, od tejto pozície: $\delta(\gamma\blacktriangleright\_overene, a) = \lbrace (\beta\lookbehind \gamma)\blacktriangleright\xi, 0) \rbrace $.
\end{list}

\textbf{\underline{Počet adries}}:

Pre \textbf{spätné referencie} potrebujeme vždy 2 adresy -- na začiatok a koniec. Ak sa náhodou budú $k$-te zátvorky opakovať, napr. kvôli Kleeneho $*$, v definícii stojí, že sa vždy berie do úvahy posledný výskyt, takže adresy prepisujeme pri každom opakovaní. V prípade, že sa $k$-te zátvorky nachádzajú vnútri lookaheadu/lookbehindu, tiež máme pre ne rezervované 2 sloty. Algoritmus porovnávania potrebuje 1 ďalšiu adresu -- aktuálnu pracovnú pozíciu. Po jeho dokončení adresu môžeme vymazať (tzn. v ďalšom výpočte prepísať niečím iným).

V prípade \textbf{lookaheadu a lookbehindu} spotrebujeme len 1 adresný slot a to tiež len dočasne -- dokým sa operácia celá nevykoná. Potom je nám tento údaj zbytočný. Tieto operácie však môžu byť vnorené a tak v najhoršom prípade zaberú $p.\log n$ priestoru, ak ich počet je $p$.

Ak máme 1 rezervovaný slot pre aktuálnu adresu, $s$ spätných referencií, $l_a$ lookaheadov a $l_b$ lookbehindov, najviac spotrebujeme $(1+2s+1+l_a+l_b)\log n$ priestoru. Celý regex $\alpha$ je konečne dlhý, teda počet operácií je konečný. Čo znamená, že $m=1+2s+1+l_a+l_b$ je konštanta a to sme chceli dokázať.

\end{proof}


\begin{veta}[Savitch]
Nech $S(n)\geq \log n$ je páskovo konštruovateľná, potom 
$$ NSPACE(S(n)) \subseteq DSPACE(S^2(n)) $$
\end{veta}

\begin{dosledok}
$\le \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{dosledok}

\begin{veta}
$\nle \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
\TODO
\end{proof}

\begin{df}
$L(regex\#word)$ nazývame jazyk takých slov, kde $regex$ je validný regulárny výraz z $R$ a slovo $word \in L(R)$. Množina $R \in \lbrace \e, \le, \nle \rbrace$ musí byť špecifikovaná.
\end{df}

\begin{df}
\textbf{Konfiguráciou} regexu $\alpha = r_1 \dots r_n$ nazývame dvojicu $(r, w)$, kde $r \in (\lceil\alpha)\cup(\alpha\lceil)\cup(r_1 \dots \lceil r_i \dots r_n)$ $w \in \Gamma^*\lceil~ \Gamma^*$ a sybmol $\lceil$ ukazuje, kde sa nachádzame vo výpočte v regexe a v slove.
\end{df}

\begin{df}
Konfiguráciu $(r_1 \dots r_n \lceil, w_1\dots w_m \lceil)$ nazývame \textbf{akceptačná}.
\end{df}

\begin{df}
Zátvorka $($ v regexe $\alpha$ je \textbf{indexovateľná}, ak sa bezprostredne za ňou nenachádza metaznak ? a zároveň sa nenachádza vnútri negatívneho lookaroundu.
\end{df}
Je zakázané odkazovať sa spätnými referenciami na operácie formy $(?\dots )$, preto ich ani nechceme a nebudeme brať do úvahy v poradí zátvoriek. Z týchto operácií sa v našom modeli nachádza iba pozitívny a negatívny lookaround. Je povolené odkazovať sa na zátvorky vnútri lookaroundu, takže sa vieme odvolať na podslovo, čo sa zhoduje s pozitívnou formou (ak lookaround považujeme za neindexovateľné zátvorky, stačí ho prepísať do formy $\lookahead (\dots ))$ a vieme sa referencovať na jeho obsah). Problém nastáva pri jeho negatívnej verzii -- podľa definície nesmie nájsť žiadnu zhodu, inak sa výpočet zastaví. Potom po akceptácii nedefinuje žiadne podslovo, na ktoré by sme sa mohli odvolať. To isté platí o ľubovoľných zátvorkách v jeho vnútri.
\TODO ale na samotné matchovanie vnútri potrebuje aj spätné referencie

\begin{df}
Zátvorka $)$ v regexe $\alpha$ je \textbf{indexovateľná}, ak k nej prislúchajúca otváracia zátvorka je indexovateľná.
\end{df}

\begin{df}
Regex $\alpha$ je \textbf{alternovateľný}, ak zodpovedá jednému z týchto tvarov:
\begin{itemize}
\item prázdny regex
\item $a\in\Sigma$ 
\item $a*$, kde $a\in\Sigma$
\item $(\beta)$, kde $\beta$ je ľubovoľný regex z rovnakej triedy ako $\alpha$
\item $(\beta)*$, kde $\beta$ je ľubovoľný regex z rovnakej triedy ako $\alpha$
\item $\backslash k$
\item $\backslash k *$
\end{itemize}
\end{df}

\begin{lema}
Alternácia používa iba alternovateľné regexy.
\end{lema}
\begin{proof}
Dokážeme sporom. Majme regex $\alpha = \beta | \gamma$, kde $\beta,\gamma$ sú všetky členy alternácie a nech $\beta$ nie je alternovateľná. Môžu nastať 3 prípady:
\begin{enumerate}
\setlength{\itemsep}{0cm}%
\setlength{\parskip}{0cm}%
\item $\beta$ má na konci $|$. Potom $\beta = \beta'|$ a členy alternácie v $\alpha$ sú $\beta', \gamma$ a prázdny regex. To je spor s predpokladom.
\item $\beta$ končí lookaroundom, ale lookaround sa nedá alternovať.
\item $\beta = \beta_1\beta_2$. Alternácia berie posledný ucelený regex, takže $\beta$ nemôže byť členom alternácie.
\end{enumerate}
\end{proof}

\TODO: krok výpočtu/krok zhody/posun/...
\begin{df}
\textbf{Krok výpočtu} je relácia $\vdash$ na konfiguráciách definovaná nasledovne:

\begin{enumerate}[I.]\label{dfkonfig}
\item $\forall a \in \Sigma: ~(r_1 \dots \lceil a \dots r_n, w_1 \dots \lceil a \dots w_m) \vdash (r_1 \dots a\lceil \dots r_n, w_1 \dots a \lceil \dots w_m)$
\item Nech ( je indexovateľná, $k$-ta v poradí: $\displaystyle{ (r_1 \dots \lceil ( \dots r_n, w_1 \dots \lceil w_j \dots w_m)}$ $$(1) \vdash (r_1 \dots (\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^k \dots w_m)$$
Ak za jej uzatváracou zátvorkou nasleduje $*$, t.j. $\alpha$ je tvaru $r_1 \dots \lceil ( \dots ) * \dots r_n$, potom $$ (2) \vdash (r_1 \dots (\dots )* \lceil \dots r_n, w_1 \dots \lceil \mathop{\mathop{w_j}^k}^{k'} \dots w_m ) $$
\item Nech ) je indexovateľná, $k$-ta v poradí: $$ (r_1 \dots \lceil ) \dots r_n, w_1 \dots \lceil w_j \dots w_m) \vdash (r_1 \dots )\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^{k'} \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie: $(r_1 \dots \lceil \alpha_1 | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$(1) \vdash \textit{ďalší prechod v }\alpha_1$$
$$(2) \vdash (r_1 \dots \alpha_1 | \lceil \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
$$\dots$$
$$(a) \vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \lceil \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item $\displaystyle{(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k\lceil * \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)\footnotemark}$
\footnotetext{Podľa definície spätných referencií platí podsledné podslovo nájdené regexom v $k$-tych zátvorkách. Pri tejto pracovnej pozícii v regexe je zrejmé, že nejde o prvý prechod cez tieto zátvorky a teda existuje také $a,b$, že $k$ je v slove nad $w_a$ a $k'$ nad $w_b$. Ak nastane prechod (2), pôvodné horné indexy $k, k'$ miznú a pridáva sa $k$ nad $w_j$.}
$$(1) ~\vdash(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k *\lceil \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)$$
$$(2) ~\vdash(r_1 \dots \mathop{(}_k\lceil r_i \dots r_l\mathop{)}_k * \dots r_n, w_1 \dots w_a \dots w_b \dots \lceil \mathop{w_j}^k \dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots\mathop{w_b}^{k'}\dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\ldots\intercal\mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)$$	

\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal w_c \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$, kde $a\leq c\leq b$ a zároveň $w_c = w_j$\footnote{$w_c$ a $w_j$ môžu byť poschodové symboly, avšak pri tejto rovnosti poschodia ignorujeme -- chceme porovnať iba písmenká v slove, prislúchajúce týmto pozíciám.}
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots w_c\intercal \dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal  \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item Nech $\lookahead \dots)$ je $k$-ty pozitívny lookahead v poradí: 
\\$\displaystyle{(r_1\dots \lceil \lookahead \dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash(r_1\dots \lookahead\lceil\dots) \dots r_n, w_1\dots\lceil \mathop{w_j}^{\mathop{k}^\rightarrow}\dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookaheadu v poradí: 
\\$\displaystyle{(r_1\dots \lookahead\dots\lceil) \dots r_n, w_1\dots \mathop{w_l}^{\mathop{k}^\rightarrow}\dots\lceil w_j\dots w_m )} $
$$ \vdash(r_1\dots \lookahead\dots)\lceil \dots r_n, w_1\dots \lceil w_l \dots w_j\dots w_m ) $$
\item Nech $\lookbehind\dots)$ je $k$-ty pozitívny lookbehind v poradí, $\forall L\in\lbrace 0,\dots, j-1\rbrace$:
$\displaystyle{(r_1\dots \lceil \lookbehind\dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash (r_1\dots \lookbehind\lceil\dots) \dots r_n, w_1\dots\lceil w_{j-L}\dots \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookbehindu v poradí:
\\ $\displaystyle{(r_1\dots \lookbehind\dots\lceil) \dots r_n, w_1\dots \lceil \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m )}$
$$ \vdash(r_1\dots \lookbehind\dots)\lceil \dots r_n, w_1 \dots \lceil w_j \dots w_m ) $$
\item Ak $\nexists p \in \lbrace j,\dots,m\rbrace: (\lceil r_k\dots r_l,\lceil w_j\dots w_p) \vdash^* (r_k\dots r_l\lceil, w_j\dots w_p \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookahead r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookahead r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item Ak $\nexists p \in \lbrace 1,\dots,j-1\rbrace: (\lceil r_k\dots r_l,\lceil w_p\dots w_{j-1}) \vdash^* (r_k\dots r_l\lceil, w_p \dots w_{j-1} \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookbehind r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookbehind r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\end{enumerate}

\end{df}

\begin{df}
\textbf{Jazyk} generovaný regexom $\alpha$ je množina $$L(\alpha) = \lbrace w~|~platí ~ (\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil) \rbrace$$
\end{df}

\textbf{Poznámka.}
Postupnosť konfigurácií $(\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil)$ pre daný regex $\alpha$ a slovo $w$ nazývame \textbf{akceptačný výpočet}.

\begin{lema}\label{dlzka_vypoctu_rw}
Nech $\alpha \in \le$ a $w \in L(\alpha)$. Potom existuje akceptačný výpočet, ktorý má najviac $5\cdot|\alpha|\cdot|w|$ konfigurácií.
\end{lema}
\begin{proof}
Pri prechodoch medzi konfiguráciami I., II., III., IV., V.(1), VII., IX., XII., XIII. a XIV. sa ukazovateľ posúva vždy vpred buď v slove alebo v regexe alebo v oboch. Keby sme využívali iba tieto prechody, akceptačný výpočet má najviac $\left\vert{\alpha}\right\vert+|w|$ konfigurácií.

Existujú prechody, pri ktorých sa žiaden ukazovateľ nepohne: VI. a VIII. Tieto prechody nastávajú pri spätných referenciách a jedná sa o objavenie sa alebo zmiznutie pomocného ukazovateľa. Pri každej spätnej referencii nastávajú oba javy práve jedenkrát. Zároveň počet spätných referencií je najviac $|\alpha|$, teda tieto 2 konfigurácie sa objavia dokopy najviac $(2\left\vert{\alpha}\right\vert)$-krát.

Zostali konfigurácie, v ktorých ukazovateľ skáče dozadu, rozoberme si ich postupne:

V.(2) -- v prípade Kleeneho $*$ nastáva ďalšie opakovanie. Keďže $w\in L(\alpha)$, existuje akceptačný výpočet. Takýchto výpočtov môže byť viac, napríklad ak sa v $\alpha$ vyskytuje regex $(\beta)*$ taký, že $\varepsilon \in \beta$. Potom existuje nekonečne veľa výpočtov, ktoré sa líšia v počte prechodov týmto regexom. Preto si vyberieme najkratší akceptačný výpočet. To znamená, že v každom prechode cez regex opakovaný operáciou $*$ musíme nájsť zhodu aspoň s jedným písmenkom z $w$ (t.j. ukazovateľ v slove $w$ sa pohne aspoň o 1 pozíciu doprava). Regex opakovaný Kleeneho $*$ je dlhý najviac $|\alpha|$-1 znakov a opakujeme ho najviac $w$-krát. Z toho vidíme, že existuje akceptačný výpočet, ktorý má najviac $|\alpha|\cdot|w|$ konfigurácií.

X., XI. -- ukončenie operácie lookahead, začiatok operácie lookbehind. V tomto prípade ukazovateľ skáče dozadu v slove. Podstatné však je, že v regexe sa posúva dopredu. Takýchto prechodov vieme spraviť najviac $|\alpha|$.

Spolu je to najviac $|\alpha|+|w|+2|\alpha|+|\alpha|\cdot|w|+|\alpha| \leq 5\cdot|\alpha|\cdot|w|$ konfigurácií.

\end{proof}

Príkladom toho, že táto lema poskytuje tesný odhad, je jazyk $(a*b*c*d*e*)*$ a slovo $edcba$. V najkratšom akceptačnom výpočte v každom opakovaní $*$ naozaj nájdeme zhodu práve s jedným písmenkom.

V praxi často regex dopredu nepoznáme. Vstupným údajom je text na vyhľadávanie a rovnako aj regex, ktorý znázorňuje požiadavku na vyhľadávanie. Tento problém predstavuje jazyk $$L(regex\#word) = \lbrace word~|~word \in L(regex) \wedge regex \in \cal U \rbrace$$
kde ${\cal U} \in \lbrace \re ,\e ,\le ,\nle \rbrace$.

\begin{veta}
$L(regex\#word) \in NSPACE(r \log w)$, kde $r = |regex|,~w = |word|$ a $regex \in \le$.
\end{veta}
\begin{proof}
\TODO
Zostrojíme nedeterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na pracovných páskach zapíše najviac $O(r\log w)$ políčok.

Na pracovnej páske 
\end{proof}

\begin{veta}
$L(regex\#word) \in DSPACE(n \log^2 n)$, kde $regex \in \le$ a $n$ je dĺžka vstupu.
\end{veta}
\begin{proof}
Pre účely dôkazu budeme označovať $w = |word|$ a $r = |regex|$.

Zostrojíme deterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na každej pracovnej páske použije najviac $O(n\log^2 n)$ políčok. M bude mať vstupnú read-only pásku a 2 pracovné pásky.

Myšlienka je podobná dôkazu Savitchovej vety -- M bude vykonávať funkciu $TESTUJ(C_1,C_2,i)$, ktorá zistí, či sa vieme dostať z konfigurácie $C_1$ do konfigurácie $C_2$ na $i$ krokov. 

Podľa lemy \ref{dlzka_vypoctu_rw} vieme, že ak existuje akceptačný výpočet pre $w$, potom existuje aj akceptačný výpočet taký, ktorý má najviac $5rw$ konfigurácií. Na základe tohto výsledku bude M zisťovať, či sa z počiatočnej konfigurácie $C_0$ vieme dostať do akceptačnej konfigurácie $C_a$ na $5rw$ krokov -- $TESTUJ(C_0,C_a,5rw)$.

Pseudokód procedúry $TESTUJ$:
\lstset{numbers=left, tabsize=4, morekeywords={if,then,return,true,false}}
\begin{lstlisting}[mathescape]
bool $TESTUJ(C_1,C_2,i)$
	if ($C_1 == C_2$) then return true
	if ($i>0 ~\wedge~ C_1\vdash C_2$) then return true
	if ($i<=1$) return false
	iteruj cez vsetky konfiguracie $C_3$
		if ($TESTUJ(C_1, C_3,\lfloor \frac{i}{2}\rfloor) ~\wedge ~TESTUJ(C_3, C_2,\lceil \frac{i}{2}\rceil)$) then return true
	return false
\end{lstlisting}

Pre podrobnejší popis pseudokódu je nutné, aby sme najprv definovali tvar konfigurácie. Použijeme zápis z definície \ref{dfkonfig}, v tvare $(a_1\dots \lceil a_i \dots a_r, b_1 \dots\lceil b_j \dots b_w)$ respektíve $(a_1\dots \lceil a_i \dots a_r, b_1 \ldots \intercal b_l \dots \lceil b_j \dots b_w)$, kde $a_1\dots a_r = regex$ a $b_1\dots b_w = word$. Reprezentovať ich budeme vo forme 2 resp. 3 adries -- pracovná pozícia v regexe (i), pracovná pozícia v slove (j) a adresa k spätnej referencii (l). Namiesto poschodových symbolov si M bude pre každú konfiguráciu pamätať informáciu, ktoré zátvorky zodpovedajú ktorému podslovu slova $word$. Pre každé zátvorky si uloží 2 adresy -- začiatok podslova a 1 políčko za koncom podslova (použijeme polootvorený interval $\langle z,k)$). Pre každý lookahead a lookbehind bude mať vyhradené 1 adresné miesto aby si zapamätal, kam do slova ukazoval, keď naňho narazil.

Popis pseudokódu:
\begin{description}
\item[riadok 2] Ak $C_1=C_2$, potom vieme prejsť z $C_1$ do $C_2$ na ľubovoľný počet krokov.
\item[riadok 3] Platí $C_1 \neq C_2$. Ak $i=0$, nevieme prejsť do žiadnej inej konfigurácie ako $C_1$, teda vrátime \textbf{false}. Nech $i>0$. Skontrolujeme podľa definície \ref{dfkonfig}, či platí $C_1 \vdash C_2$. Konfigurácie sú uložené na páske ako $m$-tice, kde $m = 3+2\cdot (\textit{počet zátvoriek})+(počet lookaheadov)+(počet lookbehindov)$: $C_1 = (d_1,\dots, d_m), ~C_2=(e_1,\dots,e_m)$. Nech $d_1, e_1$ sú pracovné adresy v regexe, $d_2,e_2$ sú pracovné adresy v slove a $d_3,e_3$ pracovné adresy pri spätných referenciách, pričom $d_3,e_3$ môžu byť nedefinované (na prislúchajúcom mieste medzi oddeľovačmi adries nebude nič zapísané). TS M overí, či je splnená nejaká z týchto podmienok (rímske čísla zodpovedajú tým v definícii \ref{dfkonfig}):
\begin{enumerate}[I.]
\item $regex[d_1]=word[d_2]~\wedge~(e_1,\dots,e_m) = (d_1+1,d_2+1,nedef,d_4, \dots, d_m)$
\item (1) $regex[d_1]=$'('$ \\ ~\wedge~regex[d_1]$ je indexovateľná \\ $\wedge$ nech $d_k$ prislúcha k $regex[d_1]$, $4\leq k \leq m$: $d_2=d_k$ (sedí začiatok podslova) $ \wedge ~(e_1,\dots, e_m) = (d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{1}
\item (2) $regex[d_1]=$'('$ \\ \wedge$ 2 políčka pred pozíciou $e_2$ je v regexe '$)*$' $ \\ \wedge$ zátvorky $regex[d_1]$ a $regex[e_1-2]$ sú k sebe prislúchajúce\footnote{To M skontroluje tak, že si overí, že medzi nimi ku každej '(' existuje ')' -- teda počet výskytov '(' a ')' musí byť rovnaký.} \\ $\wedge ~(e_1,\dots,e_m)=(d_1+l, d_2,nedef,d_4,\dots,d_k,\dots,d_m)$ pre $l\in\N$
\item podobne ako II.(1) -- kontrola, či sedí koniec podslova
\item $regex[e_1-1] =$'|' \\ $\wedge$ regex medzi $d_1$ a najbližším metaznakom | je alternovateľný \\ $\wedge$ všetky regexy ohraničené | medzi $d_1$ a $e_1$ sú alternovateľné \\ $\wedge~ (e_1,\dots, e_m)=(d_1+l,d_2,nedef,d_4,\dots,d_m)$ pre $l\in\N$
\item (1) $regex[d_1]=$'$*$'$~\wedge~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{4}
\item (2) $regex[d_1]=$'$*$'$ \\ \wedge~regex[e_1-1]=($ a prislúcha k $regex[d_1]$ \\ $\wedge$ nech $e_k,e_{k+1}$ prislúchajú k týmto zátvorkám, potom $e_k=e_2$ a $e_k\leq e_{k+1} \\ \wedge ~(e_1,\dots,e_m)=(d_1-l,d_2,nedef,d_4,\dots,d_{k-1},e_k,e_{k+1},d_{k+2},\dots, d_m)$ pre $l\in\N$
\item na pozícii $d_1$ je podslovo '$\backslash k$' pre nejaké $k\in\N, ~0\leq k \leq$ (počet indexovateľných zátvoriek) \\ $\wedge ~ (e_1,\dots,e_m)= (d_1,d_2,d_{k+3},d_4,\dots,d_m)$ ($d_{k+3}$ je adresa začiatku podslova prislúchajúca ku $k$-tym zátvorkám)
\item podobne ako I.-- musí platiť $d_3<d_{k+3}$ a správne sa posunú adresy $d_2,d_3$
\item na pozícii $d_1$ je podslovo '$\backslash k$' \\ $\wedge ~ d_3=d_{k+3} \\ \wedge ~(e_1,\dots, e_m)=(d_1,d_2,nedef,d_4,\dots,d_m)$
\item na pozícii $d_1$ je podslovo '$\lookahead$' \\ $\wedge$ nech $d_l$ adresa prislúchajúca k tomuto lookaheadu: $e_l=d_2$, teda $(e_1,\dots,e_m)=(d_1+3,d_2,nedef,d_4,\dots,d_{l-1},d_2,d_{l+1},\dots,d_m)$
\item $regex[d_1]=$')' a prislúcha lookaheadu, ktorému patrí adresa $d_l$ \\ $\wedge ~(e_1,\dots,e_m)=(d_1+1,d_l,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\item podobne ako IX. -- zapíšeme si aktuálnu adresu v slove
\item $regex[d_1]=$')' a prislúcha lookbeindu, ktorému patrí adresa $d_l$ \\ $\wedge ~ d_2=d_l \\ \wedge ~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\end{enumerate}
Keďže regex neobsahuje negatívny lookbaround, ďalšie riadky z definície netestujeme.
\item[riadok 4] Po predošlých riadkoch platí $C_1\neq C_2 \wedge C_1 \nvdash C_2$. Ak zároveň $i<=1$, potom sa z $C_1$ do $C_2$ na $i$ krokov dostať nedokážeme. $TESTUJ$ vráti \textbf{false}.
\item[riadok 5] M začne iterovať cez všetky možné konfigurácie -- t.j. všetky možné kombinácie adries, ktoré ukazujú najďalej 1 políčko za regex/slovo. Vygenerované $C_3$ bude mať M uložené ako lokálnu premennú.
\item[riadok 6] M testuje, či je $C_3$ vo výpočte v strede medzi $C_1$ a $C_2$. Ak obe volané procedúry vrátia \textbf{true}, vrátime \textbf{true}. Inak sa M vráti na \textbf{riadok 5} a vygeneruje ďalšie $C_3$.
\item[riadok 7] Neexistuje vhodná konfigurácia $C_3$, teda sa nevieme dostať z $C_1$ do $C_2$ na $i$ krokov. Vrátime \textbf{false}.
\end{description}

Podľa vyššie špecifikovaných $m$-tíc pre konfigurácie bude úvodné nastavenie nasledovné: $$C_0=(~~~~~1,~~~~~~1,nedef,0,0,\dots,0,nedef,\dots,nedef)$$
$$C_a=(r+1,w+1,nedef,\underbrace{0,0,\dots,0}_{\substack{\text{adresy pre}\\\text{spätné}\\\text{ referencie}}},\underbrace{nedef,\dots,nedef}_{\substack{\text{adresy pre}\\\text{lookahead a lookbehind}}})$$

Turingov stroj M rekurzívne volá procedúru $TESTUJ$. Preto na prvej páske bude mať zásobník, kde budú uložené záznamy o jednotlivých volaniach. Druhá páska je pomocná pri vykonávaní konkrétneho volania -- M potrebuje konštantný počet adries, aby mohol realizovať porovnávanie, zisťovanie príslušnosti zátvoriek, zisťovanie, koľký v poradí je daný lookahead/lookbehind/otváracia zátvorka, \dots

Zrejme ak existuje akceptačný výpočet, M ho nájde. Treba ukázať, že sa pri tom na každej páske zmestí do pamäte $O(n\log^2 n)$. Podľa predchádzajúceho odstavca vieme, že na druhej (pomocnej) páske potrebuje $O(\log n)$ políčok, čo spĺňa podmienku. Spočítajme veľkosť potrebnú zásobníka.

Adresy vieme zapísať v logaritmickom priestore závislom od dĺžky slova, kam ukazujú. Pre regex to bude $\log r$ a pre slovo $\log w$, pretože vieme adresovať od oddeľovača \#. Číslo $i$ je najviac $5rw$ a tiež ho vieme zapísať v logaritmickom tvare, čo zaberie $\log (5rw) = \log 5 + \log r + \log w$ políčok. Platí $r\leq n, w\leq n$.

Počet zátvoriek, lookaheadov a lookbehindov je v regexe najviac $r$, teda jedna konfigurácia bude potrebovať najviac $\log r + 2\log w + 2r\log w$ priestoru.

Jeden záznam procedúry $TESTUJ$ obsahuje 3 konfigurácie a číslo $i$, čo spolu zaberá $\log 5+2\log r + 3\log w + 2r\log w = O(r\log w) = O(n\log n)$ priestoru.

Počet záznamov na zásobníku závisí od hĺbky rekurzie. Keďže začíname na hodnote $i=5rw$ a pri každom volaní je $i$ zmenšené na polovicu, hĺbka vnorenia bude $\log(5rw)=O(\log n^2) = O(2\log n) = O(\log n)$.

Celkovo M na zásobníkovej páske zapíše $O(\log n)\cdot O(n\log n) = O(n\log^2 n)$ priestoru.
\end{proof}


\section[Popisná zložitosť]{Popisná zložitosť moderných regulárnych výrazov}
\label{vzlozitost}

V tejto kapitole rozoberieme moderné regulárne výrazy z dvoch hľadísk. Najprv nás bude zaujímať, ako pomohli nové konštrukcie pri popise regulárnych jazykov a potom prejdeme na analýzu dĺžky výrazov pre zložitejšie jazyky.

Lookaround môže výrazne pomôcť pri definovaní konečných jazykov, napríklad le-regex z \cite[Poznámka 1.]{mojaBak}
$\beta = (\lookahead (a^m)*\mathdollar )a^{m+1})*a \lbrace 1,m-1 \rbrace \mathdollar$. Aké slová obsahuje?
\begin{itemize}
\item $a^{m+1+(m-1)}$
\item $a^{2m+2+(m-2)}$ \\
	  ~~~~~~~\vdots
\item $a^{(m-1)(m+1)+1}$
\end{itemize}
avšak $a^{m(m+1)} \notin L(\beta )$, lebo nám chýba zvyšok $0$. Zaujímavé je, že le-regex využíva iteráciu $(m-1)$-krát a napriek tomu je konečný.
