\chapter{Naše výsledky}
\label{chap:vysledky}

\todo Sem by bolo fajn niečo napísať.

\section{Sila negatívneho lookaroundu}

V bakalárskej práci bol skúmaný hlavne pozitívny lookaround. Teraz si pozrieme na vlastnosti negatívneho lookaroundu. Budú to vety s podobným znením ako v prípade pozitívnej verzie. 

Pripomenieme, že negatívny lookahead skúša všetky prefixy a pokiaľ žiadny z nich nepatrí do jeho jazyka, akceptuje a hľadanie zhody môže pokračovať v regexe ďalej. Čo je jednoduché pri pozitívnej verzii -- stačí si nedeterministicky tipnúť ten správny prefix patriaci do jazyka -- to je komplikované pri tej negatívnej. Aby sme mohli s~istotou povedať, že akceptuje, potrebujeme deterministický algoritmus, ktorý vyskúša všetky možnosti. Preto veľakrát budeme budovať negatívny lookaround tak, že vezmeme nejaký deterministický model akceptujúci jeho jazyk a upravíme akceptáciu.

\begin{lema}\label{nla+R}
Trieda $\R$ je uzavretá na negatívny lookahead.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$. Ukážeme, že $L=L_1\nlookahead L_2)L_3 \in \R$.

Jazyky $ L_{1},L_{2},L_{3} $ sú regulárne, teda existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=\nobreak L_{i},\allowbreak~ i \in \lbrace 1,2,3\rbrace $. Zostrojíme NKA $A$ pre $L$.

Konštrukcia bude veľmi podobná ako v obdobnej vete pre pozitívny lookahead v \cite{mojaBak}, keď si správne predpripravíme $A_2$. Negatívny lookahead sa snaží za každú cenu nájsť slovo z $L_2$ (t.j. uspieť s $A_2$) a ak sa mu to nepodarí, akceptuje. Preto musíme zaručiť, že sa $A_2$ buď zasekne alebo prejde až do konca slova\footnote{Ak sa zasekne, slovo z $L_2$ tam určite nebude, lebo $A_2$ je deterministický a teda neexistuje akceptačný výpočet. Ak sa nezasekne, nevieme povedať o tom slove nič, pokiaľ ho neprejdeme celé.}. Akonáhle $A_2$ dosiahne akceptačný stav, negatívny lookahead musí zamietnuť. 

Ďaľšie pozorovanie nám hovorí, že negatívny lookahead akceptuje vždy nejaké slovo z komplementu $L_2$. Ale komplement vzhľadom na akú abecedu? V skutočnosti nekonečnú -- ľubovoľný znak, ktorý nepatrí do $\Sigma_2$, znamená zaseknutie $A_2$, t.j. akceptáciu. Ak sa na to pozrieme z väčšej ďiaľky, uvidíme $L_3$, s ktorým robíme prienik. $A_3$ musí dočítať slovo do konca a na úplne neznámom znaku sa zasekne, takže z pohľadu výslednej akceptácie slova nevadí, ak by kvôli tomu znaku zamietol už negatívny lookahead. Preto stačí urobiť komplement vzhľadom na $\Sigma_2 \cup \Sigma_3$. 

Poďme upravovať $A_2$, začneme vytváraním komplementu. Ak $\Sigma_3 \setminus \Sigma_2 \neq\emptyset$\footnote{Inak $A_2'=A_2$.}, potom vytvoríme $A_2'= (K_2',\Sigma_2',\delta_2',q_{0},F_2')$ tak, že pridáme nové znaky $\Sigma_2'=\Sigma_2 \cup \Sigma_3$,  jeden nový stav\footnote{Pre každý nový stav predpokladáme, že je jedinečný -- t.j. žiaden taký v množine stavov ešte nie je.} $K_2'=K_2 \cup \lbrace q_{ZLE} \rbrace$ a prechody na nové znaky z každého stavu: 
\begin{alignat*}{3}
& \forall q \in K_2, &&~ \forall a \in \Sigma_2 &&~~:~~  \delta_2'(q,a)=\delta_2(q,a) \\
& \forall q \in K_2, &&~ \forall a \in \Sigma_3 \setminus \Sigma_2 &&~~:~~ \delta_2'(q,a)=q_{ZLE} \\
&~&&~ \forall a \in \Sigma_2' &&~~:~~  \delta_2'(q_{ZLE},a)=q_{ZLE}
\end{alignat*}
 $F_2'=F_2.$ Do všetkých stavov sme pridali prechody na nové znaky a $q_{ZLE}$ má 1 prechod na každý znak, takže $A_2'$ je stále deterministický. Zároveň nové znaky vedú do stavu, z ktorého sa nedá dostať do žiadneho akceptačného, z čoho vyplýva $L(A_2')=L_2$.

Teraz $A_2'$ zmeníme na $A_2''$ tak, aby akceptoval práve vtedy, keď $\nlookahead L_2)$. Najprv si skonštruujeme množinu stavov, z ktorých sa vieme dostať do akceptačného stavu: $H=\nobreak\lbrace  q \in K_2'~|~ \exists w \in {\Sigma_2'}^*, ~ \exists q_A \in F_2': ~ (q,w)\vdash_{A_2'}(q_A,\varepsilon) \rbrace $, nasledovným spôsobom: $$ H_0 = F_2' $$ 
$$H_{i+1} = H_i \cup \lbrace q \in K_2'~|~ \exists p \in H_i ~~ \exists a \in \Sigma_2': ~ \delta(q,a)=p \rbrace$$
Zrejme $\exists j \in \N: ~ H_{j+1}=H_j = H$. Nás zaujíma množina $K_2' \setminus H$, v ktorej sa nachádzajú všetky stavy, z ktorých sa na žiadnu postupnosť znakov nedá dostať do žiadneho akceptačného stavu.

$A_2''= (K_2'',\Sigma_2'',\delta_2'',q_{0},F_2'')$: $$K_2'' = K_2' \cup \lbrace q_A, q_Z \rbrace, ~\Sigma_2'' = \Sigma_2', ~F_2'' = (K_2'\setminus H) \cup \lbrace q_A \rbrace$$

$\delta''$ je definovaná nasledovne: 
\begin{alignat*}{4}
 & \forall q \in K_2' \setminus F_2'  &~ \forall a \in \Sigma_2' ~&~:~~  \delta_2''(q&&,a)=\delta_2'(q,a) \\
 & \forall q \in K_2' \setminus F_2'  &~ \forall a \in \Sigma_2' ~&~:~~  \delta_2''(q&&,\varepsilon)=q_A \\
 & \forall q \in F_2' &~ \forall a \in \Sigma_2' ~&~:~~ \delta_2''(q&&,a)=q \footnotemark \\
 & ~ & ~\forall a \in \Sigma_2' ~&~:~~ \delta_2''(q_A&&,a)=q_Z 
\end{alignat*}
\footnotetext{Tento riadok v podstate netreba, $A_2''$ sa môže rovno zaseknúť, lebo $A_2'$ práve akceptoval.}
Je dobré poznamenať, že $A_2''$ je takmer deterministický. Chýbajú mu prechody z $q_Z$ -- môžeme ho nechať cykliť v tomto stave, ale nevadí nám ani keď sa zasekne. Nedeterministické rozhodnutie vykonáva iba jedno -- pri prechode do stavu $q_A$. Vtedy háda, že už je na konci slova. Ak nie je, $\delta$-funkcia ho pošle do stavu $q_Z$. Podľa toho je zrejmé, že ak existuje akceptačný výpočet a dočítal slovo do konca, je práve jeden\footnote{Okrem prípadu, kedy dočíta slovo a je v stave z $(K_2'\setminus H)$ -- vieme ho predĺžiť o krok na $\varepsilon$ a skončiť v $q_A$. Jadro výpočtu ale zostáva rovnaké -- jednoznačné.} \footnote{Zaujímavé je, že aj zamietací výpočet je pre každé slovo jednoznačný.}.

Tvrdíme $ L_1\lookahead L(A_2''))L_3 =L_1\nlookahead L_2)L_3= L $.
Keďže $A_1$ a $A_3$ sa pri oboch výpočtoch budú chovať rovnako (sú nezávislé od lookaheadov), nebudeme sa nimi pri dôkaze zaoberať.

$\subseteq :$ Máme akceptačný výpočet pre $A_2''$ na nejakom vstupe. Akceptačný stav mohol byť buď z množiny $K_2'\setminus H$, to znamená, že pôvodný automat $A_2'$ sa dostal do stavu, z ktorého už nemohol nijako akceptovať\footnote{Sem spadá aj prípad, keď $A_2$ prečítal neznámy znak a zasekol sa -- $A_2'$ zostáva až do konca slova v stave $q_{ZLE}$.}. V takom prípade $\nlookahead L_2)$ akceptuje. V druhom prípade mohol $A_2''$ akceptovať pomocou $q_A$, čo znamená, že dočítal slovo do konca (pretože z $q_A$ sa na ľubovoľný znak dostaneme do $q_Z$, v ktorom sa $A_2''$ zasekne a nebude akceptovať) a ani raz sa nedostal do akceptačného stavu automatu $A_2'$. Teda aj $\nlookahead L_2)$ akceptuje.

$\supseteq :$ Nech $\nlookahead L_2)$ akceptoval, t.j. na $A_2$ bol vykonaný nejaký neakceptujúci výpočet ($A_2$ je deterministický, takže existuje práve jeden pre každé slovo). Rovnakú postupnosť stavov bude mať aj výpočet na $A_2''$ (automat obsahuje všetky stavy aj $\delta$-funkciu z $A_2$, počiatočný stav je ten istý). Ak sa $A_2$ zasekol na neznámom znaku, v $A_2'$ na ten znak pridáme prechod do stavu $q_{ZLE}$ a v ňom zostaneme až do konca slova. Keďže $q_{ZLE}$ nie je v $A_2'$ akceptačný a nedá sa z neho na žiadne slovo dostať do ľubovoľného akceptačného stavu, $q_{ZLE} \in K_2' \setminus H$ a teda $q_{ZLE} \in F_2''$. Ak sa $A_2$ nezasekol, tak dočítal slovo do konca a v postupnosti stavov jeho výpočtu sa nenachádza žiaden z množiny $F_2$. V tom prípade $A_2''$ z posledného stavu prejde na $\varepsilon$ do $q_A$ (2. riadok definície $\delta_2''$) a akceptuje.

Z práve dokázaného tvrdenia a vety \ref{lookaround+R} už vyplýva aj platnosť našej lemy.
\end{proof}

\begin{lema}\label{nlb+R}
Trieda $\R$ je uzavretá na negatívny lookbehind.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=\nobreak L_{i},\allowbreak i \in \lbrace 1,2,3\rbrace $. Ukážeme, že $L=L_1\nlookbehind L_2)L_3 \in \R$.

Nemôžeme skonštruovať $A_2''$ také, že bude akceptovať práve vte\-dy, keď $\nlookbehind L_2)$, pretože nevieme čítať doľava -- teda nevieme zaručiť, že miesto, kde začína výpočet $A_2''$ je skutočný začiatok slova. Mechanizmus lookbehindu musí byť riadený zvonku, automatom pre $L$. Skonštruujeme ho. $C=(K,\Sigma, \delta,q_0,F):$ 
$$K=K_3\cup \lbrace (q,A) ~|~ q \in K_1 \wedge A \subseteq K_2 \rbrace,~\Sigma = \Sigma_1\cup\Sigma_2\cup\Sigma_3,~q_0=(q_{01},\lbrace q_{02}\rbrace),F=F_3$$
$\delta:$
\begin{alignat*}{5}
& \forall q \in K_1 ~&& \forall A \subseteq K_2  && ~ \forall a \in \Sigma_1 \cap \Sigma_2 &&~~:~~ \delta((q,A),a) \ni (\delta_1(q,a), B\cup \lbrace q_{02}\rbrace)\\ 
&                   ~&&                          && &&~~~~~~B=\lbrace r ~|~ \exists s \in A:~ \delta_2(s,a)=r \rbrace \\
& \forall q \in K_1 ~&& \forall A \subseteq K_2  &&~\forall a \in \Sigma_1 \setminus \Sigma_2 &&~~:~~ \delta((q,A),a) \ni (\delta_1(q,a),\lbrace q_{02}\rbrace) \\
& \forall q \in F_1 ~&& \forall A \subseteq K_2 \setminus F_2 && &&~~:~~ \delta((q,A),\varepsilon) \ni q_{03} \\
& \forall q \in K_3 ~&&                          &&~ \forall a \in \Sigma_3 &&~~:~~ \delta(q,a) \ni \delta_3(q,a)
\end{alignat*}
Prvý riadok $\delta$-funkcie hovorí, že $A_1$ a všetky rozbehnuté výpočty $A_2$ prejdú do ďalšieho stavu a zároveň sa rozbehne nový výpočet $A_2$. Ak by sme hľadali jeden akceptačný výpočet $A_2$ stačilo by tipnúť si začiatok a odtiaľ ho simulovať. Lenže simulujeme negatívny lookbehind, teda ak neexistuje akceptačný výpočet, tak my akceptujeme (prejdeme na simulovanie $A_3$, 4. riadok). A to vieme povedať len v prípade, že sme videli všetky možné výpočty. Keďže $A_2$ je deterministický, pre každé slovo existuje práve jeden výpočet a zároveň sa nikdy nezasekne (na svojej abecede), teda nám stačí skontrolovať množinu stavov $A$ vtedy, keď sa $C$ rozhodne, že $A_1$ končí výpočet. Ak v $A$ je nejaký akceptačný stav, potom $C$ nevie prejsť do stavu $q_3$. Tým pádom sa nedostane k simulovaniu $A_3$ a ani k svojim akceptačným stavom.

$L(C)=L.$

$\subseteq:$
Majme akceptačný výpočet $C$ na $w$. Z definície $F$ vyplýva, že $A_3$ akceptoval, teda $\exists u,v$ také, že $w=uv$ a $v \in L_3$. Do $q_{03}$ sa dá dostať len z dvojice $(q,A)$ takej, že $q\in F_1$, teda $u\in L_1$, a $A \cap F_2 = \emptyset$, teda $\nexists x,y$ také, že $u=xy$ a $y \in L_2$. To vyplýva z toho, že v každom znaku $u$ začal jeden výpočet na $A_2$ a žiaden z nich neakceptoval. Teda negatívny lookbehind akceptoval a $w\in L$.

$\supseteq:$
Nech $w\in L$, teda $\exists u,v$ také, že $w=uv,~ u \in L_1, v\in L_3$ a $\forall x,y:~u=xy$ platí $y \notin L_2$. Pre $u,v$ teda existujú akceptačné výpočty na $A_1,A_3$ a pre všetky $y$ neakceptačné na $A_2$. Z toho už vieme vyskladať akceptačný výpočet na $C$.
\end{proof}

\begin{veta}
Trieda $\R$ je uzavretá na negatívny lookaround.
\end{veta}

Zjavne konečné automaty si s negatívnym lookaroundom poradia. Pozrime sa teraz na model $\re$ s pridaným negatívnym lookaroundom. Najprv musíme skontrolovať kombinácie operácií ako v \cite[Lema. 2.2.8. a 2.2.9]{mojaBak}. Ukazuje sa, že aj tu dostávame rovnaké výsledky ako pri pozitívnej verzii.

\begin{lema}\label{nla*}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = \left( L_1 \left( ?!~ L_2\right) L_3 \right) * L_4$. Potom $L(\alpha) \in \R$.
\end{lema} 
\begin{proof}
Podobne ako v dôkaze vety \ref{nla+R} pretransformujeme $\nlookahead L_2)$ na akýsi $\lookahead L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $\nlookahead L_2)$. Potom $\beta = \left( L_1 \lookahead L(A_2'') ) L_3 \right) * L_4$, $L(\beta) = L(\alpha) \in \R$ podľa lemy k vete \ref{lookaround+R}.
\end{proof}

\begin{lema}\label{nlb*}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = L_4 \left( L_1 \left(?<!~ L_2\right) L_3 \right) *$. Potom $L(\alpha)~\in~\R$.
\end{lema} 
\begin{proof}
Použijeme konštrukciu ako v dôkaze vety \ref{nlb+R}, kde pretransformujeme $\nlookbehind L_2)$ na $\lookbehind L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $\nlookbehind L_2$. Z toho vznikne $\beta = L_4 \left( L_1 \left(?<=~ L(A_2'')\right) L_3 \right) *$, $L(\beta) = L(\alpha) \in \R$ podľa lemy k vete \ref{lookaround+R}.
\end{proof}

\begin{veta}\label{nlookaround+R}
Trieda nad regexami s negatívnym lookaroundom je $\R$.
\end{veta}
\begin{proof}
Podobne ako v dôkaze vety \ref{lookaround+Regex} je netriviálna iba kombinácia operácií negatívny lookaround a $*$. Podľa liem \ref{nla*} a \ref{nlb*} máme stále regulárne jazyky.
\end{proof}

\begin{dosledok}
Trieda nad regexami s pozitívnym a negatívnym lookaroundom je $\R$.
\end{dosledok}
\begin{proof}
Výpočet lookaroundu je z pohľadu vonkajšieho regexu nebadateľný, pretože žiadne písmenká zo vstupu mu nie sú priradené. Pre túto vlastnosť lookaround ne\-ov\-plyv\-ňu\-je zvyšok regexu, teda ani iné lookaroundy. Výnimkou je situácia, kedy look\-around nenájde podslovo zo svojho jazyka resp. negatívna verzia podslovo nájde a zastaví celý výpočet. Avšak pokiaľ akceptuje, zvyšok regexu pokračuje vo výpočte ako keby tam nebol.

Musíme vyriešiť iba prípad, kedy je do seba vnorených niekoľko pozitívnych a negatívnych lookaroundov. V takejto situácii vieme postupovať z najvnútornejšieho regexu s lookaroundom s hĺbou vnorenia 1. Jeho jazyk je regulárny a teda ho vieme prepísať na regex z $\re$. Takýmto spôsobom vieme zvnútra von prepisovať regex, až skončíme s regexom z $\re$, teda matchujúcim regulárny jazyk.

Formálne by sme to zapísali ako indukciu vzhľadom na hĺbku vnorenia lookaroundov v regexe (bez ohľadu na to, či sú pozitívne alebo negatívne).
\end{proof}

\section{Vlastnosti triedy $\lel$}

Pridanie nových operácií medzi regulárne výrazy síce pridalo na sile modelu, ale mohlo pokaziť jeho uzáverové vlastnosti. Vieme, že regulárne jazyky sú uzavreté na všetky možné operácie, ktoré poznáme. Posilnenie modelu spätnými referenciami a následne lookaroundom však ohrozilo uzavretosť na základnú operáciu regulárnych výrazov -- zreťazenie. Pokiaľ zreťazíme 2 regexy obsahujúce lookahead alebo lookbehind, tieto operácie začnú zasahovať do slova z vedľajšieho jazyka. Ak by išlo o zreťazenie so zarážkou (napr. $\alpha\#\beta$), na koniec každého lookaheadu v $\alpha$ by stačilo pripojiť $.*\#$, prípadne znak \$ nahradiť znakom \#. Podobne by sme v regexe $\beta$ pridali na začiatok každého lookbehindu $\#.*$ prípadne by sme vymenili znak $\textasciicircum$  znakom \#. Potom by tieto operácie zostali ,,skrotené'' na území slova, ktoré danému regexu prislúcha.

Otázkou zostáva, ako to spraviť, keď zarážku k dispozícii nemáme. Odpoveďou je nasledujúca veta.

\begin{veta}
Trieda $\lel$ je uzavretá na zreťazenie.
\end{veta}
\begin{proof}
Nech $\alpha, \beta\in \le$. Chceme ukázať, že jazyk $L(\alpha)L(\beta) \in \lel$. Intuitívne nás to vedie k riešeniu $\alpha\beta$, čo ale nemusí byť vždy správne. Problémom sú operácie lookaround, presnejšie každý lookahead v $\alpha$ môže zasahovať do slova z $L(\beta)$ a takisto každý lookbehind z $\beta$ môže zasahovať do slova z $L(\alpha)$. Navyše, ak lookahead obsahuje $\$$ a lookbehind $\textasciicircum$, potom zasahujú do slova z iného jazyka určite. V takom prípade môže regex $\alpha\beta$ vynechať niektoré slová z $L_1L_2$ a tiež pridať nejaké nevhodné slová naviac. Preto treba nájsť spôsob, ako operácie lookaroundu vhodne ,,skrotiť''. Predpokladajme, že $\alpha$ má $k$ označených zátvoriek, potom regex pre jazyk $L(\alpha)L(\beta)$ vyzerá nasledovne:
\begin{equation} \label{zretazenie}
\lookahead \mathop(_1 \alpha \mathop)_1 \mathop(_{k+2}\beta \mathop)_{k+2} \mathdollar) \alpha ' \backslash \text{$k$+2} ~\lookbehind \textasciicircum\backslash 1\beta ')
\end{equation}
V $\alpha,\beta$ treba vhodne prepísať spätné referencie podľa nového prečíslovania zátvoriek. $\alpha '$ je $\alpha$ prepísaný tak, že pre každý lookahead:
\begin{itemize}
\item bez \$ -- na koniec pridáme $.* \backslash \text{$k$+2} ~\mathdollar $
\item s \$ -- pred \$ pridáme $\backslash \text{$k$+2}$
\end{itemize}
$\beta '$ je $\beta$ prepísaný tak, že pre každý lookbehind:
\begin{itemize}
\item bez $\textasciicircum$ -- na začiatok pridáme $\textasciicircum \backslash 1.*$
\item s $\textasciicircum$ -- za $\textasciicircum$ pridáme $ \backslash 1$
\end{itemize}
Čo presne robí regex ~\ref{zretazenie}? Nech $w$ je vstupné slovo, ktoré chceme matchovať. Lookahead na začiatku ho nejako rozdelí na $w_1$ a $w_2$, pričom $w=w_1w_2$, tak, že $w_1$ bude patriť do $L(\alpha)$ a podslovo $w_2$ do $L(\beta)$. Ešte musíme overiť, či $\alpha$ matchuje $w_1$ samostatne.

Preto sme v $\alpha$ prepísali všetky lookaheady. V $\alpha '$ každý z nich musí na konci slova $w$ matchovať $w_2$ (toto zabezpečí spätná referencia $\backslash \text{$k$+2}$ a \$) a teda matchovanie regexu $\alpha$ zostane výlučne na podslove $w_1$. Analogicky to platí pre upravené lookbehindy v~$\beta '$.

\end{proof}

\section[Chomského hierarchia]{Zaradenie do Chomského hierarchie}

Známa je doteraz takáto hierarchia:
$$ \R = \rel \subsetneq \el \subsetneq \lel \subseteq \L_{CS} $$
a triviálne platí $\lel \subseteq \nlel $. Teraz k tomu doplníme niekoľko výsledkov.

\begin{veta}
$ \nlel \subseteq \L_{CS} $
\end{veta}
Tento dôkaz využíva formalizmus z podkapitoly \ref{novy_formalizmus}, pretože je vďaka tomu prehľadnejší a exaktnejší. Odporúčame preto čitateľovi tento dôkaz preskočiť a vrátiť sa k nemu, keď bude s daným formalizmom oboznámený.
\begin{proof}
Podľa vety \ref{le+lcs} vieme, že $\lel\subseteq\L_{CS}$. Takže potrebujeme pridať operácie negatívny lookahead a negatívny lookbehind. Nech $\alpha\in\nle$, zostrojíme lineárne ohraničený Turingov stroj T, ktorý bude simulovať výpočet $\alpha$.

Pokiaľ $\alpha$ neobsahuje negatívny lookaround, potom $\alpha\in\le$ a vieme zostrojiť požadovaný LBA. Nech $\alpha$ obsahuje aspoň 1 negatívny lookaround. Budeme postupovať indukciou vzhľadom na počet vnorených negatívnych lookaroundov $k$.

\textit{Báza indukcie:} $k=1$, teda regex $\alpha$ obsahuje 1 negatívny lookaround, ktorý obsahuje regex z $\le$. Zostrojíme T pre $\alpha$. Nech LBA A simuluje regex $\alpha$ a ignoruje pri tom negatívny lookaround. LBA A bude nedeterministický a bude fungovať nasledovne:

Stroj A je v každom kroku v konfigurácii podľa definície \ref{def_konfiguracia}. Na páske bude mať slovo s pomocnou informáciou ukladanou v poschodových symboloch a v stave bude obsahovať regex s ukazovateľom. LBA A bude postupovať z konfigurácie do konfigurácie podľa kroku výpočtu definovaného v \ref{dfkonfig}. Zrejme takto vieme simulovať ľubovoľný regex z $\le$.

Zostrojíme deterministický LBA B pre regex vnútri negatívneho lookaroundu (nech je to $\beta$). Zostrojíme najprv LBA B' tak, ako LBA A pre $\alpha$ bez negatívneho look\-aroundu. $\beta$ sa líši od regexu z $\le$ tým, že má posunuté číslovanie zátvoriek a môže sa odkazovať na zátvorky v $\alpha$ naľavo od nej. Toto nie je problém, pretože dané zátvorky už boli simulované a informácia o ich podslovách je uložená vo vyšších poschodiach symbolov. Zároveň vstupné slovo pre $\beta$ je len podslovo vstupu, preto si musíme označiť hranice. Vieme si do poschodí symbolov označiť endmarkery, ktoré výpočet B' smie prekročiť len ak potrebuje informáciu o spätných referenciach. Nech teda B' simuluje $\beta$ na podslove ohraničenom endmarkermi. B' akceptuje práve vtedy, keď $\beta$ matchuje dané podslovo. Nech B'' je ekvivalentný deterministický LBA k B'. Potom výsledný stroj B pre negatívny lookaround je deterministický LBA taký, že na začiatku prekopíruje celé vstupné slovo aj s poschodovou informáciou na ďalšiu lineárne ohraničenú pásku \footnote{Taký istý výpočet vieme spraviť v ďalších stopách, ale keď hovoríme o ďalšej páske, je to zrozumiteľnejšie.}. Pokiaľ simuluje negatívny lookahead, začiatok vstupného podslova je fixný a koniec môže byť na ľubovoľnom mieste od fixného začiatku až po samotný koniec vstupného slova. Preto B bude postupne spúšťať B'' na všetkých týchto podslovách vstupu tak, že bude postupne posúvať koncový endmarker doprava. Akonáhle nejaká simulácia akceptuje, B zamietne. Ak všetky výpočty zamietnu, potom B akceptuje. Pre negatívny lookbehind je simulácia analogická, akurát koncový endmarker je fixný a začiatočný sa posúva smerom doľava -- k začiatku samotného vstupného slova. Vidíme, že B je deterministický a simuluje daný negatívny lookaround.

Teraz zostrojíme T zo strojov A a B. T bude simulovať A, pokým nenarazí na negatívny lookaround. V tom momente si zapamätá, v akom stave bol A, kde sa nachádzal na vstupe (napríklad tak, že si do poschodového symbolu zaznačí, že tam skončil) a začne simulovať B. Keďže B si kopíruje celú vstupnú pásku na inú pásku a pracuje tam, informácie pre A zostanú nedotknuté. Ak B akceptoval, T pokračuje simuláciou A a akceptuje práve vtedy, keď akceptuje A. Ak B zamietol, T zamietne. Ak existuje výpočet regexu $\alpha$ na vstupnom slove, potom existuje aj správny počet iterácií pre každú $*$ a správny výber v alternácii, čo sú nedeterministické rozhodnutia, ktoré v krokoch výpočtov A robí. Preto na tomto vstupnom slove existuje aj akceptačný výpočet pre T. A naopak, ak T akceptoval, potom jeho akceptačný výpočet obsahuje akceptačný výpočet $\alpha$.

\textit{Indukčný krok:} Predpokladajme, že vieme zostrojiť LBA pre regex s $k-1$ vnorenými negatívnymi lookaroundmi. Zostrojíme LBA T pre $\alpha$ s hĺbkou vnorenia negatívnych lookaroundov $k$.

Zoberme negatívny lookaround, ktorý nie je obsiahnutý v žiadnom negatívnom look\-arounde (teda je ten vonkajší). Ten obsahuje negatívne lookaroundy s hĺbkou vnorenia najviac $k-1$. Podľa indukčného predpokladu vieme zostrojiť LBA C pre celý regex vnútri tohto negatívneho lookaroundu. K takému vieme zostrojiť ekvivalentný deterministický LBA C'. Tento stroj je analogický k B'' v bází indukcie, preto z neho rovnakým spôsobom vyrobíme B. Pre vonkajší regex zostrojíme LBA A ignorujúci negatívny lookaround ako v báze indukcie. Na koniec spojíme rovnakým spôsobom A a B do LBA T, ktorý sme chceli zostrojiť.
\\ \par
V indukcii sme neriešili prípad, kedy $\alpha$ obsahuje viacero negatívnych lookaroundov, ktoré navyše môžu mať rôzne hĺbky vnorenia. Platí, že akonáhle táto operácia akceptuje, jej výpočet je zahodený a celkový výpočet sa vracia na to isté miesto na vstupe, teda negatívny lookaround výpočet buď celkovo zastaví alebo ho nijako neovplyvňuje. Z toho vyplýva, že viaceré výskyty môžeme riešiť samostatne, a to konštrukciou, ktorú sme naznačili v indukcii.

Ďalej netreba zabúdať, že vnútri negatívneho lookaroundu sa môžeme odvolávať na všetky zátvorky naľavo od nás nachádzajúce sa buď v hlavnom regexe alebo v aktívnom negatívnom lookarounde (t.j. takom, ktorého otváracia zátvorka je naľavo a zatváracia zátvorka sa nachádza napravo od nás).
\end{proof}

\begin{veta}\label{lelcf}
$\lel$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Majme jazyk $L_{ww}=\lbrace ww~|~w \in \lbrace a,b \rbrace^* \rbrace \in \L_{CF}$, nech $ \alpha = ([ab]*)\backslash 1 $.
Zrejme $ L(\alpha) = L_{ww} $, teda $L_{ww}\in \lel$.

Ukážeme, že jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace \notin \lel$. Sporom, nech $L \in \lel$, teda existuje regex $\beta\in\le$ taký, že $L(\beta) = L$. 

Vieme, že $L \notin \el$, preto $\beta$ musí obsahovať nejaký lookaround. Zároveň z $L \notin \R$ a vety \ref{lookaround+Regex} vyplýva, že musí obsahovať aj spätné referencie.

Kam sa môžu spätné referencie odkazovať a kam ich potom môžeme umiestniť? 
\begin{list}{$\bullet$}{Nech výraz, na ktorý sa odkazujú, vie vyrobiť:}
\item $a^i$. Môžu nastať 4 prípady:
\begin{list}{$\circ$}{}
\item $k$-te zátvorky aj $\backslash k$ sa nachádzajú v hlavnom regexe:

Potom zátvorky s referenciami matchujú dokopy $a^{2i}$. Na to, aby sme vedeli matchovať celé $\lbrace a \rbrace^*$, by sme k tomu navyše museli vedieť matchovať $a^h$, kde $h\in\lbrace 0,\dots, i-1\rbrace$, čo v konečnom dôsledku pre $i$ idúce do nekonečna znamená vedieť $\lbrace a\rbrace^*$ a potom spätné referencie nepotrebujeme. 
\item $k$-te zátvorky sú v hlavnom regexe a $\backslash k$ je v lookarounde

\item $k$-te zátvorky sú v lookarounde a $\backslash k$ je v hlavnom regexe

\item $k$-te zátvorky aj $\backslash k$ sú v lookaroundoch
\end{list}
V každom z prípadov platí, že zátvorky aj spätné referencie musia matchovať v prvej polovici slova (časť $a^n$) a neprenášajú žiadnu informáciu do časti $b^n$.
\item $a^ib^j$. Potom možné prípady umiestnenia sú len 2., 3., a 4. z predošlej možnosti, pretože zátvorky a k nim prislúchajúce referencie musia matchovať to isté pod\-slo\-vo vstupu, inak by nesúhlasili so štruktúrou slova jazyka $L$.
\item $b^j$. Toto je analogický prípad k $a^i$.
\end{list}
Spätné referencie buď matchujú v rovnakej polovičke slova ako k nim prislúchajúce zátvorky alebo musia matchovať to isté podslovo. Z toho vidíme, že jediná informácia, ktorú prenášajú je počet $a$ respektíve $b$ v danej polovičke a táto informácia v tej polovičke aj zostáva. Keďže nič neprenášajú do druhej polovice slova a podľa vety \ref{lookaround+Regex} vieme, že so zvyšnými operáciami jazyk L nevieme matchovať, regex $\beta$ neexistuje.

\end{proof}

\begin{dosledok}
$\lel \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$\nlel$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Opäť použíjeme jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace$ a budeme dokazovať sporom. Nech $L \in \lel$.

Z vety \ref{lelcf} vidíme, že výraz musí obsahovať negatívny lookaround. Z jej dôkazu vidíme, že spätné referencie nepomôžu, nech sa ich pokúsime hocijako použiť. Z toho vyplýva, že ich nepoužijeme a z vety \ref{nlookaround+R} zistíme, že nám zostal model schopný vyrobiť iba regulárne jazyky. Spor.
\end{proof}

\begin{dosledok}
$\nlel \subsetneq \L_{CS}$
\end{dosledok} 

Posledné výsledky s jazykom $L=\lbrace a^nb^n~|~n\in\N\rbrace$ nabádajú na myšlienky o tom, či je možné doplniť model moderných regulárnych výrazov tak, aby zvládal tento a možno ďalšie bezkontextové jazyky. Pre tento konkrétny jazyk by stačilo, aby bolo možné modifikovať podslovo reprezentované spätnými referenciami nejakým homomorfizmom -- napríklad udať v špeciálnej štruktúre tesne pred referenciou, ako treba ktoré písmenká zameniť.
Podľa Chomského--Schützenbergerovej vety potrebujeme homomorfizmus, prienik s regulárnym jazykom a Dyckov jazyk a porom vieme vygenerovať všetky bezkontextové jazyky. Prienik máme vďaka pozitívnemu lookaroundu, regulárne jazyky vieme zapísať všetky a homomorfizmus pridáme. Zostáva overiť, či nový model vie zapísať Dyckov jazyk, čo zostáva otvoreným problémom.

Idea zavedenia homomorfizmu už bola skúmaná na menšom modeli -- triede $\e$. Zaoberá sa tým napríklad článok \cite{plus_homomorfizmus}.
\\ \par
Po výsledkoch v tejto kapitole vyzerá hierarchia nasledovne:
$$\R \subsetneq \el \subsetneq \lel \subseteq \nlel \subsetneq \L_{CS}$$
Vzťah medzi triedami $\le$ a $\nle$ je otvoreným problémom. Naša hypotéza je, že $\lel$ je vlastnou podmnožinou $\nlel$. Dobrým kandidátom na dôkaz by mohol byť jazyk $L=\lbrace a^p~|~p\emph{ je prvočíslo}\rbrace$, ku ktorému existuje regex $\gamma\in\nle$:
\begin{equation*}
\gamma = \nlookahead (aaa*)\backslash 1 (\backslash 1)*\$ )
\end{equation*}

\section{Priestorová zložitosť}

\begin{veta}
$\lel \subseteq NSPACE(\log n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
Ukážeme, že ľubovoľný $\alpha \in \le$ vieme simulovať nedeterministickým Turingovým strojom s jednou vstupnou read-only páskou a jednou pracovnou páskou, na ktorej použijeme maximálne logaritmický počet políčok.

Celý regex si budeme uchovávať v stavoch\footnote{Každý regex má podľa definície konečnú dĺžku, to znamená aj konečný počet stavov.} a pridáme doňho špeciálny znak $ \blacktriangleright $, ktorým si budeme ukazovať, kam sme sa v regexe dopracovali -- bude to akýsi smerník na znak, ktorý práve spracovávame. Teda stav bude vyzerať takto: $q_{\beta\blacktriangleright\xi}$ (pre lepšiu čitateľnosť budeme uvádzať namiesto stavu iba jeho dolný index: $\beta\blacktriangleright\xi$), kde $\beta\xi = \alpha$, časť $\beta$ sme už namatchovali na vstup a práve sa chystáme pokračovať časťou $\xi$. Ak $\blacktriangleright$ ukazuje na znak, porovnáme ho s aktuálnym znakom na vstupnej páske. Pokiaľ sa nezhodujú, výpočet sa zasekne. Pri zhode pokračujeme až kým sa nám neminie vstup aj regex. Ak $\blacktriangleright$ ukazuje na metaznak, potom zistíme o akú operáciu ide (ak má viac znakov, treba na to niekoľko stavov -- napr. lookahead) a začneme ju vykonávať.

Pracovná páska bude slúžiť ako úložisko smerníkov na rôzne miesta vstupnej pásky. Bude mať formát $A_1\#A_2\#\dots\#A_m$. Adresu nejakého políčka na vstupnej páske vieme zapísať v priestore $\log n$. Ak ukážeme, že $m$ je konštanta, potom $m.\log n \in O(\log n)$. Adresa $A_1$ bude rezervovaná pre prvý adresný slot na aktuálnu pozíciu hlavy na vstupe, nech si ju máme odkiaľ okopírovať, keď treba. Adresy budeme využívať pri operáciách spätná referencia, lookahead a lookbehind.

Keďže celý regex vidíme pri konštrukcii Turingovho stroja, vieme si do stavov zakódovať význam a poradie adresných slotov. A celú pracovnú pásku si predpripraviť (napísať potrebný počet \#). 

Teraz skonštruujeme Turingov stroj $M = \left( K, \Sigma, \delta, q_0, F \right)$ k regexu $\alpha$. 
$$ K = \lbrace \beta\blacktriangleright\xi ~|~ \beta,\xi \textit{ sú podslová } \alpha \textit{ také, že } \beta\xi = \alpha \rbrace $$
$$ \Sigma = \Sigma(\alpha)\footnote{T.j. všetky znaky a metaznaky použité v regexe $\alpha$.}, ~
q_0 = \blacktriangleright\alpha, ~
F = \lbrace \alpha\blacktriangleright \rbrace $$
\underline{$\delta:$ (v tvare: stav, znak čítaný na vstupnej páske)} 

Kvôli prehľadnosti popíšeme len hlavné kroky algoritmu. 
\begin{list}{}{}
\item $\delta(\beta\blacktriangleright a \xi, a) = \lbrace (\beta a \blacktriangleright \xi, 1) \rbrace ~ \forall a \in \Sigma$ -- Ak je v regexe znak, matchujeme ho s tým na vstupe.
\item $\delta(\beta\blacktriangleright(\gamma)\xi, a) = \lbrace (\beta(\blacktriangleright\gamma)\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku pre $\backslash k$.
\item $\delta(\beta(\gamma\blacktriangleright)\xi, a) = \lbrace (\beta(\gamma)\blacktriangleright\xi, 0) \rbrace$ -- Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu konca pre $\backslash k$. Používame polootvorený interval -- znak na koncovej adrese do podslova nepatrí.
\item $\delta(\beta\blacktriangleright(\gamma)*\xi, a) = \lbrace (\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Pri Kleeneho $*$ máme možnosť vykonať aj 0 iterácií, teda zátvorky preskočiť. Ak sú to $k$-te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku aj konca pre $\backslash k$.
\item $\delta(\beta(\gamma)\blacktriangleright * \xi, a) = \lbrace (\beta(\blacktriangleright\gamma)*\xi, 0),(\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Kleeneho $*$: buď opakujeme alebo pokračujeme ďalej.
\item $\delta(\beta\blacktriangleright\backslash k \xi, a) = \lbrace (q_{najdi\_zaciatok(k)}, 0) \rbrace$ -- Najprv si zapamätáme aktuálnu pozíciu na vstupe (ďalej označovanú ako 'aktuálna pracovná pozícia'). Stav $q_{najdi\_zaciatok(k)}$ zodpovedá presunu hlavy na vstupnej páske na začiatočnú pozíciu podslova. Tu začneme algoritmus porovnávania podslov podľa definície spätnej referencie -- aké podslovo matchujú $k$-te zátvorky, také isté musí ležať aj na 'aktuálnej pracovnej pozícii'. Algoritmus bude porovnávať vždy postupne po jednom znaku od začiatočnej pozície (ľavá zátvorka) po (koniec - 1) (pravá zátvorka):

\begin{verbatim}
pokiaľ začiatok != koniec: 
    zapamätaj si znak 
    začiatok++ 
    presuň hlavu na pozíciu 'aktuálna pracovná pozícia' 
    porovnaj znak (ak nesedí, zasekni sa) 
    (aktuálna pracovná pozícia)++ 
    presuň hlavu na pozíciu 'začiatok' 
presuň hlavu na pozíciu 'aktuálna pracovná pozícia'
\end{verbatim}
Vidíme, že si dočasne potrebujeme zapamätať adresu 'aktuálna pracovná pozícia', ale po skončení tohto algoritmu ju môžeme zahodiť.

Po úspešnom zbehnutí algoritmu TS prejde do stavu $\beta\backslash k \blacktriangleright\xi$.
\item $\delta(\beta\blacktriangleright\lookahead\gamma)\xi, a) = \lbrace (\blacktriangleright\gamma, 0) \rbrace$ -- Lookahead: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske a spracujeme regex vnútri lookaheadu. Ak uspejeme, presunieme hlavu na vstupnej páske naspäť na zapamätanú pozíciu a pokračujeme v regexe ďalej: $\delta(\gamma\blacktriangleright, a) = \lbrace (\beta\lookahead\gamma)\blacktriangleright\xi, 0) \rbrace $.
\item $\delta(\beta\blacktriangleright\lookbehind\gamma)\xi, a) = \lbrace (doľava\_ \gamma, 0) \rbrace$
-- Lookbehind: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske. Toto je zarážka pre lookbehind -- svoje matchovanie musí skončiť na tejto pozícii tak, že tento znak už neberie do úvahy. Nedeterministicky sa vrátime o niekoľko políčok doľava ($\delta(doľava\_ \gamma, a) = \lbrace(doľava\_ \gamma,-1), (\blacktriangleright\gamma, 0)\rbrace$)  a skúsime matchovať regex v lookbehinde. Keď uspejeme, porovnáme aktuálnu pozíciu so zarážkou. Ak sú rôzne, Turingov stroj sa zasekne. Inak pokračuje vo výpočte ďalej, od tejto pozície: $\delta(\gamma\blacktriangleright\_overene, a) = \lbrace (\beta\lookbehind \gamma)\blacktriangleright\xi, 0) \rbrace $.
\end{list}

\textbf{\underline{Počet adries}}:

Pre \textbf{spätné referencie} potrebujeme vždy 2 adresy -- na začiatok a koniec. Ak sa náhodou budú $k$-te zátvorky opakovať, napr. kvôli Kleeneho $*$, v definícii stojí, že sa vždy berie do úvahy posledný výskyt, takže adresy prepisujeme pri každom opakovaní. V prípade, že sa $k$-te zátvorky nachádzajú vnútri lookaheadu/lookbehindu, tiež máme pre ne rezervované 2 sloty. Algoritmus porovnávania potrebuje 1 ďalšiu adresu -- aktuálnu pracovnú pozíciu. Po jeho dokončení adresu môžeme vymazať (tzn. v ďalšom výpočte prepísať niečím iným).

V prípade \textbf{lookaheadu a lookbehindu} spotrebujeme len 1 adresný slot a to tiež len dočasne -- dokiaľ sa operácia celá nevykoná. Potom je nám tento údaj zbytočný. Tieto operácie však môžu byť vnorené a tak v najhoršom prípade zaberú $p.\log n$ priestoru, ak ich počet je $p$.

Ak máme 1 rezervovaný slot pre aktuálnu adresu, $s$ spätných referencií, $l_a$ lookaheadov a $l_b$ lookbehindov, najviac spotrebujeme $(1+2s+1+l_a+l_b)\log n$ priestoru. Celý regex $\alpha$ je konečne dlhý, teda počet operácií je konečný. Čo znamená, že $m=1+2s+1+l_a+l_b$ je konštanta a to sme chceli dokázať.

\end{proof}


\begin{veta}[Savitch \cite{Savitch}]
Nech $S(n)\geq \log n$ je páskovo konštruovateľná, potom 
$$ NSPACE(S(n)) \subseteq DSPACE(S^2(n)) $$
\end{veta}

\begin{dosledok}\label{le_dspace_log2n}
$\lel \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{dosledok}

Keď už máme deterministický model pre pozitívny lookaround, vieme triedu rozšíriť aj o ten negatívny.
\begin{veta}\label{dspace_log2n}
$\nlel \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
Dôkaz tejto vety uvedieme neskôr. Najprv si zavedieme niekoľko nových pojmov. Keďže sa budeme opierať o dôkaz Savitchovej vety \cite{Savitch_skripta}, bude to akási forma konfigurácií, inšpirovaná definíciou Turingovho stroja.

\subsection{Nový formalizmus}\label{novy_formalizmus}

Nasledujúce definície sa budú týkať zjednodušeného modelu regexov, v ktorom budú prípustné iba základné operácie zreťazenia, alternácie, Kleeneho uzáveru a zložité operácie -- spätné referencie, pozitívny a negatívny lookaround. Ďalej bude obsahovať špeciálne znaky pre ľubovoľný znak . , začiatok slova \textasciicircum~ a koniec slova \$. Inak povedané, nezaujímajú nás tie operácie, ktoré sú len kozmetickou úpravou regexov a dajú sa zapísať pomocou práve spomenutých operácií.

\begin{df}\label{def_konfiguracia}
\textbf{Konfiguráciou} regexu $\alpha = r_1 \dots r_n$ nazývame dvojicu $(r, w)$, kde $r \in (\lceil\alpha)\cup(\alpha\lceil)\cup(r_1 \dots \lceil r_i \dots r_n)$, $w \in \Gamma^*\lceil~ \Gamma^*$ a symbol $\lceil$ ukazuje, kde sa nachádzame vo výpočte v regexe a v slove.

$\Gamma$ je pracovná abeceda obsahujúca poschodové symboly s konečným počtom poschodí a slovo w v najspodnejšom poschodí obsahuje vstupné slovo pre regex $\alpha$.
\end{df}

Teraz si zavedieme pojem indexovateľnosti zátvoriek. Od modelu so spätnými referenciami je zavedené číslovanie zátvoriek a potrebujeme odlíšiť, na ktoré zátvorky je možné sa odkazovať.

Je zakázané odkazovať sa na operácie formy $(?\dots )$, preto ich ani nechceme a nebudeme brať do úvahy v poradí zátvoriek. Z týchto operácií sa v našom modeli nachádza iba pozitívny a negatívny lookaround. Je povolené odkazovať sa na zátvorky vnútri lookaroundu, takže sa vieme odvolať na podslovo, čo sa zhoduje s pozitívnou formou (keďže lookaround považujeme za neindexovateľné zátvorky, stačí ho prepísať do formy $\lookahead (\dots ))$ a vieme sa tak referencovať na jeho obsah). Problém nastáva pri negatívnej verzii -- podľa definície nesmie nájsť žiadnu zhodu, inak sa výpočet zastaví. Preto ľubovoľné jeho zátvorky po akceptácii nedefinujú žiadne podslovo, na ktoré by sme sa mohli odvolať.

Avšak počas výpočtu negatívny lookaround spätné referencie a indexovateľnosť zátvoriek využívať môže. Preto definícia bude závisieť od polohy ukazovateľa v regexe (t.j. od stavu výpočtu) -- bude používať indukciu vzhľadom na počet negatívnych lookaroundov, v ktorých je vnorený.

\begin{df}\label{indexovatelnost_(}
Zátvorka $($ v regexe $\alpha$ je \textbf{indexovateľná}, ak sa bezprostredne za ňou nenachádza metaznak ? a zároveň sa nenachádza vnútri negatívneho lookaroundu.

Nech je ukazovateľ vnorený v 1 negatívnom lookarounde. Potom najprv posúdime vonkajší regex podľa  predošlého kritéria a potom rovnako posudzujeme každú zátvorku ( v regexe vnútri tohto negatívneho look\-aroundu, tak ako keby to bol samostatný regex.

Nech je ukazovateľ vnorený v $k$ negatívnych lookaroundoch a predpokladajme, že máme určené indexovateľné zátvorky v $k-1$ vonkajších negatívnych lookaroundoch. Indexovateľnosť zátvoriek najvnútornejšieho negatívneho lookaroundu posúdime podľa horeuvedeného kritéria ako keby bol jeho regex samostatným regexom.
\end{df}

Jednoducho povedané, indexujeme zátvorky hlavného regexu a regexov vo všetkých negatívnych lookaroundoch, v ktorých sme práve vnorení (vo výpočte).

\begin{df}\label{indexovatelnost_)}
Zátvorka $)$ v regexe $\alpha$ je \textbf{indexovateľná}, ak k nej prislúchajúca otváracia zátvorka je indexovateľná.
\end{df}

\begin{df}
Nech regex $\alpha \in \nle$ obsahuje alternáciu. Potom jeho pod\-slovo $\beta$ nazývame \textbf{alternovateľným}, ak je validným regexom z $\nle$ a zároveň zodpovedá jednej z týchto podmienok:
\begin{enumerate}[(i)]
\item \textbf{prvý} \\ $\beta$ je prefix $\alpha$ alebo znak pred $\beta$ je ( \footnote{Z podmienky hovoriacej, že $\beta$ musí byť validný regex, vyplýva, že prislúchajúca ) sa bude nachádzať až za metaznakom |} 
\\ $\wedge$ za $\beta$ nasleduje metaznak |
\item \textbf{stredný} \\ znak pred $\beta$ je | \\ $\wedge$ $\beta$ je dobre uzátvorkovaný výraz \\ $\wedge$ za $\beta$ nasleduje |
\item \textbf{posledný} \\ znak pred $\beta$ je | \\
$\wedge$ $\beta$ je sufix $\alpha$ alebo za $\beta$ nasleduje ) \footnote{To isté ako pri podmienke $(i)$ -- prislúchajúca '(' sa musí nachádzať pred metaznakom | (susediacim s $\beta$)}
\end{enumerate}
\end{df}

\begin{lema}
Alternácia používa iba alternovateľné regexy.
\end{lema}
\begin{proof}
Ukážeme indukciou na počet alternácií v regexe.

Majme regex $\alpha \in \nle$, ktorý obsahuje alternáciu. Bez újmy na všeobecnosti nech je to práve 1 alternácia (potenciálne zložená z viacerých metaznakov |). Podľa tabuľky priorít vieme, že alternácia má najnižšiu prioritu. Regex $\alpha$ môže byť v takýchto tvaroch:
\begin{enumerate}
\item $\beta_1|\dots|\beta_n$
\item $\alpha_1(\beta_1|\dots|\beta_n)\alpha_2$
\end{enumerate}
Pre $\alpha_1,\alpha_2,\beta_i\in\nle$ $i\in\lbrace 1,\dots,n\rbrace$. Je zrejmé, že $\beta_1$ spĺňa podmienku prvého alternovateľného regexu, $\beta_i$ pre $i\in\lbrace 2,\dots,n-1\rbrace$ spĺňajú podmienku pre stredný alternovateľný regex a $\beta_n$ spĺňa podmienku pre posledný alternovateľný regex.

Nech platí pre regexy obsahujúce $m-1$ alternácií, že tieto alternácie používajú iba alternovateľné regexy. Zoberme teraz regex $\alpha \in \nle$ obsahujúci $m$ alternácií. Opäť vieme $\alpha$ rozdeliť buď spôsobom 1. alebo 2. na validné regexy z $\nle$. Každý z $\beta_1,\dots,\beta_n,\alpha_1,\alpha_2$ obsahuje najviac $m-1$ alternácií, teda alternácie v týchto regexoch používajú iba alternovateľné regexy. Navyše je zrejmé, že aj regexy $\beta_1,\dots,\beta_n$ majú tvar alternovateľných regexov.
\end{proof}

Na základe definovania pojmu alternovateľnosti vieme jednoznačne určiť, ktoré regexy patria ku ktorej alternácii. Dôležité je, že to vieme naprogramovať do Turingovho stroja -- pre každú alternáciu bude skúmať, či je ohraničená zátvorkami alebo rozdeľuje celý regex na časti (teda či nastáva prípad 1. alebo 2. z dôkazu predchádzajúcej vety). Na základe pojmu indexovateľnosti zase vieme algoritmicky určiť, ktoré zátvorky sú indexovateľné a teda si k nim uchovať pomocnú informáciu a potom im ju zase spätne priradiť.

V nasledujúcej definícii kroku výpočtu budeme používať v konfiguráciách poschodové symboly. Informáciu o tom, aké písmenko na danej pozícii leží, budeme potrebovať neustále -- tá bude aj súčasťou poschodovej varianty písmenka. Špeciálna informácia vo vyšších poschodiach bude patriť k spätným referenciám a pozitívnemu lookaroundu. Už z definície spätných referencií vieme, že informácia o tom, aké podslovo predstavuje $\backslash k$ získame až počas výpočtu na konkrétnom slove. Referencia $\backslash k$ predstavuje posledné podslovo matchované $k$-tymi zátvorkami. Preto informácia o jeho pozícii musí byť súčasťou konfigurácie. Zároveň potrebujeme informáciu o každom lookaheade/look\-behinde -- a to pozíciu v slove, kde začal matchovanie, aby sme sa po jeho vykonaní mohli na túto pozíciu vrátiť. Opäť to je informácia, ktorú získame až pri výpočte na konkrétnom vstupe a preto si ju uchováme do poschodového symbolu.

Každý regex má konečný počet operácií, preto aj poschodí v poschodových symboloch bude konečne veľa. Pre každú dvojicu zátvoriek potrebujeme 2 miesta (začiatok a koniec podslova) a pre každý lookaround 1 miesto.

Poschodové symboly sú veľmi prehľadné, čo sa týka zápisu konfigurácií. Z pohľadu výpočtu nejakého Turingovho stroja však môžu byť veľmi nepraktické. Pokiaľ nepoznáme regex dopredu, je to o to ťažšia interpretácia. Preto vo výpočtoch Turingovho stroja necháme vstup nedotknutý a informáciu pre jednotlivé operácie budeme reprezentovať vo forme adries ukazujúcich na konkrétnu pozíciu v slove.

\begin{df}
\textbf{Krok výpočtu} je relácia $\vdash$ na konfiguráciách definovaná nasledovne (najprv napíšeme, čoho sa jednotlivé kroky týkajú a potom uvedieme formálny zápis):

\begin{enumerate}[I.]
\item Prečítame rovnaké písmenko v regexe aj v slove.
\item V regexe ukazujeme na (, ktorá je $k$-ta indexovateľná. V slove si zaznačíme do poschodového symbolu, že na tejto pozícii začína podslovo ku $k$-tym zátvorkám. V regexe prejdeme za zátvorku.
\\ Pokiaľ za $k$-tymi zátvorkami nasleduje $*$, môžeme sa rozhodnúť ich celé preskočiť (až za $*$). V tom prípade si na poschodový symbol zaznačíme začiatok aj koniec podslova.
\item V regexe ukazujeme na ), ktorá je $k$-ta indexovateľná. V slove si zaznačíme do poschodového symbolu, že znak na tejto pozícii už do podslova ku $k$-tym zátvorkám nepatrí. V regexe prejdeme za zátvorku.
\item Narazili sme na začiatok alternácie (začiatok jej prvého alternovateľného regexu). Musíme si zvoliť jednu z jej možností. Buď budeme plynule pokračovať ďalej a spracovávať prvý alternovateľný regex alebo skočíme na začiatok ľubovoľného ďalšieho alternovateľného regexu z tejto alternácie.
\item V alternácii sme práve dokončili matchovanie jednej z možností -- ukazujeme na metaznak |. Skočíme v regexe za posledný alternovateľný regex.
\item Ukazujeme na Kleeneho $*$, ktorej predchádza písmenko. Máme 2 možnosti. Buď sa rozhodneme pokračovať -- preskočíme v regexe $*$ -- alebo spravíme ďalšiu iteráciu -- skočíme pred písmenko.
\item Ukazujeme na Kleeneho $*$, ktorej predchádzajú $k$-te zátvorky. Možnosti sú rovnaké ako v prípade s písmenkom. Rozdiel je len v tom, ak sa rozhodneme spraviť ďalšiu iteráciu. Potom musíme zmazať predošlý záznam k podslovu ku $k$-tym zátvorkám a zaznačiť si túto pozíciu ako jeho začiatok.
\item Narazili sme na znak spätných referencií $\backslash k$. Do slova si na túto pozíciu umiestníme pomocný ukazovateľ $\intercal$.
\item Stále ukazujeme na $\backslash k$ a v slove už máme umiestnený $\intercal$ a písmenko za ním neobsahuje značku konca podslova ku $k$-tym zátvorkám. Porovnávame písmenká v slove na pozíciách s normálnym a pomocným ukazovateľom. Pokiaľ sa zhodujú, posunieme obe pozície o 1 ďalej.
\item Stále ukazujeme na $\backslash k$, v slove je umiestnený $\intercal$ a ukazuje na písmenko zo značkou konca podslova ku $k$-tym zátvorkám. Odstránime zo slova $\intercal$ a v regexe sa posunieme za $\backslash k$.
\item Narazili sme na pozitívny lookahead. Zaznačíme si do poschodového symbolu v slove, že na tejto pozícii začína a v regexe skočíme do lookaheadu.
\item Skončili sme matchovanie lookaheadu, ukazujeme na jeho ). V slove skočíme na zaznačený začiatok a vymažeme túto značku. V regexe skočíme za ).
\item Narazili sme na pozitívny lookbehind. Zaznačíme si do poschodového symbolu v slove, že na tejto pozícii začína. V slove skočíme o niekoľko symbolov nazad (ľubovoľná pozícia medzi začiatkom slova a súčasnou, vrátane týchto 2) a v regexe skočíme do lookbehindu.
\item Skončili sme matchovanie lookbehindu, ukazujeme na jeho ). Zároveň v slove ukazujeme na jeho zaznačený začiatok. Zmažeme túto značku a v regexe prejdeme za ).
\item Narazili sme na negatívny lookahead. Pokiaľ neexistuje postupnosť konfigurácií taká, že regex v negatívnom lookaheade by matchoval nejaký prefix slova začínajúc od súčasnej pozície v slove, potom môžeme lookahead preskočiť.
\item Narazili sme na negatívny lookbehind. Pokiaľ neexistuje postupnosť konfigurácií taká, že regex v negatívnom lookbehinde by matchoval nejaký sufix slova končiac na súčasnej pozícii v slove, potom môžeme lookahead preskočiť.

\end{enumerate}

Formálny zápis:
\begin{enumerate}[I.]\label{dfkonfig}
\item $\forall a \in \Sigma: ~(r_1 \dots \lceil a \dots r_n, w_1 \dots \lceil a \dots w_m) \vdash (r_1 \dots a\lceil \dots r_n, w_1 \dots a \lceil \dots w_m)$
\item Nech ( je indexovateľná, $k$-ta v poradí: $\displaystyle{ (r_1 \dots \lceil ( \dots r_n, w_1 \dots \lceil w_j \dots w_m)}$ $$(1) \vdash (r_1 \dots (\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^k \dots w_m)$$
Ak za jej uzatváracou zátvorkou nasleduje $*$, t.j. $\alpha$ je tvaru $r_1 \dots \lceil ( \dots ) * \dots r_n$, potom $$ (2) \vdash (r_1 \dots (\dots )* \lceil \dots r_n, w_1 \dots \lceil \mathop{\mathop{w_j}^k}^{k'} \dots w_m ) $$
\item Nech ) je indexovateľná, $k$-ta v poradí: $$ (r_1 \dots \lceil ) \dots r_n, w_1 \dots \lceil w_j \dots w_m) \vdash (r_1 \dots )\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^{k'} \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie: $(r_1 \dots \lceil \alpha_1 | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$(1) \vdash \textit{ďalší prechod v }\alpha_1$$
$$(2) \vdash (r_1 \dots \alpha_1 | \lceil \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
$$\dots$$
$$(A) \vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \lceil \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie, potom pre všetky možnosti:
\\ $(r_1 \dots \alpha_1 \lceil | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$,
\\ $(r_1 \dots \alpha_1 | \alpha_2 \lceil | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
\\ \dots, \\ $(r_1 \dots \alpha_1 | \alpha_2 | \dots | \alpha_{A-1} \lceil | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$\vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \alpha_{A-1} | \alpha_A \lceil \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item $(r_1\dots a\lceil *\dots r_n, w_1\dots\lceil w_j\dots w_m)$
$$(1) \vdash (r_1\dots a *\lceil\dots r_n, w_1\dots\lceil w_j\dots w_m)$$
$$(2) \vdash (r_1\dots \lceil a *\dots r_n, w_1\dots\lceil w_j\dots w_m)$$
\item $\displaystyle{(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k\lceil * \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)\footnotemark}$
\footnotetext{Podľa definície spätných referencií platí posledné podslovo nájdené regexom v $k$-tych zátvorkách. Pri tejto pracovnej pozícii v regexe je zrejmé, že nejde o prvý prechod cez tieto zátvorky a teda existuje také $a,b$, že $k$ je v slove nad $w_a$ a $k'$ nad $w_b$. Ak nastane prechod (2), pôvodné horné indexy $k, k'$ miznú a pridáva sa $k$ nad $w_j$.}
$$(1) ~\vdash(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k *\lceil \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)$$
$$(2) ~\vdash(r_1 \dots \mathop{(}_k\lceil r_i \dots r_l\mathop{)}_k * \dots r_n, w_1 \dots w_a \dots w_b \dots \lceil \mathop{w_j}^k \dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots\mathop{w_b}^{k'}\dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\ldots\intercal\mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)$$	

\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal w_c \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$, kde $a\leq c < b$ a zároveň $w_c = w_j$\footnote{$w_c$ a $w_j$ môžu byť poschodové symboly, avšak pri tejto rovnosti poschodia ignorujeme -- chceme porovnať iba písmenká v slove, prislúchajúce týmto pozíciám.}
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots w_c\intercal \dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\ldots \intercal  \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots  \backslash k \lceil \dots r_n,w_1\dots\mathop{w_a}^k\dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item Nech $\lookahead \dots$) je $k$-ty pozitívny lookahead v poradí: 
\\ $\displaystyle{(r_1\dots \lceil \lookahead \dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash(r_1\dots \lookahead\lceil\dots) \dots r_n, w_1\dots\lceil \mathop{w_j}^{\mathop{k}^\rightarrow}\dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookaheadu v poradí: 
\\ $\displaystyle{(r_1\dots \lookahead\dots\lceil) \dots r_n, w_1\dots \mathop{w_l}^{\mathop{k}^\rightarrow}\dots\lceil w_j\dots w_m )} $
$$ \vdash(r_1\dots \lookahead\dots)\lceil \dots r_n, w_1\dots \lceil w_l \dots w_j\dots w_m ) $$
\item Nech $\lookbehind\dots)$ je $k$-ty pozitívny lookbehind v poradí, $\forall L\in\lbrace 0,\dots, j-1\rbrace$:
\\ $\displaystyle{(r_1\dots \lceil \lookbehind\dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$
$$ \vdash (r_1\dots \lookbehind\lceil\dots) \dots r_n, w_1\dots\lceil w_{j-L}\dots \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m ) $$
\item Nech ) patrí ku $k$-temu pozitívnemu lookbehindu v poradí:
\\ $\displaystyle{(r_1\dots \lookbehind\dots\lceil) \dots r_n, w_1\dots \lceil \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m )}$
$$ \vdash(r_1\dots \lookbehind\dots)\lceil \dots r_n, w_1 \dots \lceil w_j \dots w_m ) $$
\item Ak $\nexists p \in \lbrace j,\dots,m\rbrace: (\lceil r_k\dots r_l,\lceil w_j\dots w_p) \vdash^* (r_k\dots r_l\lceil, w_j\dots w_p \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookahead r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookahead r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item Ak $\nexists p \in \lbrace 1,\dots,j-1\rbrace: (\lceil r_k\dots r_l,\lceil w_p\dots w_{j-1}) \vdash^* (r_k\dots r_l\lceil, w_p \dots w_{j-1} \lceil)$, potom:
\\$\displaystyle{(r_1\dots\lceil \nlookbehind r_{k}\dots r_{l} ) \dots r_n, w_1\dots \lceil w_j \dots w_m)}$
$$\vdash (r_1\dots \nlookbehind r_{k}\dots r_{l} ) \lceil\dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\end{enumerate}

\end{df}

Prechody XV. a XVI. sa môžu zdať ťažkopádne, ťažko overiteľné. Nie je však šikovný spôsob ako krokmi znázorniť, že sa niečo nedá. Môžeme si to však predstaviť tak, že k~vnútornému regexu máme zostrojený deterministický Turingov stroj, ktorý vie postupovať podľa krokov I. -- XIV. a má obrátenú akceptáciu. Teda ak by chcel akceptovať, zamietne, a ak sa zasekne/zamietne, tak akceptuje.

Táto úvaha nezahŕňa vnorené negatívne lookaroundy. Potrebný Turingov stroj sa však dá zostrojiť aj tak. Keďže každý regex musí byť konečnej dĺžky, nejaký z tých negatívnych lookaroundov musí byť najvnútornejší -- bez vnorených negatívnych look\-aroundov. Práve k nemu vieme zostrojiť vyššie popísaný Turingov stroj. Potom Turingov stroj pre negatívny lookaround, ktorý ho obaľuje bude spúšťať tento Turingov stroj a tak ďalej, vieme zostrojovať Turingove stroje zvnútra von. Pri výpočte sa potom budú navzájom volať zvonka smerom dnu.

\begin{df}
\textbf{Jazyk} generovaný regexom $\alpha$ je množina $$L(\alpha) = \lbrace w~|~platí ~ (\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil) \rbrace$$
\end{df}

\textbf{Poznámka 1.}
Postupnosť konfigurácií $(\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil)$\footnote{Bez ohľadu na to, čo obsahujú vyššie poschodia symbolov vo $w$.} pre daný regex $\alpha$ a slovo $w$ nazývame \textbf{akceptačný výpočet}. Konfiguráciu $(\lceil \alpha,\lceil w)$ nazývame počiatočnou a $(\alpha\lceil,w\lceil)$ akceptačnou konfiguráciou.

\textbf{Poznámka 2.}
Definícia \ref{dfkonfig} je písaná univerzálne pre všetky triedy regexov. Je zrejmé, že ak daná trieda neobsahuje nejakú operáciu, v akceptačných výpočtoch jej regexov sa nebudú nachádzať kroky výpočtu prislúchajúce tejto operácii. Triedy regexov preto budú používať iba tieto body z definície:
\begin{center}
\begin{tabular}{r|l}
$\re$ & I.--VII. \\
$\e$ & I.--X. \\
$\le$ & I.--XIV. \\
$\nle$ & I.--XVI.
\end{tabular}
\end{center}

\begin{lema}\label{dlzka_vypoctu_rw}
Nech $\alpha \in \el$ a $w \in L(\alpha)$. Potom existuje akceptačný výpočet, ktorý má najviac $3\cdot|\alpha|\cdot|w|^2$ konfigurácií.
\end{lema}
\begin{proof}
Pri prechodoch medzi konfiguráciami I., II., III., IV., V., VI.(1), VII.(1), IX., XI., XIV., XV. a XVI. sa ukazovateľ posúva vždy vpred buď v slove alebo v regexe alebo v oboch. Keby sme využívali iba tieto prechody, akceptačný výpočet má najviac $\left\vert{\alpha}\right\vert+|w|$ konfigurácií.

Zostali kroky výpočtu, v ktorých ukazovateľ skáče dozadu alebo zostáva na mieste, rozoberme si ich postupne:

VI.(2),VII.(2) -- v prípade Kleeneho $*$ nastáva ďalšie opakovanie. Keďže $w\in L(\alpha)$, existuje pre $w$ akceptačný výpočet. Takýchto výpočtov môže byť viac, napríklad ak sa v $\alpha$ vyskytuje regex $(\beta)*$ taký, že $\varepsilon \in L(\beta)$. Potom existuje nekonečne veľa výpočtov, ktoré sa líšia v počte prechodov týmto regexom. Z nich si vyberieme najkratší akceptačný výpočet. Vyberme si ľubovoľnú $*$ a sled jej iterácií v nejakom momente výpočtu\footnote{Táto $*$ môže mať viac sledov iterácií, pokiaľ sa nachádza v poli pôsobnosti inej $*$. Ak vonkajšia $*$ vykonáva niekoľko (>1) iterácií, potom vnútorná $*$ je v každej z nich spúšťaná odznova. Teda môže existovať niekoľko jej sledov iterácií.}, nech je ich počet $k$. Pokiaľ $k=0$, potom je to krok II.(2) a ten sme už zarátali. V prípade $k=1$ opať krok VI.(2) ani VII.(2) nenastali. Nech teda $k>1$. Tvrdíme, že každá iterácia v tomto slede okrem poslednej matchovala aspoň 1 písmenko. Ukážeme to sporom. Nech nejaká $i$-ta, $i<k$, matchovala prázdne slovo. Potom však túto operáciu možno vymazať zo sledu, napojiť rovnaké konfigurácie na jej začiatku a konci a máme kratší výpočet, čo je spor. Tvrdenie neplatí pre poslednú iteráciu, pretože pokiaľ je iterovaný regex v zátvorkách, posledná iterácia ovplyvňuje podslovo, ktoré bude vyjadrené spätnými referenciami a jej vymazanie by mohlo pokaziť akceptačný výpočet. Takýto sled využíva $(k-1)$-krát prechod VI.(2) alebo VII.(2), teda prvé písmenko je zadarmo. Zároveň však platíme naviac za 1 návrat v VII.(2), pokiaľ chceme mať posledné slovo $\varepsilon$. Predstavme si preto, že platíme za prvé písmenko a neplatíme za posledný prechod na prázdne slovo -- v takomto prípade získame horný odhad počtu konfigurácií, lebo na záver nemusí byť zakaždým $\varepsilon$ a zároveň podľa tvrdenia prvý prechod musí byť na písmenko.

Odhadnime teraz dĺžku najkratšieho akceptačného výpočtu aj s použitím krokov VI.(2) a VII.(2). Celkovo počet návratov môže byť najviac $|w|$, pretože každá iterácia, za ktorú platíme návratom, musí matchovať aspoň 1 písmenko. Medzi 2 návratmi používame nenávratové kroky, ktorých je najviac $|w|+|\alpha|$. Preto akceptačný výpočet obsahujúci doteraz spomenuté kroky výpočtu bude mať najviac $|w|\cdot(|w|+|\alpha|)$ konfigurácií.

VIII., X. -- prechody, pri ktorých sa žiaden ukazovateľ nepohne. Tieto prechody nastávajú pri spätných referenciách a jedná sa o objavenie sa alebo zmiznutie pomocného ukazovateľa. Počet spätných referencií je najviac $|\alpha|$ a každá z nich sa môže nachádzať v poli pôsobnosti nejakej $*$, preto je vykonávaná najviac toľkokrát, koľko môže byť iterácií. Odhadli sme, že všetky $*$ na celom slove spravia najviac $|w|$ opakovaní. Preto kroky VIII. a X. nastanú najviac ($|\alpha|\cdot|w|$)--krát.

Z toho vyplýva, že pre regex $|\alpha|$ a slovo $w$ existuje akceptačný výpočet, ktorý obsahuje najviac $|w|\cdot(|w|+|\alpha|)+|w|\cdot|\alpha| \leq 3\cdot |w|^2 \cdot |\alpha| $ konfigurácií.
\end{proof}

Spočítajme počet všetkých konfigurácií pre triedu regexov $\le$. Vstupné slovo a regex máme, menia sa iba polohy ukazovateľov a informácií. Ukazovateľ v regexe môže mať $(r+1)$ pozícií a pre ukazovateľ v slove existuje $(w+1)$ rôznych pozícií. Čo sa týka ukazovateľa pre spätné referencie a informácií v poschodových symboloch, každý prvok z tejto množiny môže mať $(w+1)$ pozícií alebo sa v slove nenachádzať. Mohutnosť tejto množiny je $m = 1+2\cdot(\text{počet spätných ref.})+(\text{počet lookaroundov})\leq 2r+1$. Počet všetkých možných konfigurácií je dohromady: 
\begin{equation}\label{pocet_vsetkych_konfig}
(r+1)(w+1)(w+2)^m \leq (r+1)(w+2)^{2r+2} = O(rw^{2r+2})
\end{equation}

Keby sme priamo pokračovali v dôkaze lemy \ref{dlzka_vypoctu_rw}, odhad by nebol lepší ako \ref{pocet_vsetkych_konfig}. Nasledujúca lema to ukazuje všeobecnejšie.

Definujme si \textbf{hĺbku vnorenia lookaroundov} ako počet lookaroundov vnorených v sebe. Lookaround obsahujúci regex z $\e$ má hĺbku 1. Lookaround obsahujúci regex z $\le$, kde maximum zo všetkých hĺbok lookaroundov je $h-1$ má hĺbku $h$.

\begin{lema}\label{lema_hlbka_lookaroundov}
Majme triedu regexov takú, že funkcia $f(r)$ určuje ich maximálnu hĺbku vnorenia lookaroudov, kde $r$ je dĺžka regexu. Potom počet konfigurácií v akceptačnom výpočte pre slovo dĺžky $w$ je najviac $O(rw^2(rw)^{f(r)})$.
\end{lema}
\begin{proof}
Dokážeme si to matematickou indukciou vzhľadom na hĺbku vnorenia lookaroundov $h$.

Báza indukcie: Nech $h=1$. V regexe je $k\leq r$ lookaroundov, ktoré vnútri nemajú žiaden lookaround. Keďže lookaroundu nie sú priradené žiadne písmenká zo vstupu, môžeme ho brať ako samostatný regex, ktorý v najhoršom prípade matchuje celé $w$. Vnútri každého lookaroundu je regex z $\e$, pre ktorý podľa lemy \ref{dlzka_vypoctu_rw} existuje akceptačný výpočet s najviac $3rw^2$ konfiguráciami. Mimo všetkých lookaroundov je tiež regex, pre ktorý platí táto lema. V najhoršom prípade sa lookaround nachádza vnútri regexu, ktorý je iterovaný $*$ a môže byť spustený najviac $w$-krát. Každý lookaround teda pridá najviac $3rw^3$ konfigurácií. Spolu $3rw^2+r\cdot 3rw^3 = O(r^2w^3) = O(rw^2(rw)^1)$. 

Indukčný krok: Nech tvrdenie platí pre $h-1$, ukážeme, že platí pre $h$. Regex obsahuje $k\leq r$ lookaroundov s hĺbkou vnorenia najviac $h$. Zoberme si ľubovoľný z týchto lookaroundov. Jeho vnútorný regex obsahuje lookaroundy s hĺbkou vnorenia najviac $h-1$ a podľa indukčného predpokladu takýto regex pridáva $O(rw^2(rw)^{h-1})$ konfigurácií. Pozrime sa teraz na celý regex. Keď ignorujeme lookaroundy, akcetačný výpočet má $3rw^2$ konfigurácií. Každý lookaround pridá $O(rw^2(rw)^{h-1})$ konfigurácií a môže byť spustený najviac $w$-krát, pokiaľ sa nachádza v poli pôsobnosti nejakej $*$. Lookaroundov je najviac $r$, teda dohromady má akceptačný výpočet najviac $3rw^2+rw\cdot O(rw^2(rw)^{h-1}) = O(rw^2(rw)^h)$ konfigurácií, čo sme chceli dokázať.
\end{proof}

Pre triedu $\le$ je hĺbka vnorenia lookaroundov maximálne dĺžka regexu -- $f(r)=r$, teda akceptačný výpočet môže mať najviac $O(rw^2(rw)^r) = O(r^rw^{r+2})$ konfigurácií. Tento odhad je veľmi podobný odhadu \ref{pocet_vsetkych_konfig}. Druhý extrém je trieda regexov, ktorej lookaroundy majú hĺbku vnorenia konštantnú, teda $f(r)=O(1)$. V takom prípade má akceptačný výpočet najviac $O(rw^2(rw)^{O(1)})$ konfigurácií.

\subsection{Regex a slovo na vstupe}

V praxi často regex dopredu nepoznáme. Vstupným údajom je text na vyhľadávanie a rovnako aj regex, ktorý znázorňuje požiadavku na vyhľadávanie. Tento problém predstavuje jazyk $$L(regex\#word) = \lbrace word~|~word \in L(regex) \wedge regex \in \cal U \rbrace$$
kde ${\cal U}$ musí byť konkrétna trieda regexov (napríklad jedna z $\re$, $\e$, $\le$, $\nle$).

\begin{veta}
$L(regex\#word) \in NSPACE(n \log n)$, kde $regex \in \le$. 
\\ (Presnejšie $NSPACE(r \log w)$, kde $r = |regex|$ a $w = |word|$.)
\end{veta}
\begin{proof}
Zostrojíme nedeterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na pracovných páskach zapíše najviac $O(r\log w)$ políčok. M bude mať vstupnú read-only pásku a 4 pracovné pásky.

Na prvú pracovnú pásku si M na začiatku prekopíruje celý regex a na tejto kópii bude pracovať. Na druhej páske bude uchovávať informáciu z poschodových symbolov. Na tretej páske si bude počítať aktuálnu pozíciu na vstupe v časti slova $word$ (je ohraničené zľava \# a sprava endmarkerom) a štvrtá páska bude pomocná pri procedúrach, ktoré spomenieme neskôr.

Informácia z poschodových symbolov bude zapísaná vo forme niekoľkých adries -- pracovná pozícia (= ukazovateľ) v slove, ukazovateľ pre spätné referencie, začiatok a koniec podslova pre $k$-te zátvorky $\forall k$, začiatok lookaheadu, začiatok lookbehindu. Všetky adresy budú oddelené oddeľovačmi. Na začiatku výpočtu Turingov stroj M prejde cez regex a spočíta, koľko adries potrebuje. Podľa toho si na pásku zapíše potrebný počet oddeľovačov. Ukazovateľ v slove nastaví na prvý symbol, ostatné adresy budú nedefinované. Hlava na vstupnej páske bude väčšinu času zodpovedať pozícii ukazovateľa v slove. Adresu na túto pozíciu bude M potrebovať, keď pribudne ukazovateľ pre spätené referencie a v slove tak budú ukazovatele 2.

Informácia zapísaná na páskach zodpovedá počiatočnej konfigurácii pre regex $regex$ a slovo $word$. M bude postupovať podľa krokov výpočtu z definície \ref{dfkonfig}. Vždy si jeden nedeterministicky zvolí. Ak sa dá vykoná ho, inak sa zasekne. Pokiaľ má definovaný ukazovateľ pre spätné referencie, M je povinný pracovať s ním. Pri overovaní podmienok a vykonávaní krokov výpočtu bude M vykonávať nasledovné úkony:
\begin{enumerate}
\item indexovateľnosť zátvorky ( -- overenie, či vedľajší znak je ?
\item odpočítanie adresy pre $k$-tu zátvorku -- záznam o tom, za ktorou zátvorkou sa v regexe nachádzame, si môžeme uchovávať na 4. pracovnej páske. Adresa na začiatok podslova pre $k$-te zátvorky je $(2k+1)$-vá v poradí, na koniec podslova ukazuje adresa hneď za ňou.
\item nájdenie prislúchajúcej zátvorky -- medzi zátvorkami musí byť dobre uzátvorkovaný výraz, teda počítame +1 za každú '(' a -1 za každú ')' \footnote{Ak počíta sprava doľava, hodnoty prenásobíme -1, aby sme nedostali na začiatku súčet -1.}
\item indexovateľnosť zátvorky ) -- nájdenie prislúchajúcej ( a overenie jej indexovateľnosti
\item overenie alternovateľnosti -- na jednom konci má metaznak | a na druhom buď metaznak | alebo '(' prípadne ')' (algoritmus z kroku 3.) alebo siaha až do konca slova
\item skok ukazovateľa o konštantný počet krokov -- stačí počítadlo v stave
\item priradenie spätnej referencie k zátvorkám -- zapísané číslo z $\backslash k$ si M skopíruje na 4. pomocnú pásku a odpočíta si adresu pre $k$-te zátvorky podľa kroku 2.
\item pridanie ukazovateľa pre spätné referencie = kopírovanie adresy
\item práca s 2 ukazovateľmi v slove -- písmenká zisťuje 1 prechodom slova a podľa nich upravuje ukazovatele
\item porovnávanie adries -- napr. kopírovaním 1 z nich na 4. pracovnú pásku
\end{enumerate}
Podľa popísaných úkonov máme na 4. pracovnej páske zapísaných najviac $O(\log r + \log w)$ políčok. Na 3. páske je adresa s aktuálnou pozíciou v slove zaberajúca $\log w$ políčok. Na 1. páske je regex dĺžky $r$. Počet spätných referencií ($s$), lookaheadov ($l_a$) a lookbehindov ($l_b$) je najviac $r$, preto na 2. páske je $2+2s+l_a+l_b\leq 2r+2$ adries, čo je najviac $(2r+2)\log w = O(r \log w)$ zapísanej pamäte a je to viac ako na zvyšných páskach. Celkovo tak M zapíše najviac $O(r \log w) = O(r \log w) = O(n\log n)$ pamäte.
\end{proof}

Dôsledkom Savitchovej vety získavame:
\begin{veta}
$L(regex\#word) \in DSPACE(n^2 \log^2 n)$, kde $regex \in \le$. 
\end{veta}

Opäť pre niektoré triedy vieme dokázať lepší výsledok. Upravíme dôkaz Savitchovej vety tak, aby používal kratšie konfigurácie -- namiesto konfigurácií Turingovho stroja použijeme konfigurácie z nového formalizmu, ktoré reprezentujú výpočet regexu na slove. Keďže regex aj slovo máme na vstupe, v skutočnosti nám stačí pamätať si v~oboch pracovné pozície, na to potrebujeme $O(\log r + \log w)$ políčok, a informáciu z poschodových symbolov -- tú si vieme tiež zaznamenať vo forme adries reprezentujúcich pozíciu v slove. Preto celá konfigurácia bude zaberať $O(r\log w)$ políčok. Z odhadov o dĺžke naj\-krat\-šie\-ho akceptačného výpočtu získame odhad na hĺbku rekurzie testovacej funkcie. Pokiaľ budeme mať zaručené, že dĺžka akceptačného výpočtu je najviac polynomiálna od dĺžky regexu a slova, budeme potrebovať dokopy $O(n\log^2 n)$ políčok.

\begin{veta}\label{dspace_nlog2n}
$L(regex\#word) \in DSPACE(n \log^2 n)$, kde $regex \in \e$.
\end{veta}
\begin{proof}
Pre účely dôkazu budeme označovať $w = |word|$ a $r = |regex|$, teda $w+r=n$.

Zostrojíme deterministický Turingov stroj M, ktorý bude akceptovať jazyk $L(regex\#word)$ a na každej pracovnej páske použije najviac $O(n\log^2 n)$ políčok. M bude mať vstupnú read-only pásku a 2 pracovné pásky.

Myšlienka je podobná dôkazu Savitchovej vety \cite{Savitch_skripta} -- M bude vykonávať funkciu $TESTUJ(C_1,C_2,i)$, ktorá zistí, či sa vieme dostať z konfigurácie $C_1$ do konfigurácie $C_2$ na $i$ krokov. 

Podľa lemy \ref{dlzka_vypoctu_rw} vieme, že ak existuje akceptačný výpočet pre $w$, potom existuje aj akceptačný výpočet taký, ktorý má najviac $3rw^2$ konfigurácií. Na základe tohto výsledku bude M zisťovať, či sa z počiatočnej konfigurácie $C_0$ vieme dostať do akceptačnej konfigurácie $C_a$ na $3rw^2$ krokov -- $TESTUJ(C_0,C_a,3rw^2)$.

Pseudokód procedúry $TESTUJ$:
\lstset{numbers=left, tabsize=4, morekeywords={if,then,return,true,false}}
\begin{lstlisting}[mathescape]
bool $TESTUJ(C_1,C_2,i)$
	if ($C_1 == C_2$) then return true
	if ($i>0 ~\wedge~ C_1\vdash C_2$) then return true
	if ($i<=1$) return false
	iteruj cez vsetky konfiguracie $C_3$
		if ($TESTUJ(C_1, C_3,\lfloor \frac{i}{2}\rfloor) ~\wedge ~TESTUJ(C_3, C_2,\lceil \frac{i}{2}\rceil)$) then return true
	return false
\end{lstlisting}

Pre podrobnejší popis pseudokódu je nutné, aby sme najprv definovali tvar konfigurácie. Použijeme zápis z definície \ref{dfkonfig}, v tvare $(a_1\dots \lceil a_i \dots a_r, b_1 \dots\lceil b_j \dots b_w)$ respektíve $(a_1\dots \lceil a_i \dots a_r, b_1 \ldots \intercal b_l \dots \lceil b_j \dots b_w)$, kde $a_1\dots a_r = regex$ a $b_1\dots b_w = word$. Reprezentovať ich budeme vo forme 2 resp. 3 adries -- pracovná pozícia v regexe ($i$), pracovná pozícia v slove ($j$) a adresa k spätnej referencii ($l$). Namiesto poschodových symbolov si M bude pre každú konfiguráciu pamätať informáciu, ktoré zátvorky zodpovedajú ktorému podslovu slova $word$. Pre každé zátvorky si uloží 2 adresy -- začiatok podslova a 1 políčko za koncom podslova (použijeme polootvorený interval $\langle za\v{c},kon)$). Pre každý lookahead a každý lookbehind bude mať vyhradené 1 adresné miesto aby si zapamätal, kam do slova ukazoval, keď naňho narazil.

Popis pseudokódu:
\begin{description}
\item[riadok 2] Ak $C_1=C_2$, potom vieme prejsť z $C_1$ do $C_2$ na ľubovoľný počet krokov.
\item[riadok 3] Platí $C_1 \neq C_2$. Ak $i=0$, nevieme prejsť do žiadnej inej konfigurácie ako $C_1$, teda vrátime \textbf{false}. Nech $i>0$. Skontrolujeme podľa definície \ref{dfkonfig}, či platí $C_1 \vdash C_2$. Konfigurácie sú uložené na páske ako $m$-tice, kde $m = 3+2\cdot (\text{počet zátvoriek})+(\text{počet lookaheadov})+(\text{počet lookbehindov})$: $C_1 = (d_1,\dots, d_m)$, $C_2=(e_1,\dots,e_m)$. Nech $d_1, e_1$ sú pracovné pozície v regexe, $d_2,e_2$ sú pracovné pozície v slove a $d_3,e_3$ pracovné pozície ukazovateľa pre spätné referencie, pričom $d_3,e_3$ môžu byť nedefinované (na prislúchajúcom mieste medzi oddeľovačmi adries nebude nič zapísané). TS M overí, či je splnená nejaká z týchto podmienok (rímske čísla zodpovedajú tým v definícii \ref{dfkonfig}):
\begin{enumerate}[I.]
\item $regex[d_1]=word[d_2]~\wedge~(e_1,\dots,e_m) = (d_1+1,d_2+1,nedef,d_4, \dots, d_m)$
\item (1) $regex[d_1]=$'('$ \\ ~\wedge~regex[d_1]$ je indexovateľná 
\\ $\wedge$ nech $d_k$ prislúcha k $regex[d_1]$, $4\leq k \leq m$: $e_k=d_2$ (sedí začiatok podslova) 
\\ $ \wedge ~(e_1,\dots, e_m) = (d_1+1,d_2,nedef,d_4,\dots,d_{k-1},d_2,d_{k+1},\dots,d_m)$
\setcounter{enumi}{1}
\item (2) $regex[d_1]=$'('$ \\ \wedge$ 2 políčka pred pozíciou $e_2$ je v regexe '$)*$' $ 
\\ \wedge$ zátvorky $regex[d_1]$ a $regex[e_1-2]$ sú k sebe prislúchajúce\footnote{To M skontroluje tak, že si overí, že medzi nimi ku každej '(' existuje ')' -- teda počet výskytov '(' a ')' musí byť rovnaký.} 
\\ $\wedge$ nech $d_k$ prislúcha k $regex[d_1],~4\leq k\leq m$: $e_k=e_{k+1}=d_2$ (začiatok a koniec podslova je nastavený na to isté políčko)
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+l, d_2,nedef,d_4,\dots,d_{k-1},e_k,e_{k+1},d_{k+2},\dots,d_m)$ pre $l\in\nobreak\N$
\item podobne ako II.(1) -- kontrola, či sedí koniec podslova
\item $regex[e_1-1] =$'|' \\ $\wedge$ regex medzi $d_1$ a najbližším metaznakom | je alternovateľný \\ $\wedge$ všetky regexy ohraničené | medzi $d_1$ a $e_1$ sú alternovateľné 
\\ $\wedge~ (e_1,\dots, e_m)=(d_1+l,d_2,nedef,d_4,\dots,d_m)$ pre $l\in\N$
\item $regex[d_1] =$'$|$'
\\ $\wedge$ všetky regexy ohraničené $|$ medzi $d_1$ a $e_1$ sú alternovateľné
\\ $\wedge$ regex medzi $e_1$ a najbližším metaznakom $|$ naľavo od neho je alternovateľný
\\ $\wedge~ (e_1,\dots, e_m)=(d_1+l,d_2,nedef,d_4,\dots,d_m)$ pre $l\in\N$
\item (1) $regex[d_1]=$'$*$'$~\wedge~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{5}
\item (2) $regex[d_1]=$'$*$'
\\ $\wedge~ regex[d_1-1]=a,~a\in\Sigma$
\\ $\wedge~(e_1,\dots,e_m)=(d_1-1,d_2,nedef,d_4,\dots,d_m)$
\item (1) $regex[d_1]=$'$*$'$~\wedge~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_m)$
\setcounter{enumi}{6}
\item (2) $regex[d_1]=$'$*$'$ \\ \wedge~regex[e_1-1]=$'(' a prislúcha k $regex[d_1]$ 
\\ $\wedge$ nech $d_k,d_{k+1}$ prislúchajú k týmto zátvorkám, potom $e_k=d_2$, $e_{k+1}=\nobreak nedef$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1-l,d_2,nedef,d_4,\dots,d_{k-1},e_k,e_{k+1},d_{k+2},\dots, d_m)$ pre $l\in\nobreak\N$
\item $regex[d_1] =$'$\backslash$' 
\\ $\wedge$ nasleduje číslo $k$, $0\leq k \leq$ (počet indexovateľných zátvoriek) 
\\ $\wedge ~ (e_1,\dots,e_m)= (d_1,d_2,d_{2k+2},d_4,\dots,d_m)$ ($d_{2k+2}$ je adresa začiatku podslova prislúchajúca ku $k$-tym zátvorkám)
\item na pozícii $d_1$ je podslovo '$\backslash k$'
\\ $\wedge$ podobne ako I.-- musí platiť $d_3<d_{2k+3}$ a správne sa posunú adresy $d_2,d_3$
\item na pozícii $d_1$ je podslovo '$\backslash k$' 
\\ $\wedge ~ d_3=d_{2k+3}$ 
\\ $\wedge ~(e_1,\dots, e_m)=(d_1,d_2,nedef,d_4,\dots,d_m)$
\item na pozícii $d_1$ je podslovo '$\lookahead$' 
\\ $\wedge$ nech $d_l$ adresa prislúchajúca k tomuto lookaheadu: $e_l=d_2$, teda 
\\ $(e_1,\dots,e_m)=(d_1+3,d_2,nedef,d_4,\dots,d_{l-1},d_2,d_{l+1},\dots,d_m)$
\item $regex[d_1]=$')' a prislúcha lookaheadu, ktorému patrí adresa $d_l$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+1,d_l,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\item na pozícii $d_1$ je podslovo '$\lookbehind$' 
\\ $\wedge$ nech $d_l$ adresa prislúchajúca k tomuto lookbehindu: $e_l=d_2$ 
\\ $\wedge ~(e_1,\dots,e_m)=(d_1+3,d_2-l,nedef,d_4,\dots,d_{l-1},d_2,d_{l+1},\dots,d_m)$, kde $l\in\N$
\item $regex[d_1]=$')' a prislúcha lookbehindu, ktorému patrí adresa $d_l$ \\ $\wedge ~ d_2=d_l \\ \wedge ~(e_1,\dots,e_m)=(d_1+1,d_2,nedef,d_4,\dots,d_{l-1},nedef,d_{l+1},\dots,d_m)$
\end{enumerate}
Keďže regex neobsahuje negatívny lookbaround, ďalšie riadky z definície netestujeme.
\item[riadok 4] Po predošlých riadkoch platí $C_1\neq C_2 \wedge C_1 \nvdash C_2$. Ak zároveň $i<=1$, potom sa z $C_1$ do $C_2$ na $i$ krokov dostať nedokážeme. $TESTUJ$ vráti \textbf{false}.
\item[riadok 5] M začne iterovať cez všetky možné konfigurácie -- t.j. všetky možné kombinácie adries z množiny $\lbrace 1,\dots,d\rbrace$, kde $d=\lceil\log(r+1)\rceil$ pre $d_1$ a $d=\lceil\log(w+1)\rceil$ pre ostatné adresy. Vygenerované $C_3$ bude mať M uložené ako lokálnu premennú.
\item[riadok 6] M testuje, či je $C_3$ vo výpočte v strede medzi $C_1$ a $C_2$. Ak obe volané procedúry vrátia \textbf{true}, vrátime \textbf{true}. Inak sa M vráti na \textbf{riadok 5} a vygeneruje ďalšie $C_3$.
\item[riadok 7] Neexistuje vhodná konfigurácia $C_3$, teda sa nevieme dostať z $C_1$ do $C_2$ na $i$ krokov. Vrátime \textbf{false}.
\end{description}

Podľa vyššie špecifikovaných $m$-tíc pre konfigurácie bude úvodné nastavenie nasledovné: 
$$C_0=(~~~~~~~~~~~0,~~~~~~~~~~~~0,nedef,nedef,\dots,nedef,nedef,\dots,nedef)$$
$$C_a=(\log(r+1),\log(w+1),nedef,\underbrace{~~~~~a_1,\dots,~~~~a_{2s}}_{\substack{\text{adresy pre}\\\text{spätné}\\\text{ referencie}}},\underbrace{~~~~~b_1,\dots,~b_{l_a+l_b}}_{\substack{\text{adresy pre}\\\text{lookahead a lookbehind}}})$$
Akceptačná konfigurácia môže mať veľa možností nastavenia adries $a_1,\dots,a_{2s},b_1,\dots,\allowbreak b_{l_a+l_b}$ a M nevie, ktoré z nich je to správne. Preto bude spúšťať procedúru $TESTUJ$ pre všetky možné akceptačné konfigurácie. Akonáhle 1 výpočet vráti \textbf{true}, M akceptuje. Ak všetky vrátia \textbf{false}, M zamietne. Skúšanie všetkých možných adries pre M znamená iterovanie od $(0,0,\dots,0)$ do $(\lceil\log( w+1)\rceil,\dots,\lceil\log( w+1)\rceil)$, pričom 0 znamená \textit{nedef}.


Turingov stroj M rekurzívne volá procedúru $TESTUJ$. Preto na prvej páske bude mať zásobník, kde budú uložené záznamy o jednotlivých volaniach. Druhá páska je pomocná pri vykonávaní konkrétneho volania -- M potrebuje konštantný počet adries, aby mohol realizovať porovnávanie (overovanie rovnosti konfigurácií a adries, overovanie konkrétneho rozdielu medzi adresami), zisťovanie príslušnosti zátvoriek (t.j. ktorá je druhá zátvorka k tejto -- treba počítať zátvorky (,)), zisťovanie poradia zátvorky/lookaheadu/lookbehindu a prislúchajúcej adresy, kontrolu alternovateľnosti (to je v podstate počítanie zátvoriek), čítanie čísla $k$ za metaznakom $\backslash$ a hľadanie adries pre $k$-te zátvorky, \dots

Zrejme ak existuje akceptačný výpočet, M ho nájde. Treba ukázať, že sa pri tom na každej páske zmestí do pamäte $O(n\log^2 n)$. Podľa predchádzajúceho odstavca vieme, že na druhej (pomocnej) páske potrebuje $O(\log n)$ políčok, čo spĺňa podmienku. Spočítajme veľkosť pamäte potrebnú na zapísanie zásobníka.

Adresy vieme zapísať v logaritmickom priestore závislom od dĺžky slova, kam ukazujú. Pre regex to bude $\log r$ a pre slovo $\log w$, pretože vieme adresovať od oddeľovača \#. Číslo $i$ je najviac $3rw^2$ a tiež ho vieme zapísať v logaritmickom tvare, čo zaberie $\log (3rw^2) = \log 3 + \log r + 2\log w$ políčok. Platí $r\leq n, w\leq n$, lebo $r+w+1=n$.

Počet zátvoriek, lookaheadov a lookbehindov je v regexe dokopy najviac $r$, teda jedna konfigurácia bude potrebovať najviac $\log r + 2\log w + 2r\log w$ priestoru.

Jeden záznam procedúry $TESTUJ$ obsahuje 3 konfigurácie a číslo $i$, čo spolu zaberá $\log 3+\log r + 2\log w + 3\log r + 6\log w + 6r\log w = O(r\log w) = O(n\log n)$ priestoru.

Počet záznamov v zásobníku závisí od hĺbky rekurzie. Keďže začíname na hodnote $i=3rw^2$ a pri každom volaní je $i$ zmenšené na polovicu, hĺbka vnorenia bude $\log(3rw^2)=O(\log n^3) = O(3\log n) = O(\log n)$.

Celkovo M na zásobníkovej páske zapíše $O(\log n)\cdot O(n\log n) = O(n\log^2 n)$ priestoru.
\end{proof}

\begin{dosledok}
Nech $\cal U$ je trieda regexov, pre ktoré platí, že počet konfigurácií v~akceptačnom výpočte pre regex $\alpha$ a slovo $w$ je najviac $f(n)$, kde $n=|\alpha|+|w|+1$. Potom $L(regex\#word)\in NSPACE(n\cdot\log n\cdot \log (f(n)))$, kde $regex \in \cal U$.
\end{dosledok}
\begin{proof}
Vyplýva z dôkazu vety \ref{dspace_nlog2n} -- hĺbka vnorenia funkcie $TESTUJ$ je logaritmus z horného ohraničenia dĺžky akceptačného výpočtu.
\end{proof}

\begin{dosledok}
Trieda regexov s hĺbkou vnorenia lookaroundov zhora ohraničenou konštantou $h$ patrí do $DSPACE(n\log^2 n)$.
\end{dosledok}
\begin{proof}
Podľa lemy \ref{lema_hlbka_lookaroundov} je počet konfigurácií v akceptačnom výpočte najviac $O((rw)^h)$. Potom hĺbka rekurzie funkcie $TESTUJ$ je $\log((rw)^h) = h\log r + h\log w = O(\log r+\log w)$, čo je ten istý odhad ako v dôkaze vety \ref{dspace_nlog2n}.
\end{proof}

Teraz nasleduje sľúbený dôkaz vety \ref{dspace_log2n}. Použijeme dôkaz predošlej vety a využijeme to, že regex poznáme dopredu -- v takom prípade je jeho dĺžka konštantná, vieme počty jeho operácií a preto sa dá jeho konfigurácia ešte viac skrátiť tak, že adresy zaznačíme do niekoľkých stôp nad sebou, takže zaberá $O(\log n)$ priestoru. Vďaka konštantnej dĺžke regexu sa dá dĺžka akceptačného výpočtu odhadnúť polynómom od dĺžky vstupného slova.

Oproti predošlej vete pribudli aj nové operácie, ktoré je treba zahrnúť do konštrukcie. Pre negatívny lookaround je nutné zistiť, či do neho dané podslovo nepatrí. To urobíme tak, že vezmeme jeho vnútorný regex a spustíme na ňom výpočet na ďalšej páske, ako keby toto bol náš vstupný regex. Jeho výpočet bude ohraničený na nejakom podslove vstupu a niekedy ho bude treba spúšťať viackrát pre rôzne podslová. Pokiaľ pre všetky prípady dostaneme odpoveď, že výpočet neexistuje, negatívny lookaround akceptuje. Treba si uvedomiť, že spúšťanie výpočtu negatívneho lookaroundu nie je úplne separované od zvyšku, nakoľko môže obsahovať spätné referencie odkazujúce sa mimo neho. Takisto môže nastať situácia, kedy sa nachádza niekoľko negatívnych lookaroundov v sebe. Potom je nutné dodržiavať pravidlá indexovateľnosti zátvoriek podľa definícií \ref{indexovatelnost_(} a \ref{indexovatelnost_)}. Tiež je treba správne určovať, ktoré podslová sú správnym vstupom a nedovoliť výpočtu prekročiť tieto hranice.

\begin{proof}
Nech $\alpha\in\nle$, $r=|\alpha|$. Ak $\alpha$ neobsahuje negatívny lookaround, tvrdenie triviálne vyplýva z vety \ref{le_dspace_log2n}. Nech teda $\alpha$ obsahuje aspoň 1 negatívny lookaround a označíme si $k$ ako najväčšiu hĺbku vnorenia negatívnych lookaroundov v regexe $\alpha$.

Zostrojíme deterministický Turingov stroj T, ktorý bude akceptovať $L(\alpha)$ a na páskach zapíše najviac $O(\log^2 n)$ políčok. Konštrukcia T bude podobná ako v dôkaze vety \ref{dspace_nlog2n} -- iný bude zápis konfigurácií a pridáme spracovávanie negatívneho lookaroundu.

Keďže regex poznáme dopredu, vieme si definovať špeciálny znak pre regex s každou možnou polohou ukazovateľa (to je $(r+1)$ nových znakov). Takisto vieme počet spätných referencií $s$, lookaheadov $l_a$ a lookbehindov $l_b$, preto si vieme zapísať k nim prislúchajúce informácie nad seba do niekoľkých stôp na páske -- konkrétne potrebujeme $2s+l_a+l_b$ stôp. K nim pridáme ešte 2 ďalšie stopy -- pre ukazovateľ v slove a ukazovateľ pre spätné referencie -- a 1 stopu, kde na 1 políčku bude napísaný špeciálny znak obsahujúci informáciu o polohe ukazovateľa v regexe. Na $2s+l_a+l_b+2$ stopách sú adresy ukazujúce pozíciu na vstupe, teda informácia zaberajúca $\log n$ políčok a na 1 stope bude zapísané 1 políčko. Turingov stroj si bude strážiť, aby zápis v každej stope začínal vždy na tom istom políčku. Potom zápis jednej konfigurácie zaberie $\log n$ políčok.

Turingov stroj T na začiatku spustí procedúru $TESTUJ$ s parametrami počiatočná konfigurácia $C_0$, akceptačná konfigurácia $C_a$ a číslo $i$. Počiatočná konfigurácia má ukazovateľ v slove a v regexe nastavený na začiatok a ostatné adresy nedefinované. Akceptačná konfigurácia má tieto 2 ukazovatele nastavené na koniec a ostatné adresy môžu mať ľubovoľné hodnoty -- preto T bude spúšťať $TESTUJ$ pre všetky možné adresy. Číslo $i$, teda počet krokov, na ktoré sa vieme dostať z $C_0$ do $C_a$ je maximálne počet všetkých konfigurácií -- podľa \ref{pocet_vsetkych_konfig} je to $(r+1)(n+2)^{2r+2}$ (teraz $w=n$). Dĺžku regexu poznáme dopredu, teda je to konštanta. Preto hodnota $i$ je nejaký polynóm od $n$.

Spomínaný počet všetkých konfigurácií je spočítaný pre triedu regexov $\le$. V~našom algoritme však budeme realizovať prechody z definície \ref{dfkonfig}: XV. a XIV. na 1 krok, preto nám tento odhad postačuje.

Úprava algoritmu $TESTUJ$, aby zahŕňal spracovanie negatívneho lookaroundu je nasledovná. Budeme aplikovať kroky výpočtu XV. alebo XVI. To znamená, že celý negatívny lookahead/lookbehind môže byť preskočený na 1 krok. Kontrola, či je tento krok prípustný, sa udeje v riadku 2 funkcie $TESTUJ$, kedy sa testuje podmienka $C_1\vdash C_2$. Pokiaľ tento krok zodpovedá kroku výpočtu XV. alebo XVI., udeje sa nasledovné (Bez újmy na všeobecnosti, nech je to negatívny lookahead -- krok XV.):

Nech $C_1=(d_1,\dots,d_m)$, $C_2=(e_1,\dots,e_m)$, pričom musí platiť $(d_2,\dots,d_m)=(e_2,\dots,e_m)$. 

M zoberie regex vnútri negatívneho lookaroundu a na ďalšej páske bude spúšťať funkciu $TESTUJ$:
\begin{itemize}
\item s upravenými konfiguráciami, ktoré zodpovedajú negatívnemu lookaroundu -- Negatívny lookaround môže obsahovať zátvorky, ktoré vo vonkajšom regexe nie sú indexovateľné a vlastné pozitívne lookaroundy, pre ktoré potrebuje pomocnú pamäť. Nech $p$ je počet zátvoriek, ktoré sa nachádzajú vo vonkajšom regexe pred negatívnym lookaroundom a $q$ je počet nových adries. Potom konfigurácie budú obsahovať $t=3+p+q$ stôp, čo je konštanta.
\item s parametrami $(C_0,~C_a,~i)$ -- $C_0 = (a_1,\dots,a_t)$ je počiatočná konfigurácia a $C_a=(b_1,\dots,b_t)$ je akceptačná konfigurácia. Platí, že $a_1$ ukazuje na začiatok regexu v negatívnom lookarounde, $b_1$ na jeho koniec, $a_2=d_2$, adresy $a_3$ a $b_3$ sú nedefinované, adresy v konfiguráciách pre prvých $p$ zátvoriek sú určené z $C_1$: $(a_4,\dots,a_{p+4}) = (b_4,\dots,b_{p+4}) = (d_4,\dots,d_{p+4})$ a zvyšné $a_{p+5},\dots,a_t$ sú nedefinované.

Hodnota $i$ je rovnaká ako v hlavnej vetve procedúry $TESTUJ$, pretože horné ohraničenie pre celý regex funguje aj pre ľubovoľné jeho podslovo.
\item pre všetky prefixy od pozície $d_2$ -- To znamená, že T bude skúšať všetky akceptačné konfigurácie s hodnotami $b_2$ z množiny $\lbrace d_2, d_2+1,\dots,\lceil \log(n+1)\rceil\rbrace$.
\item pre všetky možné ohodnotenia adries $b_{p+5},\dots,b_t$ -- Počas výpočtu sa tieto adresy môžu zmeniť a budú tak mať iné hodnoty ako v počiatočnej konfigurácii. T bude skúšať (tak ako v hlavnom volaní) hodnoty od začiatku po koniec slova, teda od $(d_2,\dots,d_2)$ do $(b_2,\dots,b_2)$ vrátane nedefinovaných hodnôt. Hodnota $b_2$ určuje koniec prefixu, teda aktuálny koniec slova.
\end{itemize}
Počas výpočtu ukazovateľ v slove (adresa $d_2$) a ani ostatné adresy nesmú prekročiť hranice podslova, ktoré je vstupom. Preto pri generovaní konfigurácie $C_3$ bude T kontrolovať, či všetky adresy sú väčšie alebo rovné adrese $d_2$ z konfigurácie $C_0$ a menšie alebo rovné adrese $d_2$ z konfigurácie $C_a$.

Pokiaľ nejaké volanie vráti hodnotu \textbf{true}, potom netreba skúšať ďalšie možnosti a negatívny lookahead vráti okamžite \textbf{false}. Ak všetky volania vrátia \textbf{false}, potom odpoveď negatívneho lookaroundu je \textbf{true}. Po skončení sa všetky informácie z výpočtu zahodia, T iba overoval, či platí $C_1\vdash C_2$, preto ich už ďalej nepotrebuje.

Pre negatívny lookbehind je algoritmus iný iba v tom, že treba skúšať sufixy namiesto prefixov. V takom prípade adresa $b_2$ z akceptačnej konfigurácie bude fixná na hodnote $d_2$ a $a_2$ z počiatočnej konfigurácie bude nadobúdať hodnoty $0-d_2$.

Popísali sme volanie negatívneho lookaroundu z hlavného regexu. $\alpha$ však má v sebe niekoľko vnorených negatívnych lookaroundov a najväčšia hĺbka vnorenia je $k$. T má na 1. páske rozpracovanú vetvu hlavného regexu a teraz pracuje na 2. páske na negatívnom lookarounde a narazí na ďalší. Pre T je to obdobná situácia, ako keby pracoval stále na 1. páske. Zopakuje postup popísaný vyššie a vykoná príslušné volania procedúry $TESTUJ$ na 3. páske. Keď je hĺbka vnorenia $k$, v najvnútornejšom regexe bude mať na $k+1$ páskach rozpracované výpočty. Keď ukončí výpočet na $l$-tej páske, vráti sa s výsledkom na $(l-1)$-vú pásku. M skonštruovaný v dôkaze \ref{dspace_nlog2n} mal na vykonávanie 1 vetvy procedúry $TESTUJ$ 2 pásky. Preto T bude potrebovať $2(k+1)$ pások. $k$ je konštanta, preto je to v súlade s definíciou TS.

Čo sa týka pamäťových nárokov, na $(k+1)$ páskach je v každom kroku výpočtu spúšťaná najviac 1 vetva procedúry $TESTUJ$. Takto definovaná a spúšťaná procedúra pri každom spustení zaberie $O(\log n\cdot\log n) = O(\log ^2 n)$ priestoru, pretože hĺbka rekurzie je $$\log i = \log ((r+1)(n+2)^{2r+2}) = \log (r+1) + (2r+2)\log (n+2) = O(\log n)$$ a každá inštancia procedúry potrebuje $O(\log n)$ pamäte pre zapamätanie 3 konfigurácií a čísla $i$. O zvyšných $(k+1)$ páskach vieme z konštrukcie stroja M z dôkazu \ref{dspace_nlog2n}, že sú iba pomocné a na každej je zapísaných $O(\log (r+n)) = O(\log n) = O(\log^2 n)$ políčok. Ukázali sme, že vieme zostrojiť požadovaný Turingov stroj T, ktorý na každej páske zapíše najviac $O(\log^2 n)$ políčok.
\end{proof}

\section[Ukážka k popisnej zložitosti]{Ukážka zlepšenia popisnej zložitosti}
\label{vzlozitost}

Nové konštrukcie moderných regulárnych výrazov podstatne ovplyvňujú popisnú zložitosť. Ako sme spomínali, mnohé z nich neposilňujú model, ale sprostredkovávajú kratší zápis niektorých regexov. Zložitejšie konštrukcie tiež prispievajú svojou troškou, ako uvidíme ďalej v príklade. Výskum v tejto oblasti je bohatý na výsledky o regulárnych jazykoch ako sme videli v kapitole \ref{uzlozitost}. Pokračovať je možné porovnávaním so známymi výsledkami o klasických regulárnych výrazoch alebo skúmaním zložitosti nových jazykov, ktoré sme dosiahli až silnejším modelom.

Ochutnávkou z tejto oblasti je regex, ktorý ukazuje, že nové konštrukcie môžu výrazne pomôcť pri zápise niektorých konečných jazykov:
$$\alpha = (\lookahead 
\overbrace{
	\underbrace{
		\lookahead (a^m)*\$ )
	}_{I.}
	\underbrace{
		(a^{m+1})* a\lbrace 1,m-1\rbrace \$ ~|~ a^m \$ 
	}_{ II. }
}^{ III. }
) a^m)+$$

$$\text{platí: } a^x = \underbrace{aa\dots a}_x = a\lbrace x \rbrace$$



Podrobnejšie si popíšme, čo jednotlivé časti matchujú a ako prebieha výpočet:
\begin{enumerate}[I.]
\item matchuje $a^{km}$, kde $k\in\N_0$
\item matchuje $a^m$ alebo $a^l$, kde 
$$l\in\lbrace j(m+1)+1,j(m+1)+2,\dots,j(m+1)+m-1 ~|~j\in\N_0\rbrace$$
To znamená, že matchuje celé $\lbrace a\rbrace$* okrem: $a^{m+1}$, $a^{m(m+1)l}$, $l\in\N$
\item je prienik I. a II. V oboch vidíme na konci znak \$, teda matchujú až do konca slova. Výsledný regex matchuje $a^{km}$ také, že nevie $a^{m(m+1)l}$, $l\in\N$.
\end{enumerate}
Lookahead III. je nútený každú iteráciu matchovať $a^{im}$, kde $i\in\N$. Najkratšie slovo, ktoré je tvaru $a^{im}$ a regex III. ho zamietne je $a^{m(m+1)}$. Pokiaľ sa operácia $+$ dostane k $(m+1)$-vej iterácii, v tomto momente regex zamietne kvôli lookaheadu. Nie je možné sa vrátiť a zmeniť výpočet, pretože mimo lookaheadu sa neudiali žiadne nedeterministické rozhodnutia. Z tohto dôvodu bude ľubovoľné slovo dlhšie ako $a^{m(m+1)-1}$ zamietnuté. Regex $\alpha$ preto zodpovedá konečnému jazyku $$L = \lbrace a^m, a^{2m},\dots, a^{m^2} \rbrace$$

Počet znakov potrebných na zápis $\alpha$ za predpokladu, že nemôžeme používať operáciu $\{n,m\}$\footnote{V takom prípade by bol najkratší regex triviálne $(a\{m\})\{1,m\}$ s potrebným počtom znakov $9+\nobreak 2\log m$.} 
$$\alpha = 
\underbrace{
(\lookahead 	\lookahead (
}_{8}
 a^m
\underbrace{ 
 )*\$ ) (
}_{5}
a^{m+1}
\underbrace{
)* 
}_{2}
a\{1,m-1\}
\underbrace{ 
 \$ ~|~  
}_{2}
a^m
\underbrace{ 
\$ ) 
}_{2}
a^m
\underbrace{ 
 )+
}_{2}
$$
$$21+m+ (m+1)+\sum_{i=1}^{m-1} i+ m + m= \frac{m(m-1)}{2} + 4 m + 22\leq m^2 + 5m + 12$$

Ten istý jazyk vieme zapísať aj s pomocou negatívneho lookaheadu nasledovne:
$$\beta = \nlookahead a^{m^2+1})(a^m)+$$
A ten potrebuje na zápis $7+(m^2+1)+m = m^2 + m + 8$ znakov.

Porovnajme teraz tieto výsledky so starým modelom. 