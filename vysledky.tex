\chapter{Naše výsledky}
\label{chap:vysledky}

\section[Vlastnosti a sila]{Vlastnosti a sila moderných regulárnych výrazov}
\label{vsila}

V bakaláskej práci sme zabudli ... \textbf{\textit{negatívny lookaround}} \todo

\begin{lema}\label{nla+R}
Trieda $\R$ je uzavretá na negatívny lookahead.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$. Ukážeme, že $L=L_1(?!L_2)L_3 \in \R$.

Keďže $ L_{1},L_{2},L_{3} $ sú regulárne, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=L_{i}, i \in \lbrace 1,2,3\rbrace $. Zostrojíme NKA $A$ pre $L$.

Konštrukcia bude veľmi podobná ako pre pozitívny lookahead, keď si správne predpripravíme $A_2$. Negatívny lookahead sa snaží za každú cenu nájsť slovo z $L_2$ (t.j. uspieť s $A_2$) a ak sa mu to nepodarí, akceptuje. Preto musíme zaručiť, že sa $A_2$ buď zasekne alebo prejde až do konca slova\footnote{Ak sa zasekne, slovo z $L_2$ tam určite nebude, lebo neexistuje akceptačný výpočet. Ak sa nezasekne, nevieme povedať o tom slove nič, pokiaľ ho neprejdeme celé.}. Ak $A_2$ dosiahne akceptačný stav, negatívny lookahead musí zamietnuť. 

Ďaľšie pozorovanie nám hovorí, že negatívny lookahead akceptuje vždy nejaké slovo z komplementu $L_2$. Ale komplement vzhľadom na akú abecedu? V skutočnosti nekonečnú - ľubovoľný znak, ktorý nepatrí do $\Sigma_2$, znamená zaseknutie $A_2$, t.j. akceptáciu. Ak sa na to pozrieme z väčšej ďiaľky, uvidíme $L_3$, s ktorým robíme prenik. $A_3$ musí dočítať slovo do konca a na úplne neznámom znaku sa zasekne, takže z pohľadu výslednej akceptácie slova nevadí, ak by kvôli tomu znaku zamietol už negatívny lookahead. Preto stačí urobiť komplement vzhľadom na $\Sigma_2 \cup \Sigma_3$. 

Poďme upravovať $A_2$, začneme vytváraním komplementu. Ak $\Sigma_3 \setminus \Sigma_2 \neq\emptyset$\footnote{Inak $A_2'=A_2$.}, potom vytvoríme $A_2'= (K_2',\Sigma_2',\delta_2',q_{0},F_2')$ tak, že pridáme nové znaky $\Sigma_2'=\Sigma_2 \cup \Sigma_3$,  jeden nový stav\footnote{Pre každý nový stav predpokladáme, že je jedinečný - t.j. žiaden taký v množine stavov ešte nie je.} $K_2'=K_2 \cup \lbrace q_{ZLE} \rbrace$ a prechody na nové znaky z každého stavu: 
\begin{eqnarray*}
 \forall q \in K_2 ~ \forall a \in \Sigma_2 &:&  \delta_2'(q,a)=\delta_2(q,a) \\
 \forall q \in K_2~ \forall a \in \Sigma_3 \setminus \Sigma_2 &:& \delta_2'(q,a)=q_{ZLE} \\
 \forall a \in \Sigma_2' &:&  \delta_2'(q_{ZLE},a)=q_{ZLE}
\end{eqnarray*}
 $F_2'=F_2.$ Do všetkých stavov sme pridali prechody na nové znaky a $q_{ZLE}$ má 1 prechod na každý znak, takže $A_2'$ je stále deterministický. Zároveň nové znaky vedú do stavu, z ktorého sa nedá dostať do žiadneho akceptačného, z čoho vyplýva $L(A_2')=L_2$.

Teraz $A_2'$ zmeníme na $A_2''$ tak, aby akceptoval práve vtedy, keď $(?!L_2)$. Najprv si skonštruujeme množinu stavov, z ktorých sa vieme dostať do akceptačného stavu: $H= \lbrace  q \in K_2'~|~ \exists w \in {\Sigma_2'}^* ~ \exists q_A \in F_2': ~ (q,w)\vdash_{A_2'}(q_A,\varepsilon) \rbrace $, nasledovným spôsobom: $$ H_0 = F_2' $$ 
$$H_{i+1} = \lbrace q \in K_2'~|~ \exists p \in H_i~ \exists a \in \Sigma_2': ~ \delta(q,a)=p \rbrace$$
Zrejme $\exists i \in \N: ~ H_{i+1}=H_i = H$. Nás zaujíma množina $K_2' \setminus H$, v ktorej sa nachádzajú všetky stavy, z ktorých sa na žiadne slovo nie je možné dostať do žiadneho akceptačného stavu.

$A_2''= (K_2'',\Sigma_2'',\delta_2'',q_{0},F_2'')$: $K_2'' = K_2' \cup \lbrace q_A, q_Z \rbrace, ~\Sigma_2'' = \Sigma_2', ~F_2'' = (K_2'\setminus H) \cup \lbrace q_A \rbrace$
\begin{eqnarray*}
 \forall q \in K_2' \setminus F_2'  ~ \forall a \in \Sigma_2' &:&  \delta_2''(q,a)=\delta_2'(q,a) \\
 \forall q \in K_2' \setminus F_2'  ~ \forall a \in \Sigma_2' &:&  \delta_2''(q,\varepsilon)=q_A \\
 \forall q \in F_2' ~ \forall a \in \Sigma_2' &:& \delta_2''(q,a)=q \footnotemark \\
 \forall a \in \Sigma_2' &:& \delta_2''(q_A,a)=q_Z 
\end{eqnarray*}
\footnotetext{Tento riadok v podstate netreba, $A_2''$ sa môže rovno zaseknúť, lebo $A_2'$ práve akceptoval.}
Je dobré poznamenať, že $A_2''$ je takmer deterministický. Chýbajú mu prechody z $q_Z$ - môžeme ho nechať cykliť v tomto stave, ale nevadí nám ani keď sa zasekne. Nedeterministické rozhodnutie vykonáva iba jedno - pri prechode do stavu $q_A$. Vtedy háda, že už je na konci slova. Ak nie je, $\delta$-funkcia ho pošle do stavu $q_Z$. Podľa toho je zrejmé, že ak existuje akceptačný výpočet a dočítal slovo do konca, je práve jeden\footnote{Okrem prípadu, kedy dočíta slovo a je v stave z $(K_2'\setminus H)$ - vieme ho predĺžiť o krok na $\varepsilon$ a skončiť v $q_A$. Jadro výpočtu ale zostáva rovnaké - jednoznačné.} \footnote{Zaujímavé je, že aj zamietací výpočet je pre každé slovo jednoznačný}.

Tvrdíme $ L_1(?=L(A_2''))L_3 =L_1(?!~L_2)L_3= L $.
Keďže $A_1$ a $A_3$ sa pri oboch výpočtoch budú chovať rovnako (sú nezávislé od lookaheadov), nebudeme sa nimi pri dôkaze zaoberať.

$\subseteq :$ Máme akceptačný výpočet pre $A_2''$ na nejakom vstupe. Akceptačný stav mohol byť buď z množiny $K_2'\setminus H$, to znamená, že pôvodný automat $A_2'$ sa dostal do stavu, z ktorého už nemohol nijak akceptovať\footnote{Sem spadá aj prípad, keď $A_2$ prečítal neznámy znak a zasekol sa - $A_2'$ zostáva až do konca slova v stave $q_{ZLE}$.}. V takom prípade $(?!~L_2)$ akceptuje. V druhom prípade mohol $A_2''$ akceptovať pomocou $q_A$, čo znamená, že dočítal slovo do konca (pretože z $q_A$ sa na ľubovoľný znak dostaneme do $q_Z$, v ktorom sa $A_2''$ zasekne a nebude akceptovať) a ani raz sa nedostal do akceptačného stavu automatu $A_2'$. Teda aj $(?!~L_2)$ akceptuje.

$\supseteq :$ Nech $(?!~L_2)$ akceptoval, t.j. na $A_2$ bol vykonaný nejaký neakceptujúci výpočet ($A_2$ je deterministický, takže existuje práve jeden pre každé slovo). Rovnakú postupnosť stavov bude mať aj výpočet na $A_2''$ (automat obsahuje všetky stavy aj $\delta$-funkciu z $A_2$, počiatočný stav je ten istý). Ak sa $A_2$ zasekol na neznámom znaku, v $A_2'$ na ten znak pridáme prechod do stavu $q_{ZLE}$ a v ňom zostaneme až do konca slova. Keďže $q_{ZLE}$ nie je v $A_2'$ akceptačný a nedá sa z neho na žiadne slovo dostať do ľubovoľného akceptačného stavu, $q_{ZLE} \in K_2' \setminus H$ a teda $q_{ZLE} \in F_2''$. Ak sa $A_2$ nezasekol, tak dočítal slovo do konca a v postupnosti stavov jeho výpočtu sa nenachádza žiaden z množiny $F_2$. V tom prípade $A_2''$ z posledného stavu prejde na $\varepsilon$ do $q_A$ (2.riadok definície $\delta_2''$) a akceptuje.

Z práve dokázaného tvrdenia a vety \ref{lookahead+R} už vyplýva aj platnosť našej lemy.
\end{proof}

\begin{lema}
Trieda $\R$ je uzavretá na negatívny lookbehind.
\end{lema}
\begin{proof}
Nech $L_1,L_2,L_3 \in \R$, existujú DKA $ A_{i} = (K_{i},\Sigma_{i},\delta_{i},q_{0i},F_{i}) $ také, že $ L(A_{i})=L_{i}, i \in \lbrace 1,2,3\rbrace $.. Ukážeme, že $L=L_1(?<!~L_2)L_3 \in \R$.

Nemôžme skonštruovať $A_2''$ také, že bude akceptovať práve vte\-dy, keď $(?<~!L_2)$, pretože nevieme čítať doľava. Tzn. zaručiť, že miesto, kde začína $A_2''$ výpočet je skutočný začiatok slova. Mechanizmus lookbehindu musí byť riadený zvonku, automatom pre $L$. Skonštruujeme ho. $C=(K,\Sigma, \delta,q_0,F):$ 
$$K=K_3\cup \lbrace (q,A) ~|~ q \in K_1 \wedge A \subseteq K_2 \rbrace,~\Sigma = \Sigma_1\cup\Sigma_2\cup\Sigma_3,~q_0=(q_{01},\lbrace q_{02}\rbrace),F=F_3~ \delta:$$
\begin{eqnarray*}
\forall q \in K_3~ \forall a \in \Sigma_3 &:& \delta(q,a) \ni \delta_3(q,a) \\
\forall q \in K_1 ~\forall A \subseteq K_2~ \forall a \in \Sigma_1 \cap \Sigma_2 &:& \delta((q,A),a) \ni (p,B\cup \lbrace q_{02}\rbrace), ~\text{kde}~ \delta_1(q,a)=p,\\ &~& B=\lbrace r ~|~ \exists s \in A:~ \delta_2(s,a)=r \rbrace \\
\forall q \in K_1 ~\forall A \subseteq K_2 ~ \forall a \in \Sigma_1 \setminus \Sigma_2 &:& \delta((q,A),a) \ni (p,\lbrace q_{02}\rbrace), \text{ kde } \delta_1(q,a)=p \\
\forall q \in F_1~\forall A: ~A \subseteq K_2 \wedge A \cap F_2 = \emptyset &:& \delta((q,A),\varepsilon) \ni q_{03}
\end{eqnarray*}
Druhý riadok $\delta$-funkcie hovorí, že $A_1$ a všetky rozbehnuté výpočty $A_2$ prejdú do ďalšieho stavu a zároveň sa rozbehne nový výpočet $A_2$. Ak by sme hľadali jeden akceptačný výpočet $A_2$ stačilo by tipnúť si začiatok a odtiaľ ho simulovať. Lenže simulujeme negatívny lookbehind, teda ak neexistuje akceptačný výpočet, tak my akceptujeme (prejdeme na simulovanie $A_3$, 4. riadok). A to vieme povedať len v prípade, že sme videli všetky možné výpočty. Keďže $A_2$ je deterministický, pre každé slovo existuje práve jeden výpočet a zároveň sa nikdy nezasekne (na svojej abecede), teda nám stačí skontrolovať množinu stavov vtedy, keď sa $C$ rozhodne, že $A_1$ končí výpočet. Ak tam je, nedostane sa k simulovaniu $A_3$ a tým ani k akceptačným stavom.

$L(C)=L.$

$\subseteq:$
Majme akceptačný výpočet $C$ na $w$. Z definície $F$ vyplýva, že $A_3$ akceptoval, teda $\exists u,v$ také, že $w=uv$ a $v \in L_3$. Do $q_{03}$ sa dá dostať len z dvojice $q,A$ takej, že $q\in F_1$, teda $u\in L_1$, a $a \cap F_2 = \emptyset$, teda $\nexists xy$ také, že $u=xy$ a $y \in L_2$. To vyplýva z toho, že v každom znaku $u$ začal jeden výpočet na $A_2$ a žiaden z nich neakceptoval. Teda negatívny lookbehind akceptoval a $w\in L$.

$\supseteq:$
Nech $w\in L$, teda $\exists u,v$ také, že $w=uv,~ u \in L_1, v\in L_3$ a $\forall x,y:~u=xy$ platí $y \notin L_2$. Pre $u,v$ teda existujú akceptačné výpočty na $A_1,A_3$ a pre všetky $y$ neakceptačné na $A_2$. Z toho už vieme vyskladať akceptačný výpočet na $C$.
\end{proof}

\begin{veta}
Trieda $\R$ je uzavretá na negatívny lookaround.
\end{veta}

\begin{lema}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = \left( L_1 \left( ?!~L_2\right) L_3 \right) * L_4$. Potom $L(\alpha) \in \R$.
\end{lema} 
\begin{proof}
Podobne ako v dôkaze vety \ref{nla+R} pretransformujeme $( ?!~L_2)$ na akýsi $( ?=L(A_2''))$, kde $A_2''$ bude akceptovať práve vtedy, keď $( ?!~L_2)$. Potom $\beta = \left( L_1 \left( ?=L(A_2'')\right) L_3 \right) * L_4, ~ L(\beta) = L(\alpha) \in \R$ podľa vety \ref{lookaround+R}.
\end{proof}

\begin{lema}
Nech $L_1,L_2,L_3,L_4 \in \R$, $\alpha = L_4 \left( L_1 \left( ?<!~L_2\right) L_3 \right) *$. Potom $L(\alpha)~\in~\R$.
\end{lema} 
\begin{proof}
\todo
\end{proof}

\begin{veta}\label{nlookaround+R}
Trieda nad regexami s negatívnym lookaroundom je $\R$.
\end{veta}

\begin{dosledok}
Trieda nad regexami s pozitívnym a negatívnym lookaroundom je $\R$.
\end{dosledok}

\begin{veta}
Trieda \le~je uzavretá na zreťazenie.
\end{veta}
\begin{proof}
Nech sú le-regexy $\alpha, \beta$. Chceme ukázať, že jazyk $L(\alpha)L(\beta) \in \le$. Intuitívne nás to vedie k riešeniu $\alpha\beta$, čo ale nemusí byť vždy správne. Problémom sú operácie lookaround, presnejšie každý lookahead v $\alpha$ môže zasahovať do slova z $L(\beta)$ a takisto každý lookbehind z $\beta$ môže zasahovať do slova z $L(\alpha)$. Navyše, ak lookahead obsahuje $\$$ a lookbehind $\textasciicircum$, potom zasahujú do slova z iného jazyka určite. V takom prípade môže le-regex $\alpha\beta$ vynechať niektoré slová z $L_1L_2$ a tiež pridať nejaké nevhodné slová naviac. Preto treba nájsť spôsob, ako operácie lookaroundu vhodne 'skrotiť', predpokladajme, že $\alpha$ má $k$ označených zátvoriek:
\begin{equation} \label{zretazenie}
(?=\mathop(_1 \alpha \mathop)_1 \mathop(_{k+2}\beta \mathop)_{k+2} \mathdollar) \alpha ' \backslash k+2 (?<= \textasciicircum\backslash 1\beta ')
\end{equation}
V $\alpha,\beta$ treba vhodne prepísať označenie zátvoriek (po poradí). $\alpha '$ je $\alpha$ prepísaný tak, že pre každý lookahead:
\begin{itemize}
\item bez \$ - na koniec pridáme $.* \backslash k+2 \mathdollar $
\item s \$ - pred \$ pridáme $\backslash k+2$
\end{itemize}
$\beta '$ je $\beta$ prepísaný tak, že pre každý lookbehind:
\begin{itemize}
\item bez $\textasciicircum$ - na začiatok pridáme $\textasciicircum \backslash 1.*$
\item s $\textasciicircum$ - pred $\textasciicircum$ pridáme $\textasciicircum \backslash 1$
\end{itemize}
Čo teda robí le-regex ~\ref{zretazenie}? Nech $w$ je vstupné slovo, ktoré chceme matchovať. Lookahead na začiatku ho nejak rozdelí na $w_1$ a $w_2$, pričom $w=w_1w_2$, tak, že do $L(\alpha)$ pridelí $w_1$ a do $L(\beta)$ podslovo $w_2$. Ešte musíme overiť, či $\alpha$ matchuje $w_1$ samostatne.

Preto sme v $\alpha$ prepísali všetky lookaheady. V $\alpha '$ každý z nich musí na konci slova $w$ matchovať $w_2$ (toto zabezpečí spätná referencia $\backslash k+2$ a \$) a teda matchovanie le-regexu $\alpha$ zostane výlučne na podslove $w_1$. Analogicky to platí pre lookbehindy v $\beta '$.
\end{proof}

\begin{veta}\label{lelcf}
$\le$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Majme jazyk $L=\lbrace ww^R~|~w \in \lbrace a,b \rbrace^* \rbrace \in \L_{CF}$, nech $ \alpha = ([ab]*)\backslash 1 $.
Zrejme $ L(\alpha) = L $, teda $L\in \le$.

Ukážeme, že jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace \notin \le$. Sporom, nech $L \in \le$. 

Vieme, že $L \notin \e$, preto musí obsahovať nejaký lookaround. Zároveň z $L \notin \R$ a \ref{lookaround+R} vyplýva, že musí obsahovať aj spätné referencie.

Kam sa môžu spätné referencie odkazovať a kam ich potom môžeme umiestniť?
\begin{list}{$\bullet$}{Nech výraz, na ktorý ukazujú, vyrobí nejaké:}
\item $a^i$, potom $\backslash k$ musí byť v prvej polovičke slova (medzi $a$, inak by pokazil štruktúru slova), takže nevplýva na časť s $b$ a teda sa zaobídeme bez nich.
\item $a^ib^j$, potom $\backslash k$ by mohol byť len medzi $b$, ale tam by pokazil štruktúru slova $a^nb^n$
\item $b^j$, potom $\backslash k$ môže byť len medzi $b$ a je tam zbytočný z rovnakých dôvodov, aké má prípad $a^i$
\end{list}
Vidíme, že so spätnými referenciami dosiahneme rovnaký výsledok ako bez nich, čo je spor s tým, že sa vo výraze musia nachádzať (bez nich vieme urobiť len regulárny jazyk).
\end{proof}

\begin{dosledok}
$\le \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$ nLEregex \subseteq \L_{CS} $
\end{veta}
\begin{proof}
Vieme, že $ \le \in \L_{CS} $ (veta \ref{le+lcs}), teda ľubovoľný le-regex vieme simulovať pomocou LBA. Ukážeme, že ak pridáme operáciu negatívny lookahead/lookbehind, vieme to simulovať tiež.

Nech $\alpha$ je nle-regex. Potom $A$ je LBA pre $\alpha$, ktorý ignoruje negatívny lookaround (t.j. vyrábame LBA pre le-regex). Teraz vytvoríme LBA $B$ pre le-regex vnútri negatívneho lookaroundu. Z nich vytvoríme LBA $C$ pre úplný nle-regex $\alpha$ tak, že bude simulovať $A$ a keď príde na rad negatívny lookaround zaznačí si, v akom stave je $A$ a na ktorom políčku skončil. Skopíruje slovo na ďalšiu stopu a na nej simuluje od/do toho miesta $B$ (podľa toho, či je to lookahead alebo lookbehind). 

Teraz je to s akceptáciou náročnejšie ako pri pozitívnom lookarounde. Pokiaľ $B$ akceptoval, $C$ sa zasekne. Ak sa $B$ zasekol, $C$ sa vráti naspäť k zastavenému výpočtu $A$ a pokračuje v ňom. Keďže slovo je konečné a $B$ na ňom testuje le-regex, ktorý postupne vyjedá písmenká, určite raz príde na koniec slova. Môže sa stať, že bude skúšať viaceré možnosti - napr. skúsi pre $*$ zobrať menej znakov, teda príde na koniec slova viackrát. Ako určíme, že skončil výpočet? Bez újmy na všeobecnosti môžeme predpokladať, že sa $B$ nezacyklí, ale zamietne slovo na konci výpočtu. To preto, že všetkých možností na rozdelenie znakov medzi operácie $*,+,?,\lbrace n,m\rbrace$ je konečne veľa a keď ich systematicky skúša\footnote{Algoritmus pre $*$ je v praxi greedy. Ak slovo nesedí, tak sa vráti, odoberie posledný znak zožratý $*$ a opäť skúša zvyšok výrazu, či slovo sedí. Ak stále nie, algoritmus odoberá hviezdičke znaky dovtedy, dokým nenájde zhodu alebo odoberie všetky znaky - vtedy sa mu minuli všetky možnosti a môže slovo neakceptovať.}, raz sa mu musia minúť. To znamená, že ak nemá v $\delta$-funkcii umelo vsunuté zacyklenie, nezacyklí sa. Teda ak slovo neakceptuje, tak ho určite zamietne a vtedy $C$ môže prejsť na zastavený výpočet $A$ a pokračovať v ňom.

Podobne ako pri lookarounde aj jeho negatívna verzia môže obsahovať nle-regex, t.j. vnorený (negatívny) lookaround. Tých však môže byť iba konečne veľa, keďže každý nle-regex musí mať konečný zápis. Čo znamená, že aj stôp bude konečne veľa a naznačeným postupom si vieme postupne vybudovať LBA, ktorý bude simulovať $\alpha$.
\end{proof}

\begin{veta}
$\nle$ je neporovnateľná s $ \L_{CF}$.
\end{veta}
\begin{proof}
Opäť použíjeme jazyk $L=\lbrace a^nb^n~|~n \in \N \rbrace$ a budeme dokazovať sporom. Nech $L \in \le$.

Z vety \ref{lelcs} vieme, že výraz musí obsahovať negatívny lookaround. Z jej dôkazu vidíme, že spätné referencie nepomôžu nech sa ich pokúsime hocijako použiť. Z toho vyplýva, že ich nepoužijeme a z vety \ref{nlookaround+R} zistíme, že nám zostal model schopný vyrobiť iba regulárne jazyky. Spor.
\end{proof}

\begin{dosledok}
$\nle \subsetneq \L_{CS}$
\end{dosledok}

\begin{veta}
$\le \subseteq NSPACE(\log n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
Ukážeme, že ľubovoľný $\alpha \in \le$ vieme simulovať nedeterministickým Turingovým strojom s jednou vstupnou read-only páskou a jednou pracovnou páskou, na ktorej použijeme maximálne logaritmický počet políčok.

Celý regex si budeme uchovávať v stavoch\footnote{Každý regex je má z definície konečnú dĺžku, to znamená aj konečný počet stavov.} a pridáme doňho špeciálny znak $ \blacktriangleright $, ktorým si budeme ukazovať, kam sme sa v regexe dopracovali -- bude to akýsi smerník na znak, ktorý práve spracovávame. Teda stav bude vyzerať takto: $q_{\beta\blacktriangleright\xi}$ (pre lepšiu čitateľnosť budeme uvádzať namiesto stavu iba jeho dolný index: $\beta\blacktriangleright\xi$), kde $\beta\xi = \alpha$, časť $\beta$ sme už namatchovali na vstup a práve sa chystáme pokračovať časťou $\xi$. Ak $\blacktriangleright$ ukazuje na znak, porovnáme ho s aktuálnym znakom na vstupnej páske. Pokiaľ sa nezhodujú, výpočet sa zasekne. Pri zhode pokračujeme až kým sa nám neminie vstup aj regex. Ak $\blacktriangleright$ ukazuje na metaznak, potom zistíme o akú operáciu ide (ak má viac znakov, treba na to niekoľko stavov -- napr. lookahead) a začneme ju vykonávať.

Pracovná páska bude slúžiť ako úložisko smerníkov na rôzne miesta vstupnej pásky. Bude mať formát $A_1\#A_2\#\dots\#A_m$. Adresu nejakého políčka na vstupnej páske vieme zapísať v priestore $\log n$. Ak ukážeme, že $m$ je konštanta, potom $m.\log n \in O(\log n)$. Adresa $A_1$ bude rezervovaná pre prvý adresný slot na aktuálnu pozíciu hlavy na vstupe, nech si ju máme odkiaľ okopírovať, keď treba. Adresy budeme využívať pri operáciách spätná referencia, lookahead a lookbehind.

Keďže celý regex vidíme pri konštrukcii Turingovho stroja, vieme si do stavov zakódovať význam a poradie adresných slotov. A celú pracovnú pásku si predpripraviť (napísať potrebný počet \#). 

Teraz skonštruujeme Turingov stroj $M = \left( K, \Sigma, \delta, q_0, F \right)$ k regexu $\alpha$. 
$$ K = \lbrace \beta\blacktriangleright\xi ~|~ \beta,\xi \textit{ sú podslová } \alpha \textit{ také, že } \beta\xi = \alpha \rbrace $$
$$ \Sigma = \Sigma(\alpha)\footnote{T.j. všetky znaky a metaznaky použité v regexe $\alpha$.}, ~
q_0 = \blacktriangleright\alpha, ~
F = \lbrace \alpha\blacktriangleright \rbrace $$
\underline{$\delta:$ (v tvare: stav, znak čítaný na vstupnej páske)} 

Kvôli prehľadnosti popíšeme len hlavné kroky algoritmu. 
\begin{list}{}{}
\item $\delta(\beta\blacktriangleright a \xi, a) = \lbrace (\beta a \blacktriangleright \xi, 1) \rbrace ~ \forall a \in \Sigma$ -- Ak je v regexe znak, matchujeme ho s tým na vstupe.
\item $\delta(\beta\blacktriangleright(\gamma)\xi, a) = \lbrace (\beta(\blacktriangleright\gamma)\xi, 0) \rbrace$ -- Ak sú to $k$--te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu začiatku pre $\backslash k$.
\item $\delta(\beta(\gamma\blacktriangleright)\xi, a) = \lbrace (\beta(\gamma)\blacktriangleright\xi, 0) \rbrace$ -- Ak sú to $k$--te zátvorky a regex obsahuje $\backslash k$, zapíšeme aktuálnu adresu ako adresu konca pre $\backslash k$. Používame polootvorený interval -- znak na koncovej adrese do podslova nepatrí.
\item $\delta(\beta(\gamma)\blacktriangleright * \xi, a) = \lbrace (\beta(\blacktriangleright\gamma)*\xi, 0),(\beta(\gamma)*\blacktriangleright\xi, 0) \rbrace$ -- Kleeneho $*$: buď opakujeme alebo pokračujeme ďalej.
\item $\delta(\beta\blacktriangleright\backslash k \xi, a) = \lbrace (q_{najdi\_zaciatok(k)}, 0) \rbrace$ -- Najprv si zapamätáme aktuálnu pozíciu na vstupe (ďalej označovanú ako 'aktuálna pracovná pozícia'). Stav $q_{najdi\_zaciatok(k)}$ zodpovedá presunu hlavy na vstupnej páske na začiatočnú pozíciu podslova. Tu začneme algoritmus porovnávania podslov podľa definície spätnej referencie -- aké podslovo matchujú $k$-te zátvorky, také isté musí ležať aj na 'aktuálnej pracovnej pozícii'. Algoritmus bude porovnávať vždy postupne po jednom znaku od začiatočnej pozície (ľavá zátvorka) po (koniec - 1) (pravá zátvorka):

\begin{verbatim}
pokiaľ zaciatok != koniec: 
    zapamätaj si znak 
    začiatok++ 
    presuň hlavu na pozíciu 'aktuálna pracovná pozícia' 
    porovnaj znak (ak nesedí, zasekni sa) 
    (aktuálna pracovná pozícia)++ 
    presuň hlavu na pozíciu 'začiatok' 
presuň hlavu na pozíciu 'aktuálna pracovná pozícia'
\end{verbatim}
Vidíme, že si dočasne potrebujeme zapamätať adresu 'aktuálna pracovná pozícia', ale po skončení tohto algoritmu ju môžeme zahodiť.

Po úspešnom zbehutí algoritmu TS prejde do stavu $\beta\backslash k \blacktriangleright\xi$.
\item $\delta(\beta\blacktriangleright(?=\gamma)\xi, a) = \lbrace (\blacktriangleright\gamma, 0) \rbrace$ -- Lookahead: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske a spracujeme regex vnútri lookaheadu. Ak uspejeme, presunieme hlavu na vstupnej páske naspäť na zapamätanú pozíciu a pokračujeme v regexe ďalej: $\delta(\gamma\blacktriangleright, a) = \lbrace (\beta(?=\gamma)\blacktriangleright\xi, 0) \rbrace $.
\item $\delta(\beta\blacktriangleright(?<=\gamma)\xi, a) = \lbrace (doľava\_ \gamma, 0) \rbrace$
-- Lookbehind: zapamätáme si aktuálnu pozíciu na vstupe do zodpovedajúceho slotu na pracovnej páske. Toto je zarážka pre lookbehind - svoje matchovanie musí skončiť na tejto pozícii tak, že tento znak už neberie do úvahy. Nedeterministicky sa vrátime o niekoľko políčok doľava ($\delta(doľava\_ \gamma, a) = \lbrace(doľava\_ \gamma,-1), (\blacktriangleright\gamma, 0)\rbrace$)  a skúsime matchovať regex v lookbehinde. Keď uspejeme, porovnáme aktuálnu pozíciu so zarážkou. Ak sú rôzne, Turingov stroj sa zasekne. Inak pokračuje vo výpočte ďalej, od tejto pozície: $\delta(\gamma\blacktriangleright\_overene, a) = \lbrace (\beta(?<=\gamma)\blacktriangleright\xi, 0) \rbrace $.
\end{list}

\textbf{\underline{Počet adries}}:

Pre \textbf{spätné referencie} potrebujeme vždy 2 adresy -- na začiatok a koniec. Ak sa náhodou budú $k$-te zátvorky opakovať, napr. kvôli Kleeneho $*$, v definícii stojí, že sa vždy berie do úvahy posledný výskyt, takže adresy prepisujeme pri každom opakovaní. V prípade, že sa $k$-te zátvorky nachádzajú vnútri lookaheadu/lookbehindu, tiež máme pre ne rezervované 2 sloty. Algoritmus porovnávania potrebuje 1 ďalšiu adresu -- aktuálnu pracovnú pozíciu. Po jeho dokončení adresu môžeme vymazať (tzn. v ďalšom výpočte prepísať niečím iným).

V prípade \textbf{lookaheadu a lookbehindu} spotrebujeme len 1 adresný slot a to tiež len dočasne -- dokým sa operácia celá nevykoná. Potom je nám tento údaj zbytočný. Tieto operácie však môžu byť vnorené a tak v najhoršom prípade zaberú $p.\log n$ priestoru, ak ich počet je $p$.

Ak máme 1 rezervovaný slot pre aktuálnu adresu, $s$ spätných referencií, $l_a$ lookaheadov a $l_b$ lookbehindov, najviac spotrebujeme $(1+2s+1+l_a+l_b)\log n$ priestoru. Celý regex $\alpha$ je konečne dlhý, teda počet operácií je konečný. Čo znamená, že $m=1+2s+1+l_a+l_b$ je konštanta a to sme chceli dokázať.

\end{proof}


\begin{veta}[Savitch]
Nech $S(n)\geq \log n$ je páskovo konštruovateľná, potom 
$$ NSPACE(S(n)) \subseteq DSPACE(S^2(n)) $$
\end{veta}

\begin{dosledok}
$\le \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{dosledok}

\begin{veta}
$\nle \subseteq DSPACE(\log^2 n)$, kde $n>1$ je veľkosť vstupu.
\end{veta}
\begin{proof}
\TODO
\end{proof}

\begin{df}
$L(regex\#word)$ nazývame jazyk takých slov, kde $regex$ je validný regulárny výraz z $R$ a slovo $word \in L(R)$. Množina $R \in \lbrace \e, \le, \nle \rbrace$ musí byť špecifikovaná.
\end{df}

\begin{df}
\textbf{Konfiguráciou} regexu $\alpha = r_1 \dots r_n$ nazývame dvojicu $(r, w)$, kde $r \in (\lceil\alpha)\cup(\alpha\lceil)\cup(r_1 \dots \lceil r_i \dots r_n)$ $w \in \Gamma^*\lceil~ \Gamma^*$ a sybmol $\lceil$ ukazuje, kde sa nachádzame vo výpočte v regexe a v slove.
\end{df}

\begin{df}
Konfiguráciu $(r_1 \dots r_n \lceil, w_1\dots w_m \lceil)$ nazývame \textbf{akceptačná}.
\end{df}

\begin{df}
Zátvorka $($ v regexe $\alpha$ je \textbf{indexovateľná}, ak sa bezprostredne za ňou nenachádza metaznak ? a zárorveň sa nenachádza vnútri negatívneho lookaroundu.
\end{df}
Je zakázané odkazovať sa spätnými referenciami na operácie formy $(?\dots )$, preto ich ani nechceme a nebudeme brať do úvahy v poradí zátvoriek. Z týchto operácií sa v našom modeli nachádza iba pozitívny a negatívny lookaround. Je povolené odkazovať sa na zátvorky vnútri lookaroundu, takže sa vieme odvolať na podslovo, čo sa zhoduje s pozitívnou formou (ak lookaround považujeme za neindexovateľné zátvorky, stačí ho prepísať do formy $(?=(\dots ))$ a vieme sa referencovať na jeho obsah). Problém nastáva pri jeho negatívnej verzii -- podľa definície nesmie nájsť žiadnu zhodu, inak sa výpočet zastaví. Potom po akceptácii nedefinuje žiadne podslovo, na ktoré by sme sa mohli odvolať. To isté platí o ľubovoľných zátvorkách v jeho vnútri.
\TODO ale na samotné matchovanie vnútri potrebuje aj spätné referencie

\begin{df}
Zátvorka $)$ v regexe $\alpha$ je \textbf{indexovateľná}, ak k nej prislúchajúca otváracia zátvorka je indexovateľná.
\end{df}

\begin{df}
Regex $\alpha$ je \textbf{alternovateľný}, ak zodpovedá jednému z týchto tvarov:
\begin{itemize}
\item prázdny regex
\item $a\in\Sigma$ 
\item $a*$, kde $a\in\Sigma$
\item $(\beta)$, kde $\beta$ je ľubovoľný regex z rovnakej triedy ako $\alpha$
\item $(\beta)*$, kde $\beta$ je ľubovoľný regex z rovnakej triedy ako $\alpha$
\item $\backslash k$
\item $\backslash k *$
\end{itemize}
\end{df}

\begin{lema}
Alternácia používa iba alternovateľné regexy.
\end{lema}
\begin{proof}
Dokážeme sporom. Majme regex $\alpha = \beta | \gamma$, kde $\beta,\gamma$ sú všetky členy alternácie a nech $\beta$ nie je alternovateľná. Môžu nastať 3 prípady:

1. $\beta$ má na konci $|$. Potom $\beta = \beta'|$ a členy alternácie v $\alpha$ sú $\beta', \gamma$ a prázdny regex. To je spor s predpokladom.

2. $\beta$ končí lookaroundom, ale lookaround sa nedá alternovať.

3. $\beta = \beta_1\beta_2$. Alternácia berie posledný ucelený regex, takže $\beta$ nemôže byť členom alternácie.
\end{proof}

\TODO: krok výpočtu/krok zhody/posun/...
\begin{df}
\textbf{Krok výpočtu} je relácia $\vdash$ na konfiguráciách definovaná nasledovne:
\begin{itemize}
\item $\forall a \in \Sigma: ~(r_1 \dots \lceil a \dots r_n, w_1 \dots \lceil a \dots w_m) \vdash (r_1 \dots a\lceil \dots r_n, w_1 \dots a \lceil \dots w_m)$
\item Nech ( je indexovateľná, $k$-ta v poradí: $$ (r_1 \dots \lceil ( \dots r_n, w_1 \dots \lceil w_j \dots w_m) \vdash (r_1 \dots (\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^k \dots w_m)$$
Ak za jej uzatváracou zátvorkou nasleduje $*$, t.j. $\alpha$ je tvaru $r_1 \dots \lceil ( \dots ) * \dots r_n$, potom $$ \vdash (r_1 \dots (\dots )* \lceil \dots r_n, w_1 \dots \lceil \mathop{\mathop{w_j}^k}^{k'} \dots w_m ) $$
\item Nech ) je indexovateľná, $k$-ta v poradí: $$ (r_1 \dots \lceil ) \dots r_n, w_1 \dots \lceil w_j \dots w_m) \vdash (r_1 \dots )\lceil \dots r_n, w_1 \dots \lceil \mathop{w_j}^{k'} \dots w_m)$$
\item Nech podslová $\alpha_1, \alpha_2,\dots,\alpha_A$ regexu $\alpha$ sú všetkými členmi zobrazenej alternácie: $(r_1 \dots \lceil \alpha_1 | \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$
$$(1) \vdash \textit{ďalší prechod v }\alpha_1$$
$$(2) \vdash (r_1 \dots \alpha_1 | \lceil \alpha_2 | \dots | \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
$$\dots$$
$$(a) \vdash (r_1 \dots \alpha_1 | \alpha_2 | \dots | \lceil \alpha_A \dots r_n, w_1\dots \lceil w_j \dots w_m)$$
\item $\displaystyle{(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k\lceil * \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)\footnotemark}$
\footnotetext{Podľa definície spätných referencií platí podsledné podslovo nájdené regexom v $k$-tych zátvorkách. Pri tejto pracovnej pozícii v regexe je zrejmé, že nejde o prvý prechod cez tieto zátvorky a teda existuje také $a,b$, že $k$ je v slove nad $w_a$ a $k'$ nad $w_b$. Ak nastane prechod (2), pôvodné horné indexy $k, k'$ miznú a pridáva sa $k$ nad $w_j$.}
$$(1) ~\vdash(r_1 \dots \mathop{(}_kr_i \dots r_l\mathop{)}_k *\lceil \dots r_n, w_1 \dots \mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j \dots w_m)$$
$$(2) ~\vdash(r_1 \dots \mathop{(}_k\lceil r_i \dots r_l\mathop{)}_k * \dots r_n, w_1 \dots w_a \dots w_b \dots \lceil \mathop{w_j}^k \dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots\mathop{w_b}^{k'}\dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\intercal\mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)$$	
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\intercal\mathop{w_a}^k \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\intercal \dots \mathop{w_b}^{k'} \dots w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots \intercal w_c \dots \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$ a zároveň $w_c = w_j$\footnote{$w_c$ a $w_j$ môžu byť poschodové symboly, avšak pri tejto rovnosti poschodia ignorujeme -- chceme porovnať iba písmenká v slove, prislúchajúce týmto pozíciám.}
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots w_c\intercal \dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots \intercal  \mathop{w_b}^{k'} \dots \lceil w_j\dots w_m)}$ a zároveň $w_b = w_j$
$$\vdash(r_1 \dots \lceil \backslash k \dots r_n,w_1\dots\mathop{w_a}^k\dots \mathop{w_b}^{k'} \dots  w_j\lceil\dots w_m)$$
\item $\displaystyle{(r_1\dots \lceil (?=\dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$, nech ukazuje na $k$-ty pozitívny lookahead v poradí
$$ \vdash(r_1\dots (?=\lceil\dots) \dots r_n, w_1\dots\lceil \mathop{w_j}^{\mathop{k}^\rightarrow}\dots w_m ) $$
\item $\displaystyle{(r_1\dots (?=\dots\lceil) \dots r_n, w_1\dots \mathop{w_l}^{\mathop{k}^\rightarrow}\dots\lceil w_j\dots w_m )}$, nech ukazuje na zatváraciu zátvorku $k$-teho pozitívneho lookaheadu v poradí
$$ \vdash(r_1\dots (?=\dots)\lceil \dots r_n, w_1\dots \lceil w_l \dots w_j\dots w_m ) $$
\item $\displaystyle{(r_1\dots \lceil (?<=\dots) \dots r_n, w_1\dots\lceil w_j\dots w_m )}$, nech ukazuje na $k$-ty pozitívny lookbehind v poradí, $\forall L\in\lbrace 0,\dots, j-1\rbrace$:
$$ \vdash (r_1\dots (?<=\lceil\dots) \dots r_n, w_1\dots\lceil w_{j-L}\dots \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m ) $$
\item $\displaystyle{(r_1\dots (?<=\dots\lceil) \dots r_n, w_1\dots \lceil \mathop{w_j}^{\mathop{k}^\leftarrow} \dots w_m )}$, nech ukazuje na zatváraciu zátvorku $k$-teho pozitívneho lookbehindu v poradí
$$ \vdash(r_1\dots (?<=\dots)\lceil \dots r_n, w_1 \dots \lceil w_j \dots w_m ) $$
\end{itemize}

\end{df}

\begin{df}
\textbf{Jazyk} generovaný regexom $\alpha$ je množina $$L(\alpha) = \lbrace w~|~platí ~ (\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil) \rbrace$$
\end{df}

\begin{df}
Postupnosť konfigurácií $(\lceil \alpha, \lceil w)\vdash^* (\alpha\lceil, w\lceil) \rbrace$ pre daný regex $\alpha$ a slovo $w$ nazývame \textbf{akceptačný výpočet}.
\end{df}

\begin{lema}
Nech $\alpha \in \le$ a $w \in L(\alpha)$. Potom existuje akceptačný výpočet, ktorý má najviac $O(|\alpha|*|w|)$ krokov.
\end{lema}
\begin{proof}

\end{proof}

\begin{veta}
$L(regex\#word) \in NSPACE(r \log w)$, kde $r = |regex|,~w = |word|$ a $regex \in \le$.
\end{veta}
\begin{proof}
\TODO
\end{proof}

\begin{veta}
$L(regex\#word) \in DSPACE(n \log^2 n)$, kde $regex \in \le$ a $n$ je dĺžka vstupu.
\end{veta}
\begin{proof}
\TODO
\end{proof}


\section[Popisná zložitosť]{Popisná zložitosť moderných regulárnych výrazov}
\label{vzlozitost}

V tejto kapitole rozoberieme moderné regulárne výrazy z dvoch hľadísk. Najprv nás bude zaujímať, ako pomohli nové konštrukcie pri popise regulárnych jazykov a potom prejdeme na analýzu dĺžky výrazov pre zložitejšie jazyky.

Lookaround môže výrazne pomôcť pri definovaní konečných jazykov, napríklad le-regex z \cite[Poznámka 1.]{mojaBak}
$\beta = ((?=(a^m)*\mathdollar )a^{m+1})*a \lbrace 1,m-1 \rbrace \mathdollar$. Aké slová obsahuje?
\begin{itemize}
\item $a^{m+1+(m-1)}$
\item $a^{2m+2+(m-2)}$ \\
	  ~~~~~~~\vdots
\item $a^{(m-1)(m+1)+1}$
\end{itemize}
avšak $a^{m(m+1)} \notin L(\beta )$, lebo nám chýba zvyšok $0$. Zaujímavé je, že le-regex využíva iteráciu $(m-1)$--krát a napriek tomu je konečný.
